Presentation of file contents for project located at: C:\Users\aperonylo\Desktop\python\__NASMCrypto\cc-app
=================================================================

```text
// .gitignore
# Node.js
node_modules/

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Vite
frontend/dist/
frontend/.vite/

# Electron
*.asar
*.asar.unpacked

dist/
release/
win-unpacked/
release_sure/
build/
release_sure$/
dist/
release/
build/
*.exe
# Ignore all build outputs
release_sure$/
release_sure/
dist/
build/
win-unpacked/
*.exe

# OS
.DS_Store
Thumbs.db

# dotenv
env/
*.env
*.env.local

# Babel
backend/dist/

# Editor
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
```

```text
// LICENSE
MIT License

Copyright (c) 2025 Rahil Vahora

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

```json
// package.json
{
    "name": "nasm-cryptor",
    "version": "1.0.0",
    "description": "Advanced cryptographic application using the NASMFAG principle.",
    "main": "electron/main.js",
    "scripts": {
        "start": "concurrently  \"npm:dev:vite\" \"npm:dev:electron\"",
        "dev:vite": "vite frontend",
        "dev:electron": "wait-on tcp:5173 && electron .",
        "build": "vite build frontend && electron-builder",
        "test": "echo \"Error: no test specified\" && exit 1",
        "rebuild": "npx @electron/rebuild --force --module-dir ."
    },
    "author": "Dan",
    "license": "MIT",
    "dependencies": {
        "better-sqlite3": "^11.1.2",
        "cors": "^2.8.5",
        "express": "^4.21.2",
        "nedb-promises": "^6.2.3",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "react-draggable": "^4.4.6",
        "react-resizable": "^3.0.5"
    },
    "devDependencies": {
        "@electron/rebuild": "^3.6.0",
        "@vitejs/plugin-react": "^4.3.1",
        "autoprefixer": "^10.4.19",
        "concurrently": "^8.2.2",
        "electron": "^31.2.1",
        "electron-builder": "^25.1.8",
        "postcss": "^8.4.39",
        "tailwindcss": "^3.4.6",
        "vite": "^5.3.4",
        "wait-on": "^7.2.0"
    },
    "build": {
        "appId": "com.cognicanvas.app",
        "productName": "CogniCanvas",
        "files": [
            "frontend/dist/",
            "electron/",
            "backend/",
            "node_modules/",
            "package.json"
        ],
        "directories": {
            "buildResources": "assets",
            "output": "release"
        },
        "win": {
            "target": "nsis",
            "publisherName": "YourName",
            "verifyUpdateCodeSignature": false
        },
        "nsis": {
            "oneClick": false,
            "allowToChangeInstallationDirectory": true
        }
    }
}
```

```md
// readme.md
# React Frontend + Vite + Node.js Backend + Electron

A complete setup for building a cross-platform desktop application using React (frontend), Vite (development tooling), Node.js (backend), and Electron (desktop environment). This project serves as a template for developers looking to build modern desktop applications with a lightweight backend.

---

## Features

- **Frontend**: React powered by Vite for fast builds and development.
- **Backend**: Node.js with Express and ES6+.
- **Electron**: Cross-platform desktop application framework.
- **Integrated Workflow**:
  - Single command to run frontend, backend, and Electron together.
  - Easy packaging for production with `electron-builder`.

---

## Getting Started

### Prerequisites

- **Node.js**: Install from [Node.js website](https://nodejs.org/).

---

### Installation

1. Clone the repository:

   ```bash
   git clone https://github.com/rahil1202/react-electron-vite-template.git
   cd electron-react-vite-template
   ```

2. Install dependencies:

   ```bash
   npm install 
   cd frontend && npm install
   cd backend && npm install
   ```

---

### Development

To run the project in development mode:
Go to root directory

```bash
npm run dev
```

This will:

- Start the **React frontend** (`http://localhost:5173`).
- Start the **Node.js backend** (`http://localhost:4000`).
- Launch the **Electron desktop application**.

---

### Build for Production

1. Build the React frontend:

   ```bash
   npm run build
   ```

2. Package the app for distribution:

   ```bash
   npx electron-builder
   ```
If it fails run terminal as administrator and then run above code again.

3. The packaged app will be available in the `dist/` directory, with name `react-electron-vite-template Setup.exe`
   You may install it and use it. It can be share across easily

---

### Project Structure

```plaintext
project/
â”œâ”€â”€ backend/            # Node.js backend
â”‚   â”œâ”€â”€ src/            # Backend source code
â”‚   â””â”€â”€ package.json    # Backend dependencies
â”‚
â”œâ”€â”€ frontend/           # React frontend (with Vite)
â”‚   â”œâ”€â”€ src/            # React source code
â”‚   â””â”€â”€ package.json    # Frontend dependencies
â”‚
â”œâ”€â”€ electron/           # Electron main and preload scripts
â”‚   â”œâ”€â”€ main.js         # Main process
â”‚   â””â”€â”€ preload.js      # Preload script
â”‚
â”œâ”€â”€ package.json        # Root dependencies for Electron
â””â”€â”€ README.md           # Project documentation
```

---

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## Author

- GitHub: [rahil1202](https://github.com/rahil1202)
- Email: <rahilisvahora@gmail.com>
- LinkedIn:[rahil-vahora](https://linkedin.com/in/rahil-vahora)
```

```md
// readme_todo_next.md
To move **CogniCanva** toward a professional, Google-like desktop environment, we must address the remaining technical debt and functional gaps.

Here is the thorough list of problems categorized by priority:

### 1. High Priority: Data Integrity & OS Architecture
*   **Database Migration Reliability:** The current "on-the-fly" migration for the `rating` column is a hotfix. We need a robust versioning system for `cognicanvas.db` so that future schema changes (like adding efficiency rates) don't crash the app.
*   **Window Z-Index Management:** Currently, when multiple windows (Cryptor, Settings, Tasks) are open, clicking one doesn't necessarily bring it to the "front." We need a "Focus" system where the active window's Z-index is incremented.
*   **Shortcuts Path Normalization:** On Windows, paths like `C:/Users` vs `C:\Users` can break `child_process.exec`. We need a centralized backend utility to sanitize paths before executing `start ""`.
*   **Global Settings Persistence:** The `settings` table is implemented, but the Frontend doesn't yet load the theme (Canvas color) or saved shortcuts automatically on startup.

### 2. High Priority: Canvas Mechanics (CogniCanvas)
*   **Recursive Frame Movement:** If a Frame is inside another Frame (nested structure), the movement logic currently only moves direct children. We need recursive coordinate updates.
*   **Drag-to-Capture Precision:** The "Note Capture" logic currently uses a simple center-point check. This can feel "glitchy" with large notes and small frames. It needs a "Collision Detection" algorithm (AABB intersection).
*   **Teleport Links (Broken/Missing):** The `[[note:id]]` syntax is parsed, but clicking the link doesn't yet "pan and zoom" the camera to the target note.
*   **Note Scaling vs Content:** When a note is resized very small, the `TagManager` and `Content` overlap and become unreadable. We need "Adaptive UI" (hiding the tag bar if the height is < 100px).

### 3. Functional Gaps: The MPSI App Suite
*   **The "Calendar/Efficiency" Gap:** Tasks are logged, but there is no UI to see the history. We need a "Log Viewer" app that displays sessions by day, showing the calculated efficiency (Time vs Rating).
*   **Chronometer Persistence:** If the app is closed while a timer is running, the `start_time` is saved, but the UI doesn't "resume" the count automatically when the app restarts.
*   **Task Widget Customization:** Unlike Notes, Tasks don't yet have the right-click color picker or the ability to change their individual background colors.

### 4. Technical Debt: Performance & Warnings
*   **The "findDOMNode" Plague:** While fixed in `TaskWidget` and `WindowFrame`, this warning likely still exists in `Frame.jsx` and `Note.jsx`. Every `Draggable` instance must be verified for `nodeRef` usage.
*   **Canvas Render Bottleneck:** Re-rendering the entire canvas (every note and frame) when one note moves is inefficient. We should move to a more optimized state management (like `Zustand` or localized state) to prevent "Note Jitter."
*   **Search Regex Support:** The search currently only supports simple strings. For MPSI students, Regex support (e.g., searching `math|physics`) is a high-value tool.

### 5. Cryptor 2.0 (The Standalone Rework)
*   **Key Generator UI:** The current "Key Vault" is too simple. It needs a "Pro Mode" where the user can choose the NASM Degree (`d`), the specific mathematical operations (`I`), and the Transformation Constants (`TC`) manually.
*   **Large File Streaming:** Encrypting a 1GB file currently loads the whole buffer into memory, which will crash the app. We need to move from `fs.readFile` to `fs.createReadStream` to handle large MPSI lecture videos.

### 6. UX & "Google-Like" Polish
*   **Command Palette:** Implement `Ctrl + K` to open a global search bar (like Google Search or Spotlight) that can launch apps, search notes, or trigger system commands.
*   **Desktop "Dock" Feedback:** Icons in the left dock don't show "Active" indicators (e.g., a small dot underneath) if an app is open but minimized/behind others.

---

**Which one should we solve next?**
1.  **The "Front-End Focus" (Z-index + Teleport Links + nodeRef cleanup)**
2.  **The "Task Evolution" (Calendar/History App + Chronometer persistence)**
3.  **The "Cryptor 2.0" (Pro Key Gen + Large File Streaming)**

---

Understood. I have integrated the new crash report into the master list. Here is the thorough breakdown of all current issues and technical debt within **CogniCanva**.

### Group A: Critical Crashes & System Errors
1.  **Canvas Rendering Crash (`ReferenceError: view is not defined`):** The recent refactor from `view` state to `viewRef` caused a break in the JSX render. Line 252 is attempting to access a variable `view` that no longer exists in that scope.
2.  **Database Schema Mismatch (`SqliteError: no such column: rating`):** The backend is attempting to write to columns that don't exist in the user's local `cognicanvas.db`. The migration script failed to execute or was blocked.
3.  **Double-Click "Forbidden Area":** Clicks inside the note-populated area of the canvas fail to create new notes because the `transform-layer` is capturing pointer events without a proper fallback to the container.

### Group B: UI/UX & Mechanics (The "Desktop" Feel)
1.  **Zoom Anchor Logic:** Zooming currently centers on the top-left (0,0) or a static center rather than the user's mouse pointer, making navigation disorienting.
2.  **The "Inertia" Conflict:** Note/Frame movement feels laggy because CSS transitions are conflicting with real-time `react-draggable` coordinate updates.
3.  **Frame-Child Synchronization:** When a Frame moves, the notes inside must move recursively. When a Frame collapses, the notes must be visually and functionally "unmounted" to prevent accidental interaction.
4.  **`findDOMNode` Deprecation Warnings:** Several components (`TaskWidget`, `Note`, `Frame`) are triggering StrictMode warnings that will cause issues in future React versions.

### Group C: MPSI Suite (Tasks & Chronometer)
1.  **Task Widget UX:** Tasks currently lack a "Seconds" display, a functional "Stop" button in the UI, and a resize handle.
2.  **Chronometer Persistence:** If the app restarts, running timers do not visually resume counting despite being active in the database.
3.  **Session History (The "Calendar" Data):** We have the data structure for `ratings` and `session_notes`, but no interface to view the history of study sessions.
4.  **Task Color/Tag Integration:** Tasks need the same tagging and color-customization logic as Notes to allow for future "Efficiency Filtering."

### Group D: System Services & Apps
1.  **Settings App (The Control Panel):** No functional UI exists to manage theme colors (stored in DB) or to add/delete shortcuts using a native file picker.
2.  **Shortcut Path Normalization:** Windows paths (`\` vs `/`) are causing silent failures or defaulting to `C:/` when launching external MPSI apps.
3.  **Cryptor 2.0:** The encryption tool needs to be converted from a dashboard page to a standalone floating window with a "Vault" for managing NASM keys.

### Group E: Advanced Power Features
1.  **Teleport Links:** The `[[note:id]]` links are rendered but do not yet trigger the Canvas to pan/zoom to the target coordinate.
2.  **Command Palette (`Ctrl + K`):** No global search/action bar exists to allow "Google-like" navigation through the OS.
3.  **Search Regex Support:** Search is currently limited to plain text; complex filtering for MPSI study (e.g., `math AND urgent`) is missing.

---

**Which specific problem should we tackle first?** 
*(I recommend starting with **A1** and **A2** to stop the app from crashing, or **D1** to build the foundation for theme customization).*
```

```text
// TODO
# TODOs for NASM Crypto

- [ ] error window not showing + error
- [ ] last prompt to execute (subtle addition to add)
```

```py
// tree.py
#!/usr/bin/env python3
import os
import sys

# -----------------------------------------------------------------------------
# CONFIGURATION
# -----------------------------------------------------------------------------

# Folders to exclude from the tree to save performance/screen space
DIR_BLACKLIST = {
    '.git', 
    '.github', 
    '.vscode', 
    '__pycache__', 
    'node_modules', 
    'win-unpacked', 
    '.venv', 
    'target', 
    'build', 
    'dist'
}

# Files to exclude (optional, strictly exact match)
FILE_BLACKLIST = {
    
}

# UTF-8 Box Drawing Characters
PIPE = "â”‚   "
TEE  = "â”œâ”€â”€ "
LAST = "â””â”€â”€ "
SPACE= "    "

# -----------------------------------------------------------------------------
# LOGIC
# -----------------------------------------------------------------------------

def print_tree(directory_path, prefix=""):
    """
    Recursively prints the file structure of the given directory.
    """
    # Verify path exists
    if not os.path.exists(directory_path):
        print(f"Error: Directory '{directory_path}' not found.")
        return

    # Get list of files and directories
    try:
        entries = os.listdir(directory_path)
    except PermissionError:
        print(f"{prefix}[Access Denied]")
        return
    except OSError as e:
        print(f"{prefix}[Error: {e}]")
        return

    # Filter out blacklisted items
    filtered_entries = [
        e for e in entries 
        if e not in DIR_BLACKLIST and e not in FILE_BLACKLIST
    ]

    # Sort: Directories first, then files (Case insensitive)
    filtered_entries.sort(key=lambda x: (
        not os.path.isdir(os.path.join(directory_path, x)), 
        x.lower()
    ))

    total = len(filtered_entries)
    
    for i, entry in enumerate(filtered_entries):
        # Determine if this is the last item in the current branch
        is_last = (i == total - 1)
        
        path = os.path.join(directory_path, entry)
        is_dir = os.path.isdir(path)
        is_link = os.path.islink(path)
        
        # specific visual markers
        marker = LAST if is_last else TEE
        
        # Format the name (add trailing slash for dirs, arrows for symlinks)
        display_name = entry
        if is_link:
            try:
                target = os.readlink(path)
                display_name = f"{entry} -> {target}"
            except OSError:
                display_name = f"{entry} -> [unknown]"
        elif is_dir:
            display_name = f"{entry}/"

        # Print the current item
        print(f"{prefix}{marker}{display_name}")

        # Recurse if it is a directory and NOT a symlink 
        # (following symlinks can lead to infinite recursion)
        if is_dir and not is_link:
            # Prepare the prefix for the children
            extension = SPACE if is_last else PIPE
            print_tree(path, prefix + extension)

# -----------------------------------------------------------------------------
# ENTRY POINT
# -----------------------------------------------------------------------------

if __name__ == "__main__":
    # Use current working directory by default, or argument if provided
    root_dir = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()
    
    root_name = os.path.basename(os.path.abspath(root_dir))
    if not root_name: root_name = root_dir # Handle root drive case

    print(f"\033[1m{root_name}/\033[0m") # Bold root name
    print_tree(root_dir)
```

```js
// backend\add_test_node.js
import Database from 'better-sqlite3';
const db = new Database('cognicanvas.db');

const stmt = db.prepare(
    'INSERT INTO notes (content, pos_x, pos_y, width, height, color_hex) VALUES (?, ?, ?, ?, ?, ?)'
);

stmt.run('Hello, World!', 100, 150, 200, 200, '#FFFF88');

console.log('Test note added to cognicanvas.db');
```

```js
// backend\server.js
// backend/server.js
const express = require('express');
const cors = require('cors');
const Database = require('better-sqlite3');
const path = require('path');
const fileService = require('./services/file-service');
const dbService = require('./services/db-service');
const systemService = require('./services/system-service');

const PORT = 4000;
const app = express();

const SECRET_TOKEN = process.argv[2];
const USER_DATA_PATH = process.argv[3];

if (!SECRET_TOKEN || !USER_DATA_PATH) {
  console.error('FATAL ERROR: Server started without token or path.');
  process.exit(1);
}

app.use(cors());
app.use(express.json());

// Security Middleware
app.use((req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || authHeader !== `Bearer ${SECRET_TOKEN}`) {
    return res.status(403).json({ error: 'Forbidden: Invalid token.' });
  }
  next();
});


const db = new Database("cognicanvas.db");
db.pragma("foreign_keys = ON");

// 1. INITIAL SCHEMA
db.exec(`
  CREATE TABLE IF NOT EXISTS frames (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, pos_x INTEGER, pos_y INTEGER, width INTEGER, height INTEGER, is_collapsed BOOLEAN DEFAULT 0);
  CREATE TABLE IF NOT EXISTS notes (id INTEGER PRIMARY KEY AUTOINCREMENT, content TEXT, pos_x INTEGER, pos_y INTEGER, width INTEGER, height INTEGER, color_hex TEXT, frame_id INTEGER, FOREIGN KEY (frame_id) REFERENCES frames(id) ON DELETE CASCADE);
  CREATE TABLE IF NOT EXISTS tags (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL UNIQUE, color_hex TEXT DEFAULT '#3b82f6');
  CREATE TABLE IF NOT EXISTS note_tags (note_id INTEGER, tag_id INTEGER, PRIMARY KEY (note_id, tag_id), FOREIGN KEY (note_id) REFERENCES notes(id) ON DELETE CASCADE, FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE);
  CREATE TABLE IF NOT EXISTS frame_tags (frame_id INTEGER, tag_id INTEGER, PRIMARY KEY (frame_id, tag_id), FOREIGN KEY (frame_id) REFERENCES frames(id) ON DELETE CASCADE, FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE);
  CREATE TABLE IF NOT EXISTS tasks (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, is_done BOOLEAN DEFAULT 0, created_at INTEGER, total_time_ms INTEGER DEFAULT 0, color_hex TEXT DEFAULT '#1f2937');
  CREATE TABLE IF NOT EXISTS time_logs (id INTEGER PRIMARY KEY AUTOINCREMENT, task_id INTEGER, start_time INTEGER, end_time INTEGER, FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE);
  CREATE TABLE IF NOT EXISTS task_tags (task_id INTEGER, tag_id INTEGER, PRIMARY KEY (task_id, tag_id), FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE, FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE);
  CREATE TABLE IF NOT EXISTS shortcuts (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, target TEXT, type TEXT DEFAULT 'url', icon TEXT DEFAULT 'ðŸš€');
  CREATE TABLE IF NOT EXISTS settings (key TEXT PRIMARY KEY, value TEXT);
`);

// 2. FORCED MIGRATION (Fixes the "no such column: rating" error)
const migrate = () => {
    const columns = db.prepare("PRAGMA table_info(time_logs)").all();
    const hasRating = columns.some(c => c.name === 'rating');
    if (!hasRating) {
        console.log("Migrating time_logs table...");
        db.exec("ALTER TABLE time_logs ADD COLUMN rating INTEGER DEFAULT 0;");
        db.exec("ALTER TABLE time_logs ADD COLUMN session_notes TEXT;");
    }
    const taskCols = db.prepare("PRAGMA table_info(tasks)").all();
    if (!taskCols.some(c => c.name === 'color_hex')) {
        db.exec("ALTER TABLE tasks ADD COLUMN color_hex TEXT DEFAULT '#1f2937';");
    }
};
migrate();


const getTagsFor = (table, id) => {
  return db.prepare(`SELECT t.name, t.color_hex FROM tags t JOIN ${table}_tags nt ON t.id = nt.tag_id WHERE nt.${table}_id = ?`).all(id);
};

// --- API ROUTES: CANVAS ---
// 2. NEW ROUTES FOR SHORTCUTS
app.get("/api/shortcuts", (req, res) => {
    try {
        const shortcuts = db.prepare("SELECT * FROM shortcuts").all();
        res.json(shortcuts);
    } catch (e) { res.status(500).json({ error: e.message }); }
});

app.post("/api/shortcuts", (req, res) => {
    try {
        const { title, target, type } = req.body;
        const stmt = db.prepare("INSERT INTO shortcuts (title, target, type) VALUES (?, ?, ?)");
        const info = stmt.run(title, target, type);
        res.json({ id: info.lastInsertRowid, ...req.body });
    } catch (e) { res.status(500).json({ error: e.message }); }
});

app.delete("/api/shortcuts/:id", (req, res) => {
    db.prepare("DELETE FROM shortcuts WHERE id = ?").run(req.params.id);
    res.json({ success: true });
});

// 3. NEW ROUTES FOR SETTINGS
app.get("/api/settings", (req, res) => {
    const rows = db.prepare("SELECT * FROM settings").all();
    const settings = {};
    rows.forEach(r => settings[r.key] = r.value);
    res.json(settings);
});

app.post("/api/settings", (req, res) => {
    const { key, value } = req.body;
    db.prepare("INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)").run(key, value);
    res.json({ success: true });
});
// --- UPDATE GET /api/all (Include Task Tags) ---
app.get("/api/all", (req, res) => {
  const notes = db.prepare("SELECT * FROM notes").all().map(n => ({ ...n, tags: getTagsFor("note", n.id) }));
  const frames = db.prepare("SELECT * FROM frames").all().map(f => ({ ...f, tags: getTagsFor("frame", f.id) }));
  
  // Update Task Fetching
  const tasks = db.prepare("SELECT * FROM tasks").all().map(task => {
    const activeLog = db.prepare("SELECT start_time FROM time_logs WHERE task_id = ? AND end_time IS NULL").get(task.id);
    // NEW: Get Tags for task
    const tags = getTagsFor("task", task.id); 
    return {
      ...task,
      is_running: !!activeLog,
      current_session_start: activeLog ? activeLog.start_time : null,
      tags: tags // <--- Added
    };
  });

  res.json({ notes, frames, tasks });
});

app.post("/api/notes", (req, res) => {
  const { content, pos_x, pos_y, width, height, color_hex } = req.body;
  const info = db.prepare("INSERT INTO notes (content, pos_x, pos_y, width, height, color_hex) VALUES (?, ?, ?, ?, ?, ?)").run(content, pos_x, pos_y, width, height, color_hex);
  res.status(201).json({ id: info.lastInsertRowid, ...req.body, tags: [] });
});

app.put("/api/notes/:id", (req, res) => {
  const { content, pos_x, pos_y, width, height, color_hex } = req.body;
  db.prepare("UPDATE notes SET content = COALESCE(?, content), pos_x = COALESCE(?, pos_x), pos_y = COALESCE(?, pos_y), width = COALESCE(?, width), height = COALESCE(?, height), color_hex = COALESCE(?, color_hex) WHERE id = ?")
    .run(content, pos_x, pos_y, width, height, color_hex, req.params.id);
  res.json({ success: true });
});

app.delete("/api/notes/:id", (req, res) => {
  db.prepare("DELETE FROM notes WHERE id = ?").run(req.params.id);
  res.json({ success: true });
});

// --- API ROUTES: TAGS (The fix for your 404) ---

// --- UPDATE TAG ROUTE (Support Tasks) ---
// Find your existing app.post("/api/tags/:itemType/:itemId"...) and replace it with:
app.post("/api/tags/:itemType/:itemId", (req, res) => {
  const { itemType, itemId } = req.params; 
  const { name } = req.body;
  
  // Map URL param to DB table prefix
  let table;
  if (itemType === 'notes') table = 'note';
  else if (itemType === 'frames') table = 'frame';
  else if (itemType === 'tasks') table = 'task';
  else return res.status(400).json({ error: "Invalid item type" });
  
  db.transaction(() => {
    let tag = db.prepare("SELECT id FROM tags WHERE name = ?").get(name);
    if (!tag) {
      const info = db.prepare("INSERT INTO tags (name) VALUES (?)").run(name);
      tag = { id: info.lastInsertRowid };
    }
    db.prepare(`INSERT OR IGNORE INTO ${table}_tags (${table}_id, tag_id) VALUES (?, ?)`).run(itemId, tag.id);
  })();
  res.status(201).json({ message: "Tag added" });
});

app.delete("/api/:itemType/:itemId/tags/:tagName", (req, res) => {
  const { itemType, itemId, tagName } = req.params;
  let table;
  if (itemType === 'notes') table = 'note';
  else if (itemType === 'frames') table = 'frame';
  else if (itemType === 'tasks') table = 'task';
  
  const tag = db.prepare("SELECT id FROM tags WHERE name = ?").get(tagName);
  if (tag) {
    db.prepare(`DELETE FROM ${table}_tags WHERE ${table}_id = ? AND tag_id = ?`).run(itemId, tag.id);
  }
  res.json({ message: "Tag removed" });
});
// Update tag color
app.put("/api/tags/:name", (req, res) => {
  db.prepare("UPDATE tags SET color_hex = ? WHERE name = ?").run(req.body.color_hex, req.params.name);
  res.json({ success: true });
});

// --- FIXED KEY ROUTES ---
app.get('/api/keys', async (req, res) => {
  try {
    const keys = await dbService.getKeys();
    res.json(keys || []);
  } catch (err) { res.status(500).json({ error: err.message }); }
});

app.post('/api/keys', async (req, res) => {
  try {
    // Ensure we handle both creation and updates
    const result = await dbService.saveKey(req.body);
    res.json({ success: true, result });
  } catch (err) { res.status(500).json({ error: err.message }); }
});

app.delete('/api/keys/:id', async (req, res) => {
  try {
    await dbService.deleteKey(req.params.id);
    res.json({ success: true });
  } catch (err) { res.status(500).json({ error: err.message }); }
});

// --- FIXED CRYPTO ROUTES ---
app.post('/api/encrypt', async (req, res) => {
  const { filePath, keyConfig, intensity, savePath } = req.body;
  // Passing empty functions as fallback progress/notify handlers
  const result = await fileService.encryptFile(filePath, keyConfig, intensity, savePath, () => {}, () => {});
  res.json(result);
});

app.post('/api/decrypt', async (req, res) => {
  const { filePath, keyConfig, savePath } = req.body;
  const result = await fileService.decryptFile(filePath, keyConfig, savePath, () => {}, () => {});
  res.json(result);
});
app.post('/api/system/open', async (req, res) => res.json(await systemService.openExternal(req.body.target)));

app.listen(PORT, '127.0.0.1', () => {
  console.log(`COGNICANVAS_BACKEND_READY on port ${PORT}`);
  dbService.init(USER_DATA_PATH); 
});

app.put("/api/frames/:id", (req, res) => {
    try {
        const { title, pos_x, pos_y, width, height, is_collapsed } = req.body;
        // Dynamic update similar to notes
        const updates = [];
        const params = [];
        if (title !== undefined) { updates.push("title = ?"); params.push(title); }
        if (pos_x !== undefined) { updates.push("pos_x = ?"); params.push(pos_x); }
        if (pos_y !== undefined) { updates.push("pos_y = ?"); params.push(pos_y); }
        if (width !== undefined) { updates.push("width = ?"); params.push(width); }
        if (height !== undefined) { updates.push("height = ?"); params.push(height); }
        if (is_collapsed !== undefined) { updates.push("is_collapsed = ?"); params.push(is_collapsed); }
        
        params.push(req.params.id);
        
        db.prepare(`UPDATE frames SET ${updates.join(", ")} WHERE id = ?`).run(...params);
        res.json({ success: true });
    } catch (e) { res.status(500).json({ error: e.message }); }
});
// --- MPSI TASKS ROUTES (Fix for 404) ---
app.post("/api/tasks", (req, res) => {
    try {
        const { title } = req.body;
        // Default is_done to 0, total_time_ms to 0
        const stmt = db.prepare("INSERT INTO tasks (title, is_done, created_at, total_time_ms) VALUES (?, 0, ?, 0)");
        const info = stmt.run(title, Date.now());
        res.status(201).json({ id: info.lastInsertRowid, title, is_done: 0, total_time_ms: 0 });
    } catch (error) { res.status(500).json({ error: error.message }); }
});

app.post("/api/tasks/:id/start", (req, res) => {
    try {
        const info = db.prepare("INSERT INTO time_logs (task_id, start_time) VALUES (?, ?)").run(req.params.id, Date.now());
        res.json({ logId: info.lastInsertRowid });
    } catch (error) { res.status(500).json({ error: error.message }); }
});

// 4. UPDATED TASK ROUTES (Stop with Rating)
app.post("/api/tasks/:id/stop", (req, res) => {
    const { rating, notes } = req.body; // New optional params
    const now = Date.now();
    const log = db.prepare("SELECT * FROM time_logs WHERE task_id = ? AND end_time IS NULL").get(req.params.id);
    
    if(log) {
        db.prepare("UPDATE time_logs SET end_time = ?, rating = ?, session_notes = ? WHERE id = ?")
          .run(now, rating || 0, notes || "", log.id);
        
        const duration = now - log.start_time;
        db.prepare("UPDATE tasks SET total_time_ms = total_time_ms + ? WHERE id = ?").run(duration, req.params.id);
        res.json({ success: true, duration });
    } else {
        res.status(400).json({ error: "No running timer" });
    }
});
app.delete("/api/frames/:id", (req, res) => {
    db.prepare("DELETE FROM frames WHERE id = ?").run(req.params.id);
    res.json({ success: true });
});

// ADD THIS ROUTE:
app.post("/api/frames", (req, res) => {
    try {
        const { title, pos_x, pos_y, width, height } = req.body;
        const stmt = db.prepare("INSERT INTO frames (title, pos_x, pos_y, width, height, is_collapsed) VALUES (?, ?, ?, ?, ?, 0)");
        const info = stmt.run(title, pos_x, pos_y, width, height);
        res.status(201).json({ id: info.lastInsertRowid, ...req.body });
    } catch (error) { res.status(500).json({ error: error.message }); }
});
```

```js
// backend\services\db-service.js
// backend/services/db-service.js
const Datastore = require('nedb-promises');
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');
// REMOVED: const { app } = require('electron'); // This caused the crash

// CONSTANTS
const MASTER_PASSWORD = 'this-should-be-securely-obtained-from-user';
const SALT = 'nas-m-cryptor-static-salt';

class DatabaseService {
  constructor() {
    this.db = null;
    this.masterKey = null;
    this.dbPath = null; // Path will be set in init()
  }

  // Initialize: Derived key + Load DB. 
  // userDataPath is passed from server.js (who got it from main.js)
  async init(userDataPath) {
    if (!userDataPath) throw new Error("DatabaseService initialized without path");
    
    this.dbPath = path.join(userDataPath, 'secure.db');
    this.masterKey = crypto.pbkdf2Sync(MASTER_PASSWORD, SALT, 100000, 32, 'sha512');
    await this._load();
  }

  async _load() {
    try {
      const encryptedData = await fs.readFile(this.dbPath);
      const iv = encryptedData.slice(0, 16);
      const authTag = encryptedData.slice(16, 32);
      const ciphertext = encryptedData.slice(32);

      const decipher = crypto.createDecipheriv('aes-256-gcm', this.masterKey, iv);
      decipher.setAuthTag(authTag);
      
      const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
      
      this.db = Datastore.create({ inMemoryOnly: true });
      await this.db.loadDatabase();
      const docs = JSON.parse(decrypted.toString('utf-8'));
      await this.db.insert(docs);
      console.log("Secure DB loaded successfully.");

    } catch (error) {
      console.log("Creating new Secure DB at", this.dbPath);
      this.db = Datastore.create({ inMemoryOnly: true });
    }
  }

  async _persist() {
    if (!this.db) return;
    const docs = await this.db.find({});
    const data = JSON.stringify(docs);
    
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-gcm', this.masterKey, iv);
    
    const encrypted = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()]);
    const authTag = cipher.getAuthTag();

    await fs.writeFile(this.dbPath, Buffer.concat([iv, authTag, encrypted]));
  }

  async getKeys() { return this.db ? this.db.find({ type: 'key' }) : []; }
  
  async saveKey(key) {
    if (!this.db) return null;
    const result = await this.db.update({ _id: key._id }, { ...key, type: 'key' }, { upsert: true });
    await this._persist();
    return result;
  }
  
  async deleteKey(keyId) {
    if (!this.db) return null;
    const result = await this.db.remove({ _id: keyId, type: 'key' });
    await this._persist();
    return result;
  }
  
  async getPeers() { return this.db ? this.db.find({ type: 'peer' }) : []; }
  async addPeer(peerName, seedFilePath) {
      // Stub for peer addition
      const peer = { peerName, seedFilePath, type: 'peer' };
      await this.db.insert(peer);
      await this._persist();
      return peer;
  }
}

module.exports = new DatabaseService();
```

```js
// backend\services\file-service.js
// electron/services/file-service.js
const fs = require('fs').promises;
const path = require('path');
const { dialog } = require('electron');
const { processBuffer } = require('./nasm-engine');

class FileService {
  async encryptFile(filePath, keyConfig, intensity, savePath = null, onProgress = () => {}, onNotify = () => {}) {
    try {
      onProgress(0);
      onNotify({ title: 'Encryption', body: `Reading file ${path.basename(filePath)}...` });
      const sourceBuffer = await fs.readFile(filePath);

      onNotify({ title: 'Encryption', body: `Encrypting... This may take a while.` });
      const encryptedBuffer = processBuffer(sourceBuffer, keyConfig, intensity, (p) => onProgress(p));
      
      let finalSavePath = savePath;
      if (!finalSavePath) {
        const { canceled, filePath: chosenPath } = await dialog.showSaveDialog({
          defaultPath: `${filePath}.nasm`,
        });

        if (canceled || !chosenPath) {
          onNotify({ title: 'Cancelled', body: 'Save operation was cancelled.' });
          return { success: false, error: 'Cancelled by user.' };
        }

        finalSavePath = chosenPath;
      }

      await fs.writeFile(finalSavePath, encryptedBuffer);
      onNotify({ title: 'Success', body: `File successfully encrypted to ${path.basename(finalSavePath)}` });
      return { success: true, path: finalSavePath };

    } catch (error) {
      console.error('Encryption failed:', error);
      onNotify({ title: 'Error', body: `Encryption failed: ${error.message}` });
      return { success: false, error: error.message };
    }
  }

  async decryptFile(filePath, keyConfig, savePath = null, onProgress = () => {}, onNotify = () => {}) {
    // Similar structure to encryptFile, but calls processBuffer and suggests a decrypted filename.
    try {
      onProgress(0);
      onNotify({ title: 'Decryption', body: `Reading file ${path.basename(filePath)}...` });
      const sourceBuffer = await fs.readFile(filePath);

      onNotify({ title: 'Decryption', body: `Decrypting...` });
      const decryptedBuffer = processBuffer(sourceBuffer, keyConfig, 1, (p) => onProgress(p)); // Intensity is 1 for decryption

      const originalName = filePath.endsWith('.nasm') ? filePath.slice(0, -5) : `${filePath}.decrypted`;
      let finalSavePath = savePath;
      if (!finalSavePath) {
        const { canceled, filePath: chosenPath } = await dialog.showSaveDialog({
          defaultPath: originalName,
        });

        if (canceled || !chosenPath) {
          onNotify({ title: 'Cancelled', body: 'Save operation was cancelled.' });
          return { success: false, error: 'Cancelled by user.' };
        }

        finalSavePath = chosenPath;
      }

      await fs.writeFile(finalSavePath, decryptedBuffer);
      onNotify({ title: 'Success', body: `File successfully decrypted to ${path.basename(finalSavePath)}` });
      return { success: true, path: finalSavePath };

    } catch (error) {
      console.error('Decryption failed:', error);
      onNotify({ title: 'Error', body: `Decryption failed: ${error.message}` });
      return { success: false, error: error.message };
    }
  }
}

module.exports = new FileService();
```

```js
// backend\services\nasm-engine.js
// electron/services/nasm-engine.js

// This class encapsulates the entire state and logic of a NASMFAG sequence.
class NASMEngine {
  constructor(config) {
    this._config = config;
    this._cache = {}; // Memoization for performance
    this._parseOperations();
  }

  // CRITICAL: A safe replacement for eval().
  _parseOperations() {
    this._safeOps = this._config.I.map(opPair => {
      const prefix = opPair[0];
      const suffix = opPair[1];
      // In a real scenario, this would be a proper AST parser.
      // For this example, we'll handle simple arithmetic safely.
      const op = suffix.charAt(0);
      const num = parseFloat(suffix.substring(1));
      if (isNaN(num)) throw new Error(`Invalid operation: ${suffix}`);

      return (val) => {
        switch (op) {
          case '+': return val + num;
          case '-': return val - num;
          case '*': return val * num;
          case '/': return val / num;
          default: throw new Error(`Unsupported operator: ${op}`);
        }
      };
    });
  }

  // The core recursive function `f(x)`.
  _f(x) {
    if (x < 0) return 0;
    if (this._cache[x] !== undefined) return this._cache[x];

    let result;
    const { starts, d, TC, minBound, maxBound } = this._config;

    if (x < d) {
      result = starts[x];
    } else {
      let ntc = 0;
      for (let v = 0; v < x - d; v++) ntc += TC[v % TC.length];
      const opIndex = (x - d + ntc) % this._safeOps.length;
      const operation = this._safeOps[opIndex];
      result = operation(this._f(x - d));
    }

    const range = maxBound - minBound;
    if (range <= 0) return minBound;
    let bounded = Math.floor(result);
    this._cache[x] = minBound + ((bounded - minBound) % range + range) % range;
    return this._cache[x];
  }

  // Generator function to produce the keystream byte by byte, saving memory.
  *keystream(length, intensity) {
    for (let i = 0; i < length; i++) {
      let value = i;
      for (let j = 0; j < intensity; j++) {
        value = this._f(value + j * length); // Add complexity
      }
      yield value % 256; // Output a single byte
    }
  }
}

// The public function that services will use.
function processBuffer(sourceBuffer, keyConfig, intensity, onProgress) {
  const engine = new NASMEngine(keyConfig);
  const resultBuffer = Buffer.alloc(sourceBuffer.length);
  const stream = engine.keystream(sourceBuffer.length, intensity);

  for (let i = 0; i < sourceBuffer.length; i++) {
    const keyByte = stream.next().value;
    resultBuffer[i] = sourceBuffer[i] ^ keyByte; // XOR encryption
    if (i % 4096 === 0) {
      onProgress(i / sourceBuffer.length);
    }
  }
  onProgress(1);
  return resultBuffer;
}

module.exports = { processBuffer };
```

```js
// backend\services\p2p-service.js
// electron/services/p2p-service.js
const crypto = require('crypto');
const fs = require('fs').promises;
// const DHT = require('dht-rpc'); // Hypothetical library
// const portKnock = require('port-knocking'); // Hypothetical library
const { dbService } = require('./db-service');
//const dbService = require('./db-service'); // Corrected from { dbService }

class P2PService {
  constructor() {
    // this.dht = new DHT(); // Initialize the DHT client
  }

  async createGenesisSeed(peerName) {
    const seed = crypto.randomBytes(256);
    const savePath = dialog.showSaveDialogSync({ defaultPath: `${peerName}-seed.nasmkey` });
    if (savePath) {
      await fs.writeFile(savePath, seed);
      return savePath;
    }
    return null;
  }

  // Derives the rendezvous strategy for the current time window.
  _getStrategy(seed) {
    const timeWindow = Math.floor(Date.now() / 10000); // 10-second window
    const hmac = crypto.createHmac('sha256', seed);
    hmac.update(String(timeWindow));
    const digest = hmac.digest();

    return {
      mailbox: digest.slice(0, 20), // 20-byte ID for DHT
      knockSequence: [digest.readUInt16BE(20), digest.readUInt16BE(22)],
      handshakeKey: digest.slice(24, 32),
    };
  }

  async sendFile(peerId, filePath, onProgress, onNotify) {
    onNotify({ title: 'P2P', body: `Preparing to send to peer ${peerId}...` });
    const peer = await dbService.getPeerById(peerId);
    if (!peer) throw new Error('Peer not found.');

    const strategy = this._getStrategy(peer.genesisSeed);

    // 1. Announce presence on the DHT
    // const myIp = await getPublicIp();
    // this.dht.put(strategy.mailbox, Buffer.from(myIp));

    // 2. Listen for their IP and initiate port knock.
    // ... complex logic for listening and knocking ...

    onNotify({ title: 'P2P', body: `Connection established. Sending file...` });
    // 3. Once connected, stream the file.
  }
}

module.exports = new P2PService();
```

```js
// backend\services\system-service.js
// backend/services/system-service.js
const { exec, spawn } = require('child_process');
const path = require('path');
const os = require('os');

class SystemService {
  
  // Open a URL or File using the default OS handler
  async openExternal(target) {
    const platform = os.platform();
    let command;
    
    // NORMALIZE PATH: Fix mixed slashes for Windows
    const safeTarget = path.normalize(target);

    if (platform === 'win32') {
      // WINDOWS FIX: 
      // 1. "start" needs a dummy title argument ("") before the path.
      // 2. We wrap the path in quotes to handle spaces.
      command = `start "" "${safeTarget}"`;
    } else if (platform === 'darwin') {
      command = `open "${safeTarget}"`;
    } else {
      command = `xdg-open "${safeTarget}"`;
    }

    console.log(`[System] Executing: ${command}`); // Debug log

    return new Promise((resolve) => {
      exec(command, (error) => {
        if (error) {
            console.error(`[System] Exec error: ${error.message}`);
            resolve({ success: false, error: error.message });
        } else {
            resolve({ success: true });
        }
      });
    });
  }

  // Execute a specific command (e.g., Run a Python script for MPSI)
  async runCommand(command, args = []) {
    return new Promise((resolve, reject) => {
      const process = spawn(command, args, { shell: true });
      
      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => stdout += data.toString());
      process.stderr.on('data', (data) => stderr += data.toString());

      process.on('close', (code) => {
        resolve({ 
            success: code === 0, 
            output: stdout, 
            error: stderr,
            code 
        });
      });
    });
  }
}

module.exports = new SystemService();
```

```js
// backend\src\index.js
// MODIFIED: Replaced ES Module imports with CommonJS requires
const express = require("express");
const cors = require("cors");
const Database = require("better-sqlite3");

const app = express();
const PORT = 4000;
app.use(cors());
app.use(express.json());

const db = new Database("cognicanvas.db");

// This pragma command is critical for data integrity.
db.pragma("foreign_keys = ON");

// --- DATABASE SCHEMA ---
// The schema remains the same, using ON DELETE CASCADE for robust deletions.
db.exec(`
  CREATE TABLE IF NOT EXISTS frames ( id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT DEFAULT 'New Frame', pos_x INTEGER, pos_y INTEGER, width INTEGER, height INTEGER, is_collapsed BOOLEAN DEFAULT 0 );
  CREATE TABLE IF NOT EXISTS notes ( id INTEGER PRIMARY KEY AUTOINCREMENT, content TEXT, pos_x INTEGER, pos_y INTEGER, width INTEGER, height INTEGER, color_hex TEXT, frame_id INTEGER, FOREIGN KEY (frame_id) REFERENCES frames(id) ON DELETE CASCADE );
  CREATE TABLE IF NOT EXISTS tags ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL UNIQUE, color_hex TEXT DEFAULT '#3b82f6' );
  CREATE TABLE IF NOT EXISTS note_tags ( note_id INTEGER, tag_id INTEGER, PRIMARY KEY (note_id, tag_id), FOREIGN KEY (note_id) REFERENCES notes(id) ON DELETE CASCADE, FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE );
  CREATE TABLE IF NOT EXISTS frame_tags ( frame_id INTEGER, tag_id INTEGER, PRIMARY KEY (frame_id, tag_id), FOREIGN KEY (frame_id) REFERENCES frames(id) ON DELETE CASCADE, FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE );
`);

// --- API Helper Function for Tags ---
const getTagsFor = (table, id) => {
    const stmt = db.prepare(`SELECT t.name, t.color_hex FROM tags t JOIN ${table}_tags nt ON t.id = nt.tag_id WHERE nt.${table}_id = ?`);
    return stmt.all(id) || [];
};

// --- API ROUTES (No changes to logic) ---
app.get("/api/all", (req, res) => {
    try {
        const notes = db
            .prepare("SELECT * FROM notes")
            .all()
            .map((n) => ({ ...n, tags: getTagsFor("note", n.id) }));
        const frames = db
            .prepare("SELECT * FROM frames")
            .all()
            .map((f) => ({ ...f, tags: getTagsFor("frame", f.id) }));
        const tags = db.prepare("SELECT * FROM tags ORDER BY name").all();
        res.status(200).json({ notes, frames, tags });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.get("/api/search", (req, res) => {
    try {
        const query = req.query.q;
        if (!query) return res.status(200).json({ noteIds: [], frameIds: [] });
        const searchQuery = `%${query}%`;
        const noteIds = db
            .prepare(`SELECT id FROM notes WHERE content LIKE ?`)
            .all(searchQuery)
            .map((row) => row.id);
        const frameIds = db
            .prepare(`SELECT id FROM frames WHERE title LIKE ?`)
            .all(searchQuery)
            .map((row) => row.id);
        res.status(200).json({ noteIds, frameIds });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.post("/api/notes", (req, res) => {
    try {
        const { content, pos_x, pos_y, width, height, color_hex } = req.body;
        const stmt = db.prepare("INSERT INTO notes (content, pos_x, pos_y, width, height, color_hex) VALUES (?, ?, ?, ?, ?, ?)");
        const info = stmt.run(content, pos_x, pos_y, width, height, color_hex);
        res.status(201).json({ id: info.lastInsertRowid, ...req.body, tags: [] });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
app.put("/api/notes/:id", (req, res) => {
    try {
        const { content, pos_x, pos_y, width, height, color_hex, frame_id } = req.body;
        const stmt = db.prepare("UPDATE notes SET content = ?, pos_x = ?, pos_y = ?, width = ?, height = ?, color_hex = ?, frame_id = ? WHERE id = ?");
        stmt.run(content, pos_x, pos_y, width, height, color_hex, frame_id ?? null, req.params.id);
        res.status(200).json({ message: "Note updated" });
    } catch (error) {
        console.error("Error updating note:", error);
        res.status(500).json({ error: error.message });
    }
});
app.delete("/api/notes/:id", (req, res) => {
    try {
        db.prepare("DELETE FROM notes WHERE id = ?").run(req.params.id);
        res.status(200).json({ message: "Note deleted" });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
app.post("/api/frames", (req, res) => {
    try {
        const { title, pos_x, pos_y, width, height } = req.body;
        const stmt = db.prepare("INSERT INTO frames (title, pos_x, pos_y, width, height, is_collapsed) VALUES (?, ?, ?, ?, ?, 0)");
        const info = stmt.run(title, pos_x, pos_y, width, height);
        res.status(201).json({ id: info.lastInsertRowid, ...req.body, is_collapsed: 0, tags: [] });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
app.put("/api/frames/:id", (req, res) => {
    try {
        const { title, pos_x, pos_y, width, height, is_collapsed } = req.body;
        const stmt = db.prepare("UPDATE frames SET title = ?, pos_x = ?, pos_y = ?, width = ?, height = ?, is_collapsed = ? WHERE id = ?");
        stmt.run(title, pos_x, pos_y, width, height, is_collapsed ? 1 : 0, req.params.id);
        res.status(200).json({ message: "Frame updated" });
    } catch (error) {
        console.error("Error updating frame:", error);
        res.status(500).json({ error: error.message });
    }
});
app.delete("/api/frames/:id", (req, res) => {
    try {
        db.prepare("DELETE FROM frames WHERE id = ?").run(req.params.id);
        res.status(200).json({ message: "Frame and its notes deleted" });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

const addTagTo = db.transaction((table, itemId, tagName) => {
    let tag = db.prepare("SELECT id FROM tags WHERE name = ?").get(tagName);
    if (!tag) {
        const info = db.prepare("INSERT INTO tags (name) VALUES (?)").run(tagName);
        tag = { id: info.lastInsertRowid };
    }
    db.prepare(`INSERT OR IGNORE INTO ${table}_tags (${table}_id, tag_id) VALUES (?, ?)`).run(itemId, tag.id);
});
app.put("/api/tags/:name", (req, res) => {
    try {
        const { name } = req.params;
        const { color_hex } = req.body;
        if (!color_hex) return res.status(400).json({ error: "color_hex is required." });
        const info = db.prepare("UPDATE tags SET color_hex = ? WHERE name = ?").run(color_hex, name);
        if (info.changes === 0) return res.status(404).json({ message: "Tag not found" });
        res.status(200).json({ message: `Tag '${name}' color updated` });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
app.delete("/api/tags/:name", (req, res) => {
    try {
        const { name } = req.params;
        const info = db.prepare("DELETE FROM tags WHERE name = ?").run(name);
        if (info.changes === 0) return res.status(404).json({ message: "Tag not found" });
        res.status(200).json({ message: `Tag '${name}' was deleted globally.` });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
app.post("/api/:itemType(notes|frames)/:itemId/tags", (req, res) => {
    try {
        const { itemType, itemId } = req.params;
        const { name } = req.body;
        if (!name) return res.status(400).json({ error: "Tag name is required." });
        addTagTo(itemType.slice(0, -1), itemId, name.toLowerCase());
        res.status(201).json({ message: "Tag added" });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});
app.delete("/api/:itemType(notes|frames)/:itemId/tags/:tagName", (req, res) => {
    try {
        const { itemType, itemId, tagName } = req.params;
        const tag = db.prepare("SELECT id FROM tags WHERE name = ?").get(tagName);
        if (tag) {
            db.prepare(`DELETE FROM ${itemType.slice(0, -1)}_tags WHERE ${itemType.slice(0, -1)}_id = ? AND tag_id = ?`).run(itemId, tag.id);
        }
        res.status(200).json({ message: `Tag '${tagName}' removed` });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.listen(PORT, () => console.log(`Backend server MVP+ running on http://localhost:${PORT}`));
```

```js
// electron\ipc-handlers.js
// electron/ipc-handlers.js
const { ipcMain, dialog } = require('electron');
const { IPC_CHANNELS } = require('../shared/constants');
const fileService = require('../backend/services/file-service');
const dbService = require('../backend/services/db-service');
const p2pService = require('../backend/services/p2p-service');

function setupIpcHandlers(mainWindow) {
  const notify = (message) => mainWindow.webContents.send(IPC_CHANNELS.NOTIFY_USER, message);
  const progress = (percent) => mainWindow.webContents.send(IPC_CHANNELS.NOTIFY_PROGRESS, percent);

  // File System
  ipcMain.handle(IPC_CHANNELS.FILE_SELECT, async () => {
    const { canceled, filePaths } = await dialog.showOpenDialog();
    return canceled ? null : filePaths[0];
  });
  ipcMain.handle(IPC_CHANNELS.FILE_ENCRYPT, (evt, fp, key, intensity) => fileService.encryptFile(fp, key, intensity, progress, notify));
  ipcMain.handle(IPC_CHANNELS.FILE_DECRYPT, (evt, fp, key) => fileService.decryptFile(fp, key, progress, notify));

  // Keys
  ipcMain.handle(IPC_CHANNELS.DB_GET_KEYS, () => dbService.getKeys());
  ipcMain.handle(IPC_CHANNELS.DB_SAVE_KEY, (evt, key) => dbService.saveKey(key));
  ipcMain.handle(IPC_CHANNELS.DB_DELETE_KEY, (evt, id) => dbService.deleteKey(id));
  
  // Peers & P2P
  ipcMain.handle(IPC_CHANNELS.DB_GET_PEERS, () => dbService.getPeers());
  ipcMain.handle(IPC_CHANNELS.P2P_CREATE_SEED, (evt, name) => p2pService.createGenesisSeed(name));
  ipcMain.handle(IPC_CHANNELS.DB_ADD_PEER, (evt, name, path) => dbService.addPeer(name, path));
  ipcMain.handle(IPC_CHANNELS.P2P_SEND_FILE, (evt, peerId, fp) => p2pService.sendFile(peerId, fp, progress, notify));
}

module.exports = { setupIpcHandlers };
```

```js
// electron\main.js
// electron/main.js
const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const path = require('path');
const { spawn } = require('child_process');
const crypto = require('crypto');
// Remove the dbService import from here to prevent "app.getPath is not a function" errors
// We let the backend handle the DB entirely.

const SECRET_TOKEN = crypto.randomBytes(32).toString('hex');
let backendProcess = null;

function createWindow() {
  const mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  if (app.isPackaged) {
    mainWindow.loadFile(path.join(__dirname, '../frontend/dist/index.html'));
  } else {
    mainWindow.loadURL('http://localhost:5173');
    mainWindow.webContents.openDevTools();
  }
  return mainWindow;
}

function startBackend() {
  const backendPath = path.join(__dirname, '../backend/server.js');
  const userDataPath = app.getPath('userData');

  // FIXED: Use process.execPath (Electron) instead of 'node'
  // FIXED: Add ELECTRON_RUN_AS_NODE environment variable
  backendProcess = spawn(process.execPath, [backendPath, SECRET_TOKEN, userDataPath], {
    cwd: path.join(__dirname, '../backend'), 
    env: { 
      ...process.env, 
      ELECTRON_RUN_AS_NODE: '1' 
    },
    stdio: 'inherit'
  });

  backendProcess.on('error', (err) => {
    console.error('Failed to start backend process:', err);
  });
}
app.whenReady().then(async () => {
  startBackend();
  const mainWindow = createWindow();

  ipcMain.handle('get-secret-token', (event) => {
    if (event.sender === mainWindow.webContents) return SECRET_TOKEN;
    return null;
  });
  
  ipcMain.handle('dialog:open-file', async () => {
    const { canceled, filePaths } = await dialog.showOpenDialog();
    return canceled ? null : filePaths[0];
  });

  ipcMain.handle('dialog:save-file', async (event, options) => {
    const { canceled, filePath } = await dialog.showSaveDialog(options);
    return canceled ? null : filePath;
  });

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

app.on('quit', () => {
  if (backendProcess) backendProcess.kill();
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});
```

```js
// electron\preload.js
const { contextBridge, ipcRenderer } = require('electron');

// We define constants here to avoid "module not found" errors with relative paths during dev
const IPC_CHANNELS = {
  // File operations
  FILE_SELECT: 'file:select',
  FILE_ENCRYPT: 'file:encrypt',
  FILE_DECRYPT: 'file:decrypt',
  // Database
  DB_GET_KEYS: 'db:get-keys',
  DB_SAVE_KEY: 'db:save-key',
  DB_DELETE_KEY: 'db:delete-key',
  DB_GET_PEERS: 'db:get-peers',
  DB_ADD_PEER: 'db:add-peer',
  // P2P
  P2P_CREATE_SEED: 'p2p:create-seed',
  P2P_SEND_FILE: 'p2p:send-file',
  // Notifications
  NOTIFY_USER: 'notify:user',
  NOTIFY_PROGRESS: 'notify:progress',
};

contextBridge.exposeInMainWorld('nativeAPI', {
  // Security
  getSecretToken: () => ipcRenderer.invoke('get-secret-token'),
  
  // Dialogs
  selectFile: () => ipcRenderer.invoke('dialog:open-file'),
  showSaveDialog: (options) => ipcRenderer.invoke('dialog:save-file', options),

  // Events
  onProgress: (callback) => ipcRenderer.on(IPC_CHANNELS.NOTIFY_PROGRESS, (_event, value) => callback(value)),
  onNotification: (callback) => ipcRenderer.on(IPC_CHANNELS.NOTIFY_USER, (_event, value) => callback(value)),
  removeAllListeners: (channel) => ipcRenderer.removeAllListeners(channel),
});
```

```text
// frontend\.gitignore
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
```

```js
// frontend\eslint.config.js
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]
```

```html
// frontend\index.html
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  
  <meta http-equiv="Content-Security-Policy" 
  content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self' ws://localhost:5173 http://localhost:4000">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Vite + React + Electron Template</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.jsx"></script>
</body>

</html>
```

```json
// frontend\package.json
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/postcss": "^4.1.10",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-draggable": "^4.4.6",
    "react-resizable": "^3.0.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.17.0",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "postcss": "^8.5.5",
    "tailwindcss": "^4.1.10",
    "vite": "^6.0.5"
  }
}
```

```js
// frontend\postcss.config.js
export default {
  plugins: {
    "@tailwindcss/postcss": {},
  }
}
```

```md
// frontend\README.md
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh
```

```js
// frontend\tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

```js
// frontend\vite.config.js
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  base: "./", // Ensures correct file paths in production
  plugins: [react()],
  build: {
    outDir: "dist",
    emptyOutDir: true,
  },
});
```

```js
// frontend\src\api.js
// frontend/src/api.js
const API_URL = 'http://localhost:4000/api';
let SECRET_TOKEN = null;

/*export async function initializeApi() {
  // Check if nativeAPI exists (it might not if preload failed)
  if (!window.nativeAPI) {
    console.error("CRITICAL: window.nativeAPI is undefined. Preload script failed.");
    return;
  }
  
  if (!SECRET_TOKEN) {
    try {
      SECRET_TOKEN = await window.nativeAPI.getSecretToken();
      console.log("API Initialized with Token");
    } catch (e) {
      console.error("Failed to get secret token:", e);
    }
  }
}*/

export async function initializeApi() {
  // Ensure we look for nativeAPI, not electronAPI
  if (window.nativeAPI) {
    SECRET_TOKEN = await window.nativeAPI.getSecretToken();
  } else {
    console.error("nativeAPI not found. Preload failed?");
  }
}

async function apiFetch(endpoint, options = {}) {
  if (!SECRET_TOKEN) {
    // Attempt to init if missing (e.g., hot reload)
    await initializeApi(); 
    if(!SECRET_TOKEN) throw new Error('API is not initialized. Token missing.');
  }

  const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${SECRET_TOKEN}`,
    ...options.headers,
  };

  const response = await fetch(`${API_URL}${endpoint}`, { ...options, headers });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
  }
  return response.json();
}

// Exports
export const getKeys = () => apiFetch('/keys');
export const saveKey = (keyData) => apiFetch('/keys', { method: 'POST', body: JSON.stringify(keyData) });
export const deleteKey = (keyId) => apiFetch(`/keys/${keyId}`, { method: 'DELETE' });
export const getPeers = () => apiFetch('/peers');
export const addPeer = (peerName, seedFilePath) => apiFetch('/peers', { method: 'POST', body: JSON.stringify({ peerName, seedFilePath }) });

export async function encryptFile(filePath, keyConfig, intensity) {
  const savePath = await window.nativeAPI.showSaveDialog({ defaultPath: `${filePath}.nasm` });
  if (!savePath) return { success: false, error: 'User cancelled save.' };
  return apiFetch('/encrypt', { method: 'POST', body: JSON.stringify({ filePath, keyConfig, intensity, savePath }) });
}

export async function decryptFile(filePath, keyConfig) {
  const originalName = filePath.endsWith('.nasm') ? filePath.slice(0, -5) : `${filePath}.decrypted`;
  const savePath = await window.nativeAPI.showSaveDialog({ defaultPath: originalName });
  if (!savePath) return { success: false, error: 'User cancelled save.' };
  return apiFetch('/decrypt', { method: 'POST', body: JSON.stringify({ filePath, keyConfig, savePath }) });
}

export const selectFile = () => window.nativeAPI.selectFile();
```

```jsx
// frontend\src\App.jsx
import React, { useState, useEffect } from 'react';
import { initializeApi } from './api';
import Canvas from './components/Canvas';
import WindowFrame from './components/WindowFrame';
import CryptoApp from './apps/CryptoApp';
import TasksApp from './apps/TasksApp';
import ShortcutWidget from './components/ShortcutWidget';
import SettingsApp from './apps/SettingsApp';


function App() {
  const [openApps, setOpenApps] = useState([]);
  const [isReady, setIsReady] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  
  // Filters
  const [activeFilters, setActiveFilters] = useState([]); 
  const [availableTags, setAvailableTags] = useState([]); // For Dropdown

  // Update this function to fetch tags
  const fetchTags = async () => {
     try {
         const token = await window.nativeAPI.getSecretToken();
         const res = await fetch('http://localhost:4000/api/all', { headers: { 'Authorization': `Bearer ${token}` } });
         const data = await res.json();
         const tags = new Set();
         data.notes.forEach(n => n.tags.forEach(t => tags.add(t.name)));
         setAvailableTags(Array.from(tags));
     } catch(e) { console.error("Tag fetch error", e); }
  };

  useEffect(() => {
    initializeApi().then(() => {
       setIsReady(true);
       fetchTags(); // Initial fetch
    });

    // FIX TAG SYNC: Listen for updates from Canvas
    window.addEventListener('cognicanvas:data-updated', fetchTags);
    return () => window.removeEventListener('cognicanvas:data-updated', fetchTags);
  }, []);

  const toggleApp = (appName) => {
    setOpenApps(prev => prev.includes(appName) ? prev.filter(a => a !== appName) : [...prev, appName]);
  };

  const toggleFilter = (tagName) => {
    console.log("Toggling filter:", tagName);
    setActiveFilters(prev => prev.includes(tagName) ? prev.filter(t => t !== tagName) : [...prev, tagName]);
  };

  const triggerAddFrame = () => {
    console.log("App: Triggering Add Frame...");
    window.dispatchEvent(new CustomEvent('cognicanvas:add-frame'));
  };
   const [shortcuts, setShortcuts] = useState([]); // NEW STATE
  const [theme, setTheme] = useState({ canvas_bg: '#242424' }); // NEW STATE

  const refreshConfig = async () => {
      const token = await window.nativeAPI.getSecretToken();
      
      // Load Shortcuts
      const sRes = await fetch('http://localhost:4000/api/shortcuts', { headers: { 'Authorization': `Bearer ${token}` } });
      setShortcuts(await sRes.json());

      // Load Settings
      const tRes = await fetch('http://localhost:4000/api/settings', { headers: { 'Authorization': `Bearer ${token}` } });
      const tData = await tRes.json();
      if (tData.canvas_bg) setTheme({ canvas_bg: tData.canvas_bg });
  };

  useEffect(() => {
    initializeApi().then(() => {
       setIsReady(true);
       refreshConfig(); // Load initial
    });

    // Listen for changes from Settings App
    window.addEventListener('cognicanvas:config-updated', refreshConfig);
    return () => window.removeEventListener('cognicanvas:config-updated', refreshConfig);
  }, []);
  if (!isReady) return <div className="bg-[#1a1a1a] h-screen text-yellow-500 flex items-center justify-center font-mono">SYSTEM_BOOT...</div>;

  return (
    <div className="flex h-screen w-screen overflow-hidden bg-[#111] text-gray-100 font-sans select-none">
      
      {/* SIDEBAR DOCK */}
      <nav className="w-16 bg-black flex flex-col items-center py-4 space-y-4 z-[100] border-r border-white/10">
        <div className="w-10 h-10 bg-yellow-400 rounded-lg flex items-center justify-center font-black text-black text-xl mb-4">C</div>
        <DockIcon label="Cryptor" active={openApps.includes('crypto')} onClick={() => toggleApp('crypto')}>ðŸ”’</DockIcon>
        <DockIcon label="Tasks" active={openApps.includes('tasks')} onClick={() => toggleApp('tasks')}>âœ…</DockIcon>
        <div className="flex-1" />
        <DockIcon label="Settings" active={openApps.includes('settings')} onClick={() => toggleApp('settings')}>âš™ï¸</DockIcon>
      </nav>

      <div className="flex-1 flex flex-col relative">
        
        {/* ENHANCED HEADER */}
        <header className="h-14 bg-[#f8f9fa] border-b border-gray-300 flex items-center px-4 space-x-4 z-40 shadow-sm text-gray-800">
          
          {/* Add Frame Button */}
          <button 
            onClick={triggerAddFrame}
            className="bg-[#4285f4] text-white px-4 py-1.5 rounded-md text-sm font-bold hover:shadow-md active:scale-95 transition-all whitespace-nowrap"
          >
            + Frame
          </button>
          
          {/* Search Bar */}
          <div className="w-64 relative">
            <input 
              type="text" 
              placeholder="Search content..." 
              className="w-full bg-[#e9ecef] border-none rounded-lg px-4 py-2 text-sm outline-none focus:ring-2 focus:ring-blue-400 text-gray-700"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
          </div>

          <div className="h-8 w-px bg-gray-300 mx-2"></div>

          {/* Tag Dropdown & List */}
          <div className="flex-1 flex items-center space-x-2 overflow-hidden">
            <span className="text-xs font-bold text-gray-400 uppercase tracking-wide">Tags:</span>
            
            {/* Dropdown */}
            <select 
                className="bg-white border border-gray-300 text-gray-700 text-xs rounded p-1 outline-none focus:border-blue-500"
                onChange={(e) => { if(e.target.value) { toggleFilter(e.target.value); e.target.value = ""; } }}
            >
                <option value="">+ Add Filter</option>
                {availableTags.map(tag => (
                    <option key={tag} value={tag}>{tag}</option>
                ))}
            </select>

            {/* Selected Tags List */}
            <div className="flex items-center space-x-2 overflow-x-auto no-scrollbar">
                {activeFilters.length === 0 && <span className="text-xs text-gray-400 italic">No filters active</span>}
                
                {activeFilters.map(tag => (
                <div 
                    key={tag}
                    className="px-2 py-1 bg-blue-100 text-blue-800 border border-blue-200 rounded-md text-xs font-bold flex items-center whitespace-nowrap"
                >
                    {tag} <button className="ml-1 text-blue-400 hover:text-blue-900" onClick={() => toggleFilter(tag)}>Ã—</button>
                </div>
                ))}
            </div>

            {/* Clear All */}
            {activeFilters.length > 0 && (
                <button onClick={() => setActiveFilters([])} className="text-xs text-red-500 hover:text-red-700 underline font-bold whitespace-nowrap">
                    Clear
                </button>
            )}
          </div>
        </header>

       <div className="flex-1 relative z-10">
          {/* PASS THEME COLOR TO CANVAS */}
          <Canvas 
            searchQuery={searchQuery} 
            activeFilters={activeFilters} 
            showTasks={openApps.includes('tasks')}
            bgColor={theme.canvas_bg} 
          />
          
          {/* DYNAMIC SHORTCUTS LAYER */}
          <div className="absolute top-4 left-4 z-20 flex flex-col space-y-2 pointer-events-none">
            {shortcuts.map(s => (
                <ShortcutWidget key={s.id} shortcut={s} />
            ))}
          </div>

          {/* WINDOWS */}
          <div className="absolute inset-0 z-50 pointer-events-none">
            {/* ... other apps ... */}
            
            {openApps.includes('settings') && (
              <div className="pointer-events-auto">
                <WindowFrame title="System Settings" onClose={() => toggleApp('settings')} width={600} initialPos={{x: 200, y: 100}}>
                  <SettingsApp />
                </WindowFrame>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

const DockIcon = ({ children, label, onClick, active }) => (
  <button 
    onClick={onClick}
    className={`w-10 h-10 rounded-xl flex items-center justify-center text-xl transition-all group relative
      ${active ? 'bg-blue-600 text-white shadow-lg' : 'bg-white/5 text-gray-500 hover:bg-white/10 hover:text-white'}
    `}
  >
    {children}
    <span className="absolute left-14 bg-black text-white text-[10px] font-bold px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none z-[110]">
      {label.toUpperCase()}
    </span>
  </button>
);

export default App;
```

```css
// frontend\src\index.css
@import "tailwindcss";

/* 
  STEP 2 (Optional but Recommended): This restores the dark background and light text
  from the original template, but in a non-conflicting way.
*/
body {
    background-color: #242424;
    color: rgba(255, 255, 255, 0.87);
}

/* 
  STEP 3: This is our custom CSS to create the placeholder effect for the
  editable divs on our notes.
*/
[contentEditable="true"]:empty::before {
    content: attr(data-placeholder);
    pointer-events: none; /* Lets you click "through" the placeholder */
    color: #6b7280; /* A slightly darker gray for better contrast on yellow */
}

/* --- Add this for the resize handle --- */
.react-resizable-handle {
    display: block;
    position: absolute;
    width: 20px;
    height: 20px;
    background-repeat: no-repeat;
    background-origin: content-box;
    background-position: bottom right;
    padding: 0 4px 4px 0;
    box-sizing: border-box;
    background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2IDYiIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmYwMCIgeD0iMHB4IiB5PSIwcHgiIGZpbGw9ImJsYWNrIj48ZyBvcGFjaXR5PSIwLjMwMiI+PHBhdGggZD0iTTQgNiA2IDYgNiA0IEwgNCA2IFoiIGZpbGw9ImJsYWNrIi8+PC9nPjwvc3ZnPg==");
    cursor: se-resize;
}
.react-resizable-handle:hover {
    background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMDAwL3N2ZyIgdmlld0JveD0iMCAwIDYgNiIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6I2ZmZmZmZjAwIiB4PSIwcHgiIHk9IjBweCIgZmlsbD0iYmxhY2siPjxnIG9wYWNpdHk9IjAuNSI+PHBhdGggZD0iTTQgNiA2IDYgNiA0IEwgNCA2IFoiIGZpbGw9ImJsYWNrIi8+PC9nPjwvc3ZnPg==");
}
.react-resizable-handle-sw {
    bottom: 0;
    left: 0;
    cursor: sw-resize;
    transform: rotate(90deg);
}
.react-resizable-handle-se {
    bottom: 0;
    right: 0;
    cursor: se-resize;
}
.react-resizable-handle-nw {
    top: 0;
    left: 0;
    cursor: nw-resize;
    transform: rotate(180deg);
}
.react-resizable-handle-ne {
    top: 0;
    right: 0;
    cursor: ne-resize;
    transform: rotate(270deg);
}
.react-resizable-handle-w,
.react-resizable-handle-e {
    top: 50%;
    margin-top: -10px;
    cursor: ew-resize;
}
.react-resizable-handle-w {
    left: 0;
    transform: rotate(135deg);
}
.react-resizable-handle-e {
    right: 0;
    transform: rotate(-45deg);
}
.react-resizable-handle-n,
.react-resizable-handle-s {
    left: 50%;
    margin-left: -10px;
    cursor: ns-resize;
}
.react-resizable-handle-n {
    top: 0;
    transform: rotate(225deg);
}
```

```jsx
// frontend\src\main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

// THIS IS THE FIX: Import the main CSS file which contains the
// @tailwind directives. This loads all of Tailwind's utility classes.
import './index.css'; 

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

```jsx
// frontend\src\apps\CryptoApp.jsx
import React, { useState, useEffect } from 'react';

const TabButton = ({ active, label, onClick }) => (
  <button 
    onClick={onClick}
    className={`flex-1 py-2 text-sm font-bold border-b-2 transition-colors
      ${active ? 'border-blue-500 text-blue-400' : 'border-transparent text-gray-500 hover:text-gray-300'}`}
  >
    {label}
  </button>
);

const CryptoApp = () => {
  const [tab, setTab] = useState('process'); // 'process' or 'vault'
  const [keys, setKeys] = useState([]);
  
  // Process State
  const [mode, setMode] = useState('encrypt'); // 'encrypt' or 'decrypt'
  const [selectedKeyId, setSelectedKeyId] = useState('');
  const [filePath, setFilePath] = useState('');
  const [intensity, setIntensity] = useState(10);
  const [status, setStatus] = useState({ msg: '', type: '' });

  // Init
  useEffect(() => {
    fetchKeys();
  }, []);

  const fetchKeys = async () => {
    try {
        const token = await window.nativeAPI.getSecretToken();
        const res = await fetch('http://localhost:4000/api/keys', { headers: { 'Authorization': `Bearer ${token}` } });
        setKeys(await res.json());
    } catch (e) { console.error(e); }
  };

  const handleSelectFile = async () => {
    const path = await window.nativeAPI.selectFile();
    if (path) setFilePath(path);
  };

  const execute = async () => {
    if (!filePath || !selectedKeyId) {
        setStatus({ msg: 'Missing File or Key', type: 'error' });
        return;
    }
    
    setStatus({ msg: 'Processing...', type: 'info' });
    const token = await window.nativeAPI.getSecretToken();
    const keyConfig = keys.find(k => k._id === selectedKeyId);
    
    // 1. Get Save Path
    const defaultName = mode === 'encrypt' ? `${filePath}.nasm` : filePath.replace('.nasm', '.dec');
    const savePath = await window.nativeAPI.showSaveDialog({ defaultPath: defaultName });
    if (!savePath) {
        setStatus({ msg: 'Cancelled', type: 'info' });
        return;
    }

    // 2. Execute
    try {
        const endpoint = mode === 'encrypt' ? '/api/encrypt' : '/api/decrypt';
        const res = await fetch(`http://localhost:4000${endpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
            body: JSON.stringify({ filePath, keyConfig, intensity, savePath })
        });
        const data = await res.json();
        
        if (data.success) setStatus({ msg: `Done! Saved to ${savePath.split(/[/\\]/).pop()}`, type: 'success' });
        else setStatus({ msg: data.error || 'Failed', type: 'error' });
    } catch (e) {
        setStatus({ msg: e.message, type: 'error' });
    }
  };

  // --- SUB-COMPONENT: VAULT ---
  const KeyVault = () => {
      const [newKeyName, setNewKeyName] = useState("");

      const createKey = async () => {
          // Simplified Key Gen for UX
          const newKey = {
              name: newKeyName || "New Key",
              d: 2, minBound: 32, maxBound: 126,
              starts: [10, 20], I: [['a', '+1']], TC: [1, 2] // Default basic NASM config
          };
          const token = await window.nativeAPI.getSecretToken();
          await fetch('http://localhost:4000/api/keys', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
              body: JSON.stringify(newKey)
          });
          setNewKeyName("");
          fetchKeys();
      };

      const deleteKey = async (id) => {
          const token = await window.nativeAPI.getSecretToken();
          await fetch(`http://localhost:4000/api/keys/${id}`, { method: 'DELETE', headers: { 'Authorization': `Bearer ${token}` } });
          fetchKeys();
      };

      return (
          <div className="space-y-4">
              <div className="flex gap-2">
                  <input 
                    className="flex-1 bg-gray-700 border border-gray-600 rounded px-2 py-1 text-white text-sm"
                    placeholder="Key Name..." 
                    value={newKeyName} 
                    onChange={e => setNewKeyName(e.target.value)}
                  />
                  <button onClick={createKey} className="bg-blue-600 text-white px-3 py-1 rounded text-sm font-bold">Generate</button>
              </div>
              <div className="space-y-2 h-48 overflow-y-auto pr-1">
                  {keys.map(k => (
                      <div key={k._id} className="flex justify-between items-center bg-gray-800 p-2 rounded border border-gray-700">
                          <div>
                              <div className="text-white font-bold text-sm">{k.name}</div>
                              <div className="text-xs text-gray-500 font-mono">NASM-d{k.d}</div>
                          </div>
                          <button onClick={() => deleteKey(k._id)} className="text-red-400 hover:text-red-300 text-xs font-bold">DEL</button>
                      </div>
                  ))}
              </div>
          </div>
      );
  };

  return (
    <div className="bg-gray-900 text-gray-200 h-full flex flex-col">
        {/* Tabs */}
        <div className="flex border-b border-gray-700">
            <TabButton active={tab === 'process'} label="PROCESSOR" onClick={() => setTab('process')} />
            <TabButton active={tab === 'vault'} label="KEY VAULT" onClick={() => setTab('vault')} />
        </div>

        {/* Content */}
        <div className="p-4 flex-1 overflow-y-auto">
            {tab === 'vault' ? <KeyVault /> : (
                <div className="space-y-5">
                    {/* 1. Mode Select */}
                    <div className="flex bg-gray-800 rounded p-1">
                        <button 
                            onClick={() => setMode('encrypt')} 
                            className={`flex-1 py-1 rounded text-xs font-bold transition-colors ${mode === 'encrypt' ? 'bg-red-600 text-white' : 'text-gray-400 hover:text-white'}`}
                        >
                            ENCRYPT
                        </button>
                        <button 
                            onClick={() => setMode('decrypt')} 
                            className={`flex-1 py-1 rounded text-xs font-bold transition-colors ${mode === 'decrypt' ? 'bg-green-600 text-white' : 'text-gray-400 hover:text-white'}`}
                        >
                            DECRYPT
                        </button>
                    </div>

                    {/* 2. File Input */}
                    <div 
                        onClick={handleSelectFile}
                        className="border-2 border-dashed border-gray-600 rounded-lg p-6 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-800 transition-colors"
                    >
                        <div className="text-2xl mb-1">ðŸ“„</div>
                        <div className="text-sm font-bold text-gray-300 truncate">
                            {filePath ? filePath.split(/[/\\]/).pop() : "Click to select file"}
                        </div>
                        <div className="text-xs text-gray-500">{filePath || "No file selected"}</div>
                    </div>

                    {/* 3. Key Select */}
                    <div>
                        <label className="text-xs font-bold text-gray-500 uppercase">Select Key</label>
                        <select 
                            value={selectedKeyId}
                            onChange={(e) => setSelectedKeyId(e.target.value)}
                            className="w-full bg-gray-800 border border-gray-600 text-white text-sm rounded p-2 mt-1 outline-none focus:border-blue-500"
                        >
                            <option value="">-- Choose Key --</option>
                            {keys.map(k => <option key={k._id} value={k._id}>{k.name}</option>)}
                        </select>
                    </div>

                    {/* 4. Intensity (Encrypt Only) */}
                    {mode === 'encrypt' && (
                        <div>
                            <div className="flex justify-between text-xs font-bold text-gray-500 uppercase">
                                <span>Time Intensity</span>
                                <span>{intensity}x</span>
                            </div>
                            <input 
                                type="range" min="1" max="100" 
                                value={intensity} 
                                onChange={(e) => setIntensity(parseInt(e.target.value))}
                                className="w-full mt-1 accent-red-500"
                            />
                        </div>
                    )}

                    {/* 5. Action */}
                    <button 
                        onClick={execute}
                        className={`w-full py-3 rounded font-bold text-white shadow-lg transition-transform active:scale-95
                            ${mode === 'encrypt' ? 'bg-red-600 hover:bg-red-500' : 'bg-green-600 hover:bg-green-500'}`}
                    >
                        {mode === 'encrypt' ? 'LOCK FILE' : 'UNLOCK FILE'}
                    </button>

                    {/* Status */}
                    {status.msg && (
                        <div className={`text-xs text-center p-2 rounded ${status.type === 'error' ? 'bg-red-900/50 text-red-200' : 'bg-green-900/50 text-green-200'}`}>
                            {status.msg}
                        </div>
                    )}
                </div>
            )}
        </div>
    </div>
  );
};

export default CryptoApp;
```

```jsx
// frontend\src\apps\SettingsApp.jsx
import React, { useState, useEffect } from 'react';

const SettingsApp = () => {
  const [activeTab, setActiveTab] = useState('shortcuts');
  const [shortcuts, setShortcuts] = useState([]);
  const [canvasColor, setCanvasColor] = useState('#242424');

  // --- SHORTCUTS LOGIC ---
  const fetchShortcuts = async () => {
      const token = await window.nativeAPI.getSecretToken();
      const res = await fetch('http://localhost:4000/api/shortcuts', { headers: { 'Authorization': `Bearer ${token}` } });
      const data = await res.json();
      setShortcuts(data || []);
      // Trigger App to reload widgets
      window.dispatchEvent(new CustomEvent('cognicanvas:config-updated'));
  };

  const handleAddShortcut = async () => {
      // 1. Ask User for File
      const filePath = await window.nativeAPI.selectFile();
      if (!filePath) return;

      // 2. Guess Name
      const name = filePath.split(/[/\\]/).pop();

      // 3. Save to DB
      const token = await window.nativeAPI.getSecretToken();
      await fetch('http://localhost:4000/api/shortcuts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ title: name, target: filePath, type: 'file' })
      });
      fetchShortcuts();
  };

  const handleDeleteShortcut = async (id) => {
      const token = await window.nativeAPI.getSecretToken();
      await fetch(`http://localhost:4000/api/shortcuts/${id}`, { method: 'DELETE', headers: { 'Authorization': `Bearer ${token}` } });
      fetchShortcuts();
  };

  // --- THEME LOGIC ---
  const saveTheme = async (color) => {
      setCanvasColor(color);
      const token = await window.nativeAPI.getSecretToken();
      await fetch('http://localhost:4000/api/settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ key: 'canvas_bg', value: color })
      });
      window.dispatchEvent(new CustomEvent('cognicanvas:config-updated'));
  };

  useEffect(() => {
      fetchShortcuts();
      // Fetch initial theme (could be refactored into a hook)
  }, []);

  return (
    <div className="flex h-full text-gray-800">
      {/* Sidebar */}
      <div className="w-1/4 bg-gray-100 border-r p-2 space-y-1">
          <button onClick={() => setActiveTab('shortcuts')} className={`w-full text-left px-2 py-1.5 rounded text-sm font-bold ${activeTab==='shortcuts' ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-200'}`}>Shortcuts</button>
          <button onClick={() => setActiveTab('theme')} className={`w-full text-left px-2 py-1.5 rounded text-sm font-bold ${activeTab==='theme' ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-200'}`}>Theme</button>
      </div>

      {/* Content */}
      <div className="flex-1 p-4 overflow-y-auto">
          {activeTab === 'shortcuts' && (
              <div className="space-y-4">
                  <div className="flex justify-between items-center">
                      <h3 className="font-bold">System Shortcuts</h3>
                      <button onClick={handleAddShortcut} className="bg-green-600 text-white px-3 py-1 rounded text-xs font-bold hover:bg-green-500">+ Add File/Exe</button>
                  </div>
                  <div className="space-y-2">
                      {shortcuts.map(s => (
                          <div key={s.id} className="flex justify-between items-center bg-white border p-2 rounded shadow-sm">
                              <div className="truncate flex-1 pr-2">
                                  <div className="font-bold text-sm">{s.title}</div>
                                  <div className="text-xs text-gray-400 truncate" title={s.target}>{s.target}</div>
                              </div>
                              <button onClick={() => handleDeleteShortcut(s.id)} className="text-red-500 hover:bg-red-50 p-1 rounded">ðŸ—‘ï¸</button>
                          </div>
                      ))}
                  </div>
              </div>
          )}

          {activeTab === 'theme' && (
              <div className="space-y-4">
                  <h3 className="font-bold">Appearance</h3>
                  <div>
                      <label className="block text-xs font-bold text-gray-500 mb-1">CANVAS BACKGROUND</label>
                      <div className="flex gap-2">
                          {['#242424', '#1e1e1e', '#0f172a', '#312e81', '#ffffff'].map(c => (
                              <button 
                                key={c}
                                className={`w-8 h-8 rounded-full border-2 ${canvasColor === c ? 'border-blue-500 scale-110' : 'border-transparent'}`}
                                style={{ backgroundColor: c }}
                                onClick={() => saveTheme(c)}
                              />
                          ))}
                      </div>
                  </div>
              </div>
          )}
      </div>
    </div>
  );
};

export default SettingsApp;
```

```jsx
// frontend\src\apps\TasksApp.jsx
import React, { useState, useEffect } from 'react';

const TasksApp = () => {
  const [tasks, setTasks] = useState([]);
  const [newTaskTitle, setNewTaskTitle] = useState("");

  const fetchTasks = async () => {
    try {
      const token = await window.nativeAPI.getSecretToken();
      const res = await fetch('http://localhost:4000/api/all', { headers: { 'Authorization': `Bearer ${token}` } });
      const data = await res.json();
      setTasks(data.tasks || []);
    } catch (e) { console.error(e); }
  };

  useEffect(() => { fetchTasks(); }, []);

  const handleCreate = async (e) => {
    e.preventDefault();
    if (!newTaskTitle.trim()) return;

    const token = await window.nativeAPI.getSecretToken();
    await fetch('http://localhost:4000/api/tasks', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
      body: JSON.stringify({ title: newTaskTitle })
    });
    setNewTaskTitle("");
    fetchTasks();
    // Refresh Canvas widgets too
    window.dispatchEvent(new CustomEvent('cognicanvas:data-updated'));
  };

  return (
    <div className="p-4 space-y-4">
      <form onSubmit={handleCreate} className="flex gap-2">
        <input 
          type="text" 
          className="flex-1 border rounded px-2 py-1 text-sm text-black"
          placeholder="New Task Name..." 
          value={newTaskTitle}
          onChange={(e) => setNewTaskTitle(e.target.value)}
          autoFocus
        />
        <button type="submit" className="bg-blue-600 text-white px-3 py-1 rounded text-sm font-bold">Add</button>
      </form>

      <div className="space-y-2">
        {tasks.length === 0 && <p className="text-gray-500 text-sm italic text-center">No tasks yet.</p>}
        {tasks.map(task => (
          <div key={task.id} className="bg-white border rounded p-2 flex justify-between items-center shadow-sm">
            <div>
              <div className="font-bold text-gray-800 text-sm">{task.title}</div>
              <div className="text-xs text-gray-500">
                Total: {Math.floor(task.total_time_ms / 1000 / 60)}m 
                {task.is_running && <span className="text-green-600 font-bold ml-1">(RUNNING)</span>}
              </div>
            </div>
            <div className="text-xs bg-gray-100 px-2 py-1 rounded text-gray-500">
              Widget Active
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default TasksApp;
```

```jsx
// frontend\src\components\Canvas.jsx
import React, { useState, useEffect, useRef } from 'react';
import Note from './Note';
import Frame from './Frame';
import TaskWidget from './TaskWidget';

const Canvas = ({ searchQuery = "", activeFilters = [], onTagClick, showTasks, bgColor = '#242424' }) => {
  const [data, setData] = useState({ notes: [], frames: [], tasks: [] });
  const viewRef = useRef({ x: 0, y: 0, scale: 1 });
  const [forceRender, setForceRender] = useState(0); 
  const [isPanning, setIsPanning] = useState(false);
  const containerRef = useRef(null);

  const setView = (newView) => {
      viewRef.current = { ...viewRef.current, ...newView };
      setForceRender(prev => prev + 1);
  };

  const fetchData = async () => {
    try {
      const token = await window.nativeAPI.getSecretToken();
      const res = await fetch('http://localhost:4000/api/all', { headers: { 'Authorization': `Bearer ${token}` } });
      const json = await res.json();
      setData(json);
      window.dispatchEvent(new CustomEvent('cognicanvas:data-updated'));
    } catch (e) { console.error(e); }
  };

  useEffect(() => { 
    fetchData(); 
    const container = containerRef.current;
    if (!container) return;

    // --- FIX: ZOOM ANCHOR (Mouse Centered) ---
    const handleWheelNative = (e) => {
      e.preventDefault();
      const current = viewRef.current;
      const rect = container.getBoundingClientRect();
      
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // World coordinates under mouse
      const worldX = (mouseX - current.x) / current.scale;
      const worldY = (mouseY - current.y) / current.scale;

      const delta = -e.deltaY * 0.001;
      const newScale = Math.min(Math.max(current.scale + delta, 0.05), 4);

      // New offsets to keep world point under mouse
      const newX = mouseX - (worldX * newScale);
      const newY = mouseY - (worldY * newScale);

      setView({ x: newX, y: newY, scale: newScale });
    };

    container.addEventListener('wheel', handleWheelNative, { passive: false });
    return () => container.removeEventListener('wheel', handleWheelNative);
  }, []);

  // --- FIX: DOUBLE CLICK (Infinite Click Area) ---
  const handleDoubleClick = async (e) => {
    // Only trigger if we clicked the actual background (container)
    // or the empty transform layer
    if (e.target !== containerRef.current && e.target.id !== 'transform-layer') return;

    const rect = containerRef.current.getBoundingClientRect();
    const x = ((e.clientX - rect.left) - viewRef.current.x) / viewRef.current.scale;
    const y = ((e.clientY - rect.top) - viewRef.current.y) / viewRef.current.scale;

    const token = await window.nativeAPI.getSecretToken();
    await fetch('http://localhost:4000/api/notes', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
      body: JSON.stringify({ content: "New Note", pos_x: x - 100, pos_y: y - 100, width: 200, height: 200, color_hex: "#fff000" })
    });
    fetchData();
  };

  const handleNoteUpdateDrag = async (id, changes) => {
    let updates = { ...changes };
    if (changes.pos_x !== undefined) {
        const note = data.notes.find(n => n.id === id);
        const cx = changes.pos_x + (note.width / 2);
        const cy = changes.pos_y + (note.height / 2);
        const parentFrame = data.frames.find(f => !f.is_collapsed && cx >= f.pos_x && cx <= (f.pos_x + f.width) && cy >= f.pos_y && cy <= (f.pos_y + f.height));
        updates.frame_id = parentFrame ? parentFrame.id : null;
    }
    setData(prev => ({ ...prev, notes: prev.notes.map(n => n.id === id ? { ...n, ...updates } : n) }));
    const token = await window.nativeAPI.getSecretToken();
    await fetch(`http://localhost:4000/api/notes/${id}`, { 
        method: 'PUT', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }, 
        body: JSON.stringify(updates) 
    });
  };

  // --- 1. FRAME MOVING LOGIC (Synchronized) ---
  const handleFrameDrag = (frameId, dx, dy) => {
    setData(prev => ({
      ...prev,
      // Move the Frame
      frames: prev.frames.map(f => f.id === frameId ? { ...f, pos_x: f.pos_x + dx, pos_y: f.pos_y + dy } : f),
      // Move the Children (Notes inside this frame)
      notes: prev.notes.map(n => n.frame_id === frameId ? { ...n, pos_x: n.pos_x + dx, pos_y: n.pos_y + dy } : n)
    }));
  };

  const handleFrameStop = async (id, finalPos) => {
    // 1. Update Frame in DB
    const token = await window.nativeAPI.getSecretToken();
    await fetch(`http://localhost:4000/api/frames/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
        body: JSON.stringify(finalPos)
    });

    // 2. Update Children in DB (Batch update ideally, but separate calls for MVP)
    const children = data.notes.filter(n => n.frame_id === id);
    for (const child of children) {
        await fetch(`http://localhost:4000/api/notes/${child.id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
            body: JSON.stringify({ pos_x: child.pos_x, pos_y: child.pos_y })
        });
    }
  };

  const handleUpdateFrame = async (id, changes) => {
    // For Collapse/Resize updates
    setData(prev => ({ ...prev, frames: prev.frames.map(f => f.id === id ? { ...f, ...changes } : f) }));
    const token = await window.nativeAPI.getSecretToken();
    await fetch(`http://localhost:4000/api/frames/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
        body: JSON.stringify(changes)
    });
  };

  // --- 2. NOTE MOVING & CAPTURE LOGIC ---
  const handleNoteUpdate = async (id, changes) => {
    let updates = { ...changes };

    // If moving, check if we dropped into a frame
    if (changes.pos_x !== undefined && changes.pos_y !== undefined) {
        const note = data.notes.find(n => n.id === id);
        // Calculate Center of Note
        const cx = changes.pos_x + (note.width / 2);
        const cy = changes.pos_y + (note.height / 2);

        // Find a Frame that contains this center point
        const parentFrame = data.frames.find(f => 
            !f.is_collapsed && 
            cx >= f.pos_x && cx <= (f.pos_x + f.width) &&
            cy >= f.pos_y && cy <= (f.pos_y + f.height)
        );

        if (parentFrame) {
            updates.frame_id = parentFrame.id; // Capture!
        } else {
            updates.frame_id = null; // Release!
        }
    }

    // Optimistic Update
    setData(prev => ({ ...prev, notes: prev.notes.map(n => n.id === id ? { ...n, ...updates } : n) }));

    // API Call
    const token = await window.nativeAPI.getSecretToken();
    await fetch(`http://localhost:4000/api/notes/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
      body: JSON.stringify(updates)
    });
  };

  // --- 3. FILTERING & COLLAPSE LOGIC ---
  // We need to know which notes to render.
  
  // A. Filter Matching Logic
  const getFilterMatch = (note) => {
      const normContent = (note.content || "").toLowerCase();
      const normSearch = searchQuery.toLowerCase();
      const matchesSearch = !searchQuery || normContent.includes(normSearch);
      
      const matchesTags = activeFilters.length === 0 || 
        (note.tags && note.tags.some(tag => activeFilters.includes(tag.name)));

      return matchesSearch && matchesTags;
  };

  // B. Rendering List
  const notesToRender = data.notes.map(note => {
      // 1. Check Collapse
      if (note.frame_id) {
          const parent = data.frames.find(f => f.id === note.frame_id);
          // If parent exists and is collapsed, DO NOT RENDER this note
          if (parent && parent.is_collapsed) return null;
      }

      // 2. Check Filter (Dimming)
      const isMatch = getFilterMatch(note);
      // If there's an active search/filter, and this note doesn't match, it is dimmed.
      const isDimmed = (searchQuery || activeFilters.length > 0) && !isMatch;

      return (
          <Note 
            key={note.id} 
            note={note} 
            scale={view.scale}
            isDimmed={isDimmed} // Restore Dimming Prop
            onNoteUpdate={handleNoteUpdate}
            onNoteDelete={async (id) => {
                setData(p => ({...p, notes: p.notes.filter(n => n.id !== id)}));
                await fetch(`http://localhost:4000/api/notes/${id}`, { method: 'DELETE', headers: { 'Authorization': `Bearer ${await window.nativeAPI.getSecretToken()}` }});
            }}
            onTagAdd={(type, id, name) => handleTagAction('add', type, id, name)}
            onTagRemove={(type, id, name) => handleTagAction('remove', type, id, name)}
            onDataChange={fetchData}
            onTagClick={onTagClick} 
          />
      );
  }).filter(Boolean); // Remove nulls (collapsed notes)

  // --- 4. HELPERS (Tag, Wheel, Add Frame) ---
  const handleTagAction = async (action, type, id, tagName) => {
      const token = await window.nativeAPI.getSecretToken();
      const url = action === 'add' ? `http://localhost:4000/api/tags/${type}/${id}` : `http://localhost:4000/api/${type}/${id}/tags/${tagName}`;
      await fetch(url, { method: action === 'add' ? 'POST' : 'DELETE', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }, body: action === 'add' ? JSON.stringify({ name: tagName }) : undefined });
      fetchData();
  };

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;
    const handleWheelNative = (e) => {
      e.preventDefault();
      const delta = -e.deltaY * 0.001;
      setView(prev => ({ ...prev, scale: Math.min(Math.max(prev.scale + delta, 0.1), 3) }));
    };
    container.addEventListener('wheel', handleWheelNative, { passive: false });
    return () => container.removeEventListener('wheel', handleWheelNative);
  }, []);

  useEffect(() => {
    const onAddFrame = async () => {
        const token = await window.nativeAPI.getSecretToken();
        const newFrame = { title: "NEW FRAME", pos_x: (-view.x + 100) / view.scale, pos_y: (-view.y + 100) / view.scale, width: 400, height: 300 };
        await fetch('http://localhost:4000/api/frames', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }, body: JSON.stringify(newFrame) });
        fetchData();
    };
    window.addEventListener('cognicanvas:add-frame', onAddFrame);
    return () => window.removeEventListener('cognicanvas:add-frame', onAddFrame);
  }, [view]);

   return (
    <div 
        ref={containerRef}
        onDoubleClick={handleDoubleClick}
        onMouseDown={(e) => { if(e.button===1 || e.buttons===4 || (e.button===0 && e.altKey)) setIsPanning(true); }}
        onMouseMove={(e) => { if(isPanning) setView({ x: viewRef.current.x + e.movementX, y: viewRef.current.y + e.movementY }); }}
        onMouseUp={() => setIsPanning(false)}
        className="w-full h-full overflow-hidden relative"
        style={{ backgroundColor: bgColor }}
    >
      <div 
        id="transform-layer"
        style={{ 
            transform: `translate(${viewRef.current.x}px, ${viewRef.current.y}px) scale(${viewRef.current.scale})`, 
            transformOrigin: '0 0',
            position: 'absolute',
            width: 0, height: 0, // FIX: Size 0 ensures children overflow but clicks pass through
            pointerEvents: 'none' // FIX: Passes clicks to container background
        }}
      >
          {/* GRID: Massive coverage */}
          <div className="absolute opacity-10 top-[-100000px] left-[-100000px] w-[200000px] h-[200000px] pointer-events-none"
             style={{ backgroundImage: 'radial-gradient(#888 1px, transparent 1px)', backgroundSize: '40px 40px' }} 
          />

          {/* Children: Explicitly enable pointer events */}
          <div className="pointer-events-auto">
            {data.frames.map(frame => (
                <Frame key={frame.id} frame={frame} scale={viewRef.current.scale} onUpdate={fetchData} />
            ))}
            {data.notes.map(note => {
                if (note.frame_id && data.frames.find(f => f.id === note.frame_id)?.is_collapsed) return null;
                return <Note key={note.id} note={note} scale={viewRef.current.scale} onNoteUpdate={handleNoteUpdateDrag} onDataChange={fetchData} />;
            })}
            {showTasks && data.tasks.map(task => (
                <TaskWidget key={task.id} task={task} scale={viewRef.current.scale} onUpdate={fetchData} />
            ))}
          </div>
      </div>
      <div className="absolute bottom-4 right-4 bg-black/50 text-white px-3 py-1 rounded-full text-xs font-mono">{Math.round(viewRef.current.scale * 100)}%</div>
    </div>
  );
};

export default Canvas;
```

```jsx
// frontend\src\components\Frame.jsx
import React, { useRef, useState } from "react";
import Draggable from "react-draggable";
import { ResizableBox } from "react-resizable";
import "react-resizable/css/styles.css";

// DESTUCTURING onDrag HERE is critical to fix your error
const Frame = ({ frame, onUpdate, onDelete, onDrag, onDragStop, scale }) => {
    const nodeRef = useRef(null);
    const [isEditingTitle, setIsEditingTitle] = useState(false);

    // 1. Handle Dragging (Movement)
    const handleDrag = (e, data) => {
        // We pass the ID and the movement deltas to the parent
        if (onDrag) {
            onDrag(frame.id, data.deltaX, data.deltaY);
        }
    };

    // 2. Handle Stop (Save to DB)
    const handleStop = (e, data) => {
        if (onDragStop) {
            onDragStop(frame.id, { pos_x: data.x, pos_y: data.y });
        }
    };

    const handleResizeStop = (e, data) => {
        onUpdate(frame.id, { width: data.size.width, height: data.size.height });
    };

    const toggleCollapse = () => {
        // Toggle the boolean state (0 or 1 for SQLite)
        onUpdate(frame.id, { is_collapsed: frame.is_collapsed ? 0 : 1 });
    };

    const handleTitleBlur = (e) => {
        setIsEditingTitle(false);
        if (e.target.innerText !== frame.title) {
            onUpdate(frame.id, { title: e.target.innerText });
        }
    };

    return (
        <Draggable
            nodeRef={nodeRef}
            handle=".frame-header"
            // Use local state position or props position? 
            // Props position is safer for synchronized movement with children
            position={{ x: frame.pos_x, y: frame.pos_y }}
            scale={scale}
            onDrag={handleDrag} // Fires on every pixel move
            onStop={handleStop} // Fires when you let go
        >
            <div 
                ref={nodeRef} 
                className="absolute z-10 transition-opacity duration-200" 
                style={{ 
                    width: frame.width, 
                    height: frame.is_collapsed ? 'auto' : frame.height 
                }}
            >
                <ResizableBox 
                    width={frame.width} 
                    height={frame.is_collapsed ? 40 : frame.height} 
                    onResizeStop={handleResizeStop}
                    minConstraints={[200, 40]}
                    axis={frame.is_collapsed ? "x" : "both"}
                    handle={!frame.is_collapsed && <span className="react-resizable-handle react-resizable-handle-se" />}
                >
                    <div className="w-full h-full border-2 border-dashed border-gray-300 hover:border-gray-400 rounded-lg flex flex-col bg-gray-50 bg-opacity-50">
                        
                        {/* HEADER */}
                        <div className="frame-header h-10 bg-gray-200 flex items-center px-2 cursor-move group rounded-t-lg select-none">
                            <button onClick={(e) => { e.stopPropagation(); toggleCollapse(); }} className="mr-2 text-gray-500 hover:text-black w-6 h-6 flex items-center justify-center font-bold">
                                {frame.is_collapsed ? 'â–¶' : 'â–¼'}
                            </button>

                            <div 
                                contentEditable
                                suppressContentEditableWarning
                                className="flex-grow font-bold text-gray-700 text-sm uppercase tracking-wide focus:outline-none focus:bg-white px-1 rounded cursor-text"
                                onBlur={handleTitleBlur}
                                onKeyDown={(e) => { if(e.key === 'Enter') e.target.blur(); }}
                                onMouseDown={(e) => e.stopPropagation()} // Allow clicking text without dragging
                            >
                                {frame.title}
                            </div>

                            <button onClick={() => onDelete(frame.id)} className="opacity-0 group-hover:opacity-100 text-gray-400 hover:text-red-500 font-bold ml-2">
                                Ã—
                            </button>
                        </div>
                    </div>
                </ResizableBox>
            </div>
        </Draggable>
    );
};

export default Frame;
```

```jsx
// frontend\src\components\KeyConfigForm.jsx
// frontend/src/components/KeyConfigForm.jsx
import React, { useState } from 'react';

// A simple reusable input component.
const FormInput = ({ label, value, onChange }) => (
  <label className="block">
    <span className="text-gray-700">{label}</span>
    <input type="text" value={value} onChange={onChange} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
  </label>
);

// A component for a list of values that can be added/removed.
const DynamicListInput = ({ label, items, setItems }) => {
  const handleItemChange = (index, value) => {
    const newItems = [...items];
    newItems[index] = value;
    setItems(newItems);
  };
  const addItem = () => setItems([...items, '']);
  const removeItem = (index) => setItems(items.filter((_, i) => i !== index));

  return (
    <div>
      <h3 className="text-lg font-medium">{label}</h3>
      {items.map((item, index) => (
        <div key={index} className="flex items-center space-x-2 mt-2">
          <input type="text" value={item} onChange={(e) => handleItemChange(index, e.target.value)} className="flex-grow rounded-md border-gray-300 shadow-sm" />
          <button onClick={() => removeItem(index)} className="px-2 py-1 bg-red-500 text-white rounded">-</button>
        </div>
      ))}
      <button onClick={addItem} className="mt-2 px-2 py-1 bg-green-500 text-white rounded">+</button>
    </div>
  );
};

function KeyConfigForm({ initialData, onSave, onCancel }) {
  const [key, setKey] = useState(initialData || {});

  const handleChange = (field) => (e) => {
    setKey({ ...key, [field]: e.target.value });
  };
  
  const handleListChange = (field) => (items) => {
    setKey({ ...key, [field]: items });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    // In a real app, perform validation here using a library like Zod.
    onSave(key);
  };

  return (
    <form onSubmit={handleSubmit} className="p-4 bg-white rounded-lg shadow-md space-y-4">
      <h2 className="text-xl font-bold">{key._id ? 'Edit Key' : 'Create New Key'}</h2>
      <FormInput label="Key Name" value={key.name || ''} onChange={handleChange('name')} />
      <FormInput label="Degree (d)" value={key.d || ''} onChange={handleChange('d')} />
      <FormInput label="Min Bound" value={key.minBound || '32'} onChange={handleChange('minBound')} />
      <FormInput label="Max Bound" value={key.maxBound || '126'} onChange={handleChange('maxBound')} />
      <DynamicListInput label="Start Values (starts)" items={key.starts || []} setItems={handleListChange('starts')} />
      <DynamicListInput label="Operations (I)" items={key.I || []} setItems={handleListChange('I')} />
      <DynamicListInput label="Transformation (TC)" items={key.TC || []} setItems={handleListChange('TC')} />
      <div className="flex justify-end space-x-2">
        <button type="button" onClick={onCancel} className="px-4 py-2 bg-gray-300 rounded">Cancel</button>
        <button type="submit" className="px-4 py-2 bg-blue-600 text-white rounded">Save</button>
      </div>
    </form>
  );
}

export default KeyConfigForm;    
```

```jsx
// frontend\src\components\Note.jsx
import React, { useRef, useEffect, useState } from "react";
import Draggable from "react-draggable";
import { ResizableBox } from "react-resizable";
import "react-resizable/css/styles.css";
import TagManager from "./TagManager";

const NOTE_COLORS = [
    { hex: '#fff000', name: 'Yellow' },
    { hex: '#a7ffeb', name: 'Teal' },
    { hex: '#f8bbd0', name: 'Pink' },
    { hex: '#ccff90', name: 'Green' },
    { hex: '#ffe0b2', name: 'Orange' },
    { hex: '#d1c4e9', name: 'Purple' },
    { hex: '#ffffff', name: 'White' },
    { hex: '#242424', name: 'Dark', text: 'white' } // Special case for dark mode note
];

const parseAndRenderLinks = (htmlContent) => {
    const content = String(htmlContent || "");
    const internalLinkRegex = /\[\[(note|frame):(\d+)\]\]/g;
    return content.replace(internalLinkRegex, (match, type, id) => {
        const elementId = `${type}-${id}`;
        return `<a href="#" data-internal-link="${elementId}" class="internal-link bg-blue-100 text-blue-800 px-1 rounded hover:bg-blue-200" contenteditable="false">ðŸ”— ${type} ${id}</a>`;
    });
};

const Note = ({ note, onNoteUpdate, onNoteDelete, onTagAdd, onTagRemove, onDataChange, scale, isDimmed }) => {
    const nodeRef = useRef(null);
    const contentRef = useRef(null);
    const [isDragging, setIsDragging] = useState(false);
    
    // CONTEXT MENU STATE
    const [contextMenu, setContextMenu] = useState(null); // { x, y }

    // --- HANDLERS ---
    const handleDragStart = () => { setIsDragging(true); setContextMenu(null); }; // Close menu on drag
    const handleDragStop = (e, data) => {
        setIsDragging(false);
        if (Math.abs(data.x - note.pos_x) > 1 || Math.abs(data.y - note.pos_y) > 1) {
            onNoteUpdate(note.id, { pos_x: data.x, pos_y: data.y });
        }
    };

    const handleResizeStop = (e, data) => onNoteUpdate(note.id, { width: data.size.width, height: data.size.height });

    const handleFocus = () => { if (contentRef.current) contentRef.current.innerText = contentRef.current.innerHTML; };
    const handleBlur = () => {
        if (contentRef.current) {
            const raw = contentRef.current.innerText;
            contentRef.current.innerHTML = raw;
            if (contentRef.current.innerHTML !== note.content) onNoteUpdate(note.id, { content: contentRef.current.innerHTML });
        }
    };

    // --- RIGHT CLICK HANDLER ---
    const handleContextMenu = (e) => {
        e.preventDefault();
        e.stopPropagation();
        // Show menu at mouse position (relative to screen to avoid clipping)
        setContextMenu({ x: e.clientX, y: e.clientY });
    };

    // Close context menu on any click outside
    useEffect(() => {
        const handleClick = () => setContextMenu(null);
        window.addEventListener('click', handleClick);
        return () => window.removeEventListener('click', handleClick);
    }, []);

    const changeColor = (hex) => {
        onNoteUpdate(note.id, { color_hex: hex });
        setContextMenu(null);
    };

    // Calculate Text Color (Black for light notes, White for dark notes)
    const isDark = note.color_hex === '#242424';
    const textColor = isDark ? 'text-white' : 'text-gray-900';

    const visualClass = isDimmed 
        ? "opacity-30 grayscale pointer-events-none transition-opacity duration-300" 
        : "opacity-100 transition-opacity duration-300";

    return (
        <>
            <Draggable
                nodeRef={nodeRef}
                handle=".drag-handle"
                onStart={handleDragStart}
                onStop={handleDragStop}
                position={{ x: note.pos_x, y: note.pos_y }}
                scale={scale}
                disabled={isDimmed}
            >
                <div 
                    id={`note-${note.id}`} 
                    ref={nodeRef} 
                    className={`absolute z-20 shadow-xl ${visualClass}`} 
                    style={{ width: note.width, height: note.height }}
                    onContextMenu={handleContextMenu} // Attach Event
                >
                    <ResizableBox 
                        height={note.height} 
                        width={note.width} 
                        onResizeStop={handleResizeStop} 
                        minConstraints={[180, 150]}
                        handle={<span className="react-resizable-handle react-resizable-handle-se" />}
                    >
                        <div 
                            className="w-full h-full rounded-lg flex flex-col overflow-hidden ring-1 ring-black ring-opacity-10 transition-colors duration-200" 
                            style={{ backgroundColor: note.color_hex || '#fff000' }}
                        >
                            {/* Drag Handle */}
                            <div className="drag-handle h-7 w-full cursor-move bg-black bg-opacity-5 hover:bg-opacity-10 flex items-center justify-end p-1 transition-colors">
                                <button onClick={(e) => { e.stopPropagation(); onNoteDelete(note.id); }} className="w-5 h-5 flex items-center justify-center text-black opacity-30 hover:opacity-100 hover:text-red-600 font-bold">Ã—</button>
                            </div>

                            {/* Content */}
                            <div 
                                ref={contentRef} 
                                contentEditable 
                                suppressContentEditableWarning 
                                className={`flex-grow w-full text-lg p-4 focus:outline-none font-sans leading-relaxed ${textColor}`}
                                onFocus={handleFocus} 
                                onBlur={handleBlur} 
                                dangerouslySetInnerHTML={{ __html: parseAndRenderLinks(note.content) }} 
                            />

                            {/* Tag Manager */}
                            <TagManager tags={note.tags || []} onAddTag={(t) => onTagAdd("notes", note.id, t)} onRemoveTag={(t) => onTagRemove("notes", note.id, t)} onDataChange={onDataChange} />
                        </div>
                    </ResizableBox>
                </div>
            </Draggable>

            {/* CONTEXT MENU PORTAL (Fixed Position) */}
            {contextMenu && (
                <div 
                    className="fixed z-[9999] bg-white rounded shadow-xl border border-gray-200 p-2 grid grid-cols-4 gap-2 w-32 animate-in fade-in zoom-in-95 duration-100"
                    style={{ top: contextMenu.y, left: contextMenu.x }}
                    onClick={(e) => e.stopPropagation()} // Prevent closing when clicking inside
                >
                    {NOTE_COLORS.map(c => (
                        <button
                            key={c.hex}
                            onClick={() => changeColor(c.hex)}
                            className="w-6 h-6 rounded-full border border-gray-300 hover:scale-110 transition-transform shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400"
                            style={{ backgroundColor: c.hex }}
                            title={c.name}
                        />
                    ))}
                </div>
            )}
        </>
    );
};
export default Note;
```

```jsx
// frontend\src\components\Notification.jsx
// frontend/src/components/Notification.jsx
import React, { useState, useEffect } from 'react';

function Notification({ message, duration = 5000 }) {
  const [visible, setVisible] = useState(false);

  useEffect(() => {
    if (message) {
      setVisible(true);
      const timer = setTimeout(() => {
        setVisible(false);
      }, duration);
      return () => clearTimeout(timer);
    }
  }, [message, duration]);

  if (!visible) return null;

  return (
    <div className="fixed top-5 right-5 bg-blue-500 text-white p-4 rounded-lg shadow-lg animate-fade-in-out">
      <h3 className="font-bold">{message.title}</h3>
      <p>{message.body}</p>
    </div>
  );
}

export default Notification;
```

```jsx
// frontend\src\components\ShortcutWidget.jsx
import React, { useState } from 'react';

const ShortcutWidget = ({ shortcut }) => {
  const [status, setStatus] = useState("Idle");

  const execute = async () => {
    // Check if the API is actually available
    if (!window.nativeAPI) {
      console.error("Native API not initialized");
      setStatus("Init Error");
      return;
    }

    setStatus("Running...");
    try {
      // FIXED: Changed from window.electronAPI to window.nativeAPI
      const token = await window.nativeAPI.getSecretToken();
      
      let url, body;
      if (shortcut.type === 'command') {
          url = 'http://localhost:4000/api/system/run';
          body = { command: shortcut.command, args: shortcut.args };
      } else {
          url = 'http://localhost:4000/api/system/open';
          body = { target: shortcut.target };
      }

      const res = await fetch(url, {
          method: 'POST',
          headers: { 
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(body)
      });
      
      const data = await res.json();
      if (data.success || data.code === 0) {
          setStatus("Done âœ…");
      } else {
          setStatus("Error âŒ");
      }
      
      setTimeout(() => setStatus("Idle"), 2000);
    } catch (e) {
      console.error(e);
      setStatus("Failed âš ï¸");
    }
  };

  return (
    <div 
      className="bg-gray-800 text-white p-3 rounded-lg shadow-lg w-48 flex items-center justify-between cursor-pointer hover:bg-gray-700 transition border border-gray-600 pointer-events-auto" 
      onClick={execute}
    >
      <div className="overflow-hidden">
        <div className="font-bold text-sm truncate">{shortcut.title}</div>
        <div className="text-[10px] uppercase tracking-tighter text-gray-400">{status}</div>
      </div>
      <div className="text-xl ml-2">ðŸš€</div>
    </div>
  );
};

export default ShortcutWidget;
```

```jsx
// frontend\src\components\TagManager.jsx
import React, { useRef } from "react";

// Helper Component for individual Tag Pills
const TagPill = ({ tag, onRemove, onColorChange }) => (
    <div 
        onClick={() => onColorChange(tag)} 
        className="flex items-center text-white text-xs font-semibold px-2 py-1 rounded-full cursor-pointer transition-transform hover:scale-105 select-none" 
        style={{ backgroundColor: tag.color_hex || '#3b82f6' }} 
        title="Double-click to change color"
    >
        <span>{tag.name}</span>
        <button
            onClick={(e) => {
                e.stopPropagation();
                onRemove(tag.name);
            }}
            className="ml-2 text-white opacity-50 hover:opacity-100 font-bold"
        >
            Ã—
        </button>
    </div>
);

const TagManager = ({ tags, onAddTag, onRemoveTag, onDataChange }) => {
    const colorInputRef = useRef(null);
    const tagToChangeRef = useRef(null);

    const handleKeyDown = (e) => {
        if (e.key === "Enter" && e.currentTarget.value.trim() !== "") {
            e.preventDefault();
            onAddTag(e.currentTarget.value.trim());
            e.currentTarget.value = "";
        }
    };

    const handleColorChange = (tag) => {
        tagToChangeRef.current = tag;
        if (colorInputRef.current) colorInputRef.current.click();
    };

    const onColorSelected = async (e) => {
        const newColor = e.target.value;
        const tag = tagToChangeRef.current;
        if (!tag || !newColor) return;

        try {
            const token = await window.nativeAPI.getSecretToken();
            await fetch(`http://localhost:4000/api/tags/${tag.name}`, {
                method: "PUT",
                headers: { 
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${token}` 
                },
                body: JSON.stringify({ color_hex: newColor }),
            });
            onDataChange(); // Refresh canvas data
        } catch (err) {
            console.error("Failed to update tag color", err);
        }
    };

    return (
        <div className="flex flex-wrap items-center gap-2 p-2 border-t border-black border-opacity-10 bg-white bg-opacity-20 mt-auto">
            {/* Hidden Color Input for Picker */}
            <input 
                type="color" 
                ref={colorInputRef} 
                onChange={onColorSelected} 
                className="w-0 h-0 opacity-0 absolute pointer-events-none" 
            />

            {(tags || []).map((tag) => (
                <TagPill 
                    key={tag.name} 
                    tag={tag} 
                    onRemove={onRemoveTag} 
                    onColorChange={handleColorChange} 
                />
            ))}
            
            <input 
                type="text" 
                onKeyDown={handleKeyDown} 
                placeholder="+ tag" 
                className="bg-transparent text-xs text-gray-600 placeholder-gray-400 focus:outline-none w-16 hover:w-24 transition-all" 
                onClick={(e) => e.stopPropagation()} 
            />
        </div>
    );
};

export default TagManager;
```

```jsx
// frontend\src\components\TaskWidget.jsx
import React, { useState, useEffect } from 'react';
import Draggable from 'react-draggable';
import { ResizableBox } from 'react-resizable';
import TagManager from './TagManager'; // Re-use your TagManager!
import "react-resizable/css/styles.css";

const formatTime = (ms) => {
  const s = Math.floor((ms / 1000) % 60).toString().padStart(2, '0');
  const m = Math.floor((ms / 1000 / 60) % 60).toString().padStart(2, '0');
  const h = Math.floor(ms / 1000 / 3600).toString().padStart(2, '0');
  return `${h}:${m}:${s}`;
};

const TaskWidget = ({ task, onUpdate, scale }) => {
  const nodeRef = useRef(null); // FIX: Added ref
  const [elapsed, setElapsed] = useState(task.total_time_ms || 0);

  // Timer Logic
  useEffect(() => {
    let interval;
    if (task.is_running && task.current_session_start) {
      interval = setInterval(() => {
        setElapsed((task.total_time_ms || 0) + (Date.now() - task.current_session_start));
      }, 1000);
    } else { setElapsed(task.total_time_ms || 0); }
    return () => clearInterval(interval);
  }, [task.is_running, task.current_session_start, task.total_time_ms]);

  const handleAction = async (action) => {
    const token = await window.nativeAPI.getSecretToken();
    await fetch(`http://localhost:4000/api/tasks/${task.id}/${action}`, {
       method: 'POST',
       headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
       body: JSON.stringify({ rating: 5, notes: "Session finished" }) // Now works with migration
    });
    onUpdate(); 
  };


  // Tag Handlers
  const handleTagAction = async (action, tagName) => {
      const token = await window.nativeAPI.getSecretToken();
      const method = action === 'add' ? 'POST' : 'DELETE';
      const url = action === 'add' 
        ? `http://localhost:4000/api/tags/tasks/${task.id}` 
        : `http://localhost:4000/api/tasks/${task.id}/tags/${tagName}`;
      
      await fetch(url, {
          method,
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: action === 'add' ? JSON.stringify({ name: tagName }) : undefined
      });
      onUpdate();
  };

  return (
    <Draggable nodeRef={nodeRef} scale={scale} handle=".task-header">
      <div ref={nodeRef} className="absolute z-30 shadow-2xl"> 
        <ResizableBox 
            width={300} height={180} minConstraints={[250, 150]} 
            className="rounded-xl overflow-hidden border border-gray-700 flex flex-col transition-colors"
            style={{ backgroundColor: task.color_hex || '#1f2937', color: 'white' }}
            handle={<span className="react-resizable-handle react-resizable-handle-se" />}
        >
            {/* Header */}
            <div className="task-header bg-black/20 p-2 cursor-move flex justify-between items-center select-none backdrop-blur-sm">
                <span className="font-bold text-sm truncate px-1">{task.title}</span>
                <div className={`w-2 h-2 rounded-full ${task.is_running ? 'bg-green-400 animate-pulse' : 'bg-red-500'}`} />
            </div>

            {/* Content */}
            <div className="flex-1 flex flex-col p-3 relative">
                 <div className="text-center my-auto">
                     <div className="font-mono text-5xl font-bold tracking-widest drop-shadow-lg opacity-90">
                         {formatTime(elapsed)}
                     </div>
                 </div>

                 {/* Tags Area */}
                 <div className="mt-2 mb-8 overflow-hidden">
                    <TagManager 
                        tags={task.tags || []} 
                        onAddTag={(t) => handleTagAction('add', t)}
                        onRemoveTag={(t) => handleTagAction('remove', t)}
                        onDataChange={onUpdate}
                    />
                 </div>

                 {/* Controls */}
                 <div className="absolute bottom-3 left-3 right-3 flex gap-2">
                     <button onClick={() => handleAction(task.is_running ? 'stop' : 'start')}
                        className={`flex-1 py-1.5 rounded text-xs font-bold uppercase shadow-lg transition-transform active:scale-95
                            ${task.is_running ? 'bg-red-500 hover:bg-red-400' : 'bg-green-500 hover:bg-green-400'}`}
                     >
                        {task.is_running ? 'STOP' : 'START'}
                     </button>
                 </div>
            </div>
        </ResizableBox>
      </div>
    </Draggable>
  );
};
export default TaskWidget;
```

```jsx
// frontend\src\components\WindowFrame.jsx
import React, { useRef } from 'react'; // 1. Import useRef
import Draggable from 'react-draggable';

const WindowFrame = ({ title, onClose, children, initialPos = { x: 100, y: 100 }, width = 500 }) => {
  const nodeRef = useRef(null); // 2. Create the reference

  return (
    <Draggable 
      handle=".window-header" 
      defaultPosition={initialPos}
      nodeRef={nodeRef} // 3. Tell Draggable to use this ref (Stops the error)
    >
      <div 
        ref={nodeRef} // 4. Attach the ref to the actual DIV
        className="absolute z-50 flex flex-col bg-white rounded-lg shadow-2xl border border-gray-700 overflow-hidden"
        style={{ width: width, minHeight: '300px' }}
      >
        {/* Window Header */}
        <div className="window-header h-8 bg-gray-800 text-white flex items-center justify-between px-3 cursor-move select-none">
          <span className="font-bold text-xs uppercase tracking-wider">{title}</span>
          <div className="flex space-x-2">
            <button 
              onClick={onClose}
              className="w-4 h-4 rounded-full bg-red-500 hover:bg-red-400 flex items-center justify-center"
            >
              <span className="text-xs pb-1">Ã—</span>
            </button>
          </div>
        </div>

        {/* Window Content */}
        <div className="flex-1 overflow-auto p-4 bg-gray-100 text-gray-900">
          {children}
        </div>
      </div>
    </Draggable>
  );
};

export default WindowFrame;
```

```jsx
// frontend\src\pages\Dashboard.jsx
// frontend/src/pages/Dashboard.jsx
import React, { useState, useEffect } from 'react';
// In Dashboard.jsx
import ShortcutWidget from '../components/ShortcutWidget';

// /!\ WARNING /!\
// This file was edited to remove all IPC calls to the main process.
// The backend server now handles all operations via REST API calls.
// Ensure the backend server is running and accessible for this to work.
// If window.electronAPI calls are found here, be careful if they are available or not.
// If not, replace them with appropriate API calls to the backend server.
/* Example replacement:

// In the same React component (e.g., KeyManager.jsx)

// No longer importing 'api' for IPC calls, as it's now for HTTP or removed.
// Access window.electronAPI directly, as it's exposed by the preload script.

const handleOpenFile = async () => {
  // Ensure window.electronAPI is available before calling its methods
  if (window.electronAPI && window.electronAPI.selectFile) {
    const filePath = await window.electronAPI.selectFile();
    if (filePath) {
      console.log('Selected file:', filePath);
    }
  } else {
    console.error("Electron API for file selection not available.");
  }
};


*/
import { getKeys, encryptFile, decryptFile, selectFile } from "../api";

function Dashboard() {
  const [selectedFile, setSelectedFile] = useState(null);
  const [keys, setKeys] = useState([]);
  const [selectedKeyId, setSelectedKeyId] = useState('');
  const [intensity, setIntensity] = useState(10); // Default intensity

  useEffect(() => {
    getKeys().then(setKeys);
  }, []);

  const handleFileSelect = async () => {
    const path = await selectFile();
    if (path) {
      setSelectedFile({ path, name: path.split(/[/\\]/).pop() });
    }
  };

  const handleEncrypt = async () => {
    if (!selectedFile || !selectedKeyId) {
      alert('Please select a file and a key.');
      return;
    }
    const selectedKey = keys.find(k => k._id === selectedKeyId);
    await encryptFile(selectedFile.path, selectedKey, intensity);
    setSelectedFile(null); // Clear after operation
  };

  const handleDecrypt = async () => {
    if (!selectedFile || !selectedKeyId) {
      alert('Please select a file and a key.');
      return;
    }
    const selectedKey = keys.find(k => k._id === selectedKeyId);
    await decryptFile(selectedFile.path, selectedKey);
    setSelectedFile(null); // Clear after operation
  };

  return (
    <div>
      <h1 className="text-3xl font-bold mb-6">Dashboard</h1>
      <div className="bg-white p-6 rounded-lg shadow-lg">
        {/* File Selection */}
        <div className="mb-4">
          <button onClick={handleFileSelect} className="px-4 py-2 bg-blue-500 text-white rounded">
            Select File
          </button>
          {selectedFile && <span className="ml-4 text-gray-700">Selected: {selectedFile.name}</span>}
        </div>

        {/* Key and Intensity Selection */}
        <div className="flex items-center space-x-4 mb-6">
          <select value={selectedKeyId} onChange={(e) => setSelectedKeyId(e.target.value)} className="p-2 border rounded">
            <option value="">-- Select a Key --</option>
            {keys.map(key => <option key={key._id} value={key._id}>{key.name}</option>)}
          </select>
          <label className="flex items-center space-x-2">
            <span>Time Intensity:</span>
            <input 
              type="range" 
              min="1" 
              max="1000" 
              value={intensity} 
              onChange={(e) => setIntensity(parseInt(e.target.value))} 
              className="w-48"
            />
            <span>{intensity}</span>
          </label>
        </div>

        {/* Action Buttons */}
        <div className="flex space-x-4">
          <button onClick={handleEncrypt} className="px-6 py-3 bg-green-600 text-white font-bold rounded hover:bg-green-700 disabled:bg-gray-400" disabled={!selectedFile || !selectedKeyId}>
            Encrypt
          </button>
          <button onClick={handleDecrypt} className="px-6 py-3 bg-red-600 text-white font-bold rounded hover:bg-red-700 disabled:bg-gray-400" disabled={!selectedFile || !selectedKeyId}>
            Decrypt
          </button>
        </div>
      </div>
      // Inside your render/return:
<div className="absolute top-20 left-20">
    <ShortcutWidget 
        shortcut={{ 
            title: "MPSI Drive", 
            target: "C:\\Users\\aperonylo\\Documents\\MPSI", 
            type: "url" 
        }} 
    />
</div>
<div className="absolute top-40 left-20">
    <ShortcutWidget 
        shortcut={{ 
            title: "Wolfram Alpha", 
            target: "https://www.wolframalpha.com", 
            type: "url" 
        }} 
    />
</div>
    </div>
    
  );
}

export default Dashboard;
```

```jsx
// frontend\src\pages\KeyManager.jsx
// frontend/src/pages/KeyManager.jsx
import React, { useState, useEffect } from 'react';
import { getKeys, saveKey } from '../api.js'; // Import the new API module
// Assume KeyConfigForm is a component for editing key details
import KeyConfigForm from '../components/KeyConfigForm'; 

function KeyManager() {
  const [keys, setKeys] = useState([]);
  const [selectedKey, setSelectedKey] = useState(null);

  const refreshKeys = () => {
    getKeys().then(setKeys);
  };

  useEffect(() => {
    refreshKeys();
  }, []);

  const handleSaveKey = async (keyData) => {
    await saveKey(keyData);
    refreshKeys();
    setSelectedKey(null); // Close the form
  };

  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-4">Key Manager</h1>
      <div className="flex space-x-4">
        <div className="w-1/3">
          <button onClick={() => setSelectedKey({})} className="w-full p-2 bg-blue-500 text-white rounded">
            Create New Key
          </button>
          <ul className="mt-4 space-y-2">
            {keys.map(key => (
              <li key={key._id} onClick={() => setSelectedKey(key)} className="p-2 border rounded cursor-pointer hover:bg-gray-200">
                {key.name}
              </li>
            ))}
          </ul>
        </div>
        <div className="w-2/3">
          {selectedKey && (
            <KeyConfigForm
              initialData={selectedKey}
              onSave={handleSaveKey}
              onCancel={() => setSelectedKey(null)}
            />
          )}
        </div>
      </div>
    </div>
  );
}

export default KeyManager;
```

```js
// frontend\src\styles\theme.js
export const NOTE_COLORS = {
    yellow: "#fff000",
    blue: "#a7ffeb",
    pink: "#f8bbd0",
    green: "#ccff90"
};
```

```js
// shared\constants.js
// shared/constants.js
// This contract ensures the frontend and backend always speak the same language.
// Changing a value here updates it everywhere.

module.exports = {
  IPC_CHANNELS: {
    // File operations
    FILE_SELECT: 'file:select',
    FILE_ENCRYPT: 'file:encrypt',
    FILE_DECRYPT: 'file:decrypt',
    
    // Database: Keys
    DB_GET_KEYS: 'db:get-keys',
    DB_SAVE_KEY: 'db:save-key',
    DB_DELETE_KEY: 'db:delete-key',

    // Database: Peers & Seeds
    DB_GET_PEERS: 'db:get-peers',
    DB_ADD_PEER: 'db:add-peer',

    // P2P operations
    P2P_CREATE_SEED: 'p2p:create-seed',
    P2P_SEND_FILE: 'p2p:send-file',

    // UI Notifications
    NOTIFY_USER: 'notify:user',
    NOTIFY_PROGRESS: 'notify:progress',
  }
};
```

```js
// shared\validation-shemas.js

```

