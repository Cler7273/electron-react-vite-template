Presentation of file contents for project located at: C:\Users\aperonylo\Desktop\python\__NASMCrypto\cc-app
=================================================================

```text
// .gitignore
# Node.js
node_modules/

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Vite
frontend/dist/
frontend/.vite/

# Electron
*.asar
*.asar.unpacked

dist/
release/
win-unpacked/
release_sure/
build/
release_sure$/
dist/
release/
build/
*.exe
# Ignore all build outputs
release_sure$/
release_sure/
dist/
build/
win-unpacked/
*.exe

# OS
.DS_Store
Thumbs.db

# dotenv
env/
*.env
*.env.local

# Babel
backend/dist/

# Editor
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
```

```text
// LICENSE
MIT License

Copyright (c) 2025 Rahil Vahora

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

```json
// package.json
{
    "name": "nasm-cryptor",
    "version": "1.0.0",
    "description": "Advanced cryptographic application using the NASMFAG principle.",
    "main": "electron/main.js",
    "scripts": {
        "start": "concurrently  \"npm:dev:vite\" \"npm:dev:electron\"",
        "dev:vite": "vite frontend",
        "dev:electron": "wait-on tcp:5173 && electron .",
        "build": "vite build frontend && electron-builder",
        "test": "echo \"Error: no test specified\" && exit 1",
        "rebuild": "npx @electron/rebuild --force --module-dir ."
    },
    "author": "Dan",
    "license": "MIT",
    "dependencies": {
        "better-sqlite3": "^11.1.2",
        "cors": "^2.8.5",
        "express": "^4.21.2",
        "nedb-promises": "^6.2.3",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "react-draggable": "^4.4.6",
        "react-resizable": "^3.0.5"
    },
    "devDependencies": {
        "@electron/rebuild": "^3.6.0",
        "@vitejs/plugin-react": "^4.3.1",
        "autoprefixer": "^10.4.19",
        "concurrently": "^8.2.2",
        "electron": "^31.2.1",
        "electron-builder": "^25.1.8",
        "postcss": "^8.4.39",
        "tailwindcss": "^3.4.6",
        "vite": "^5.3.4",
        "wait-on": "^7.2.0"
    },
    "build": {
        "appId": "com.cognicanvas.app",
        "productName": "CogniCanvas",
        "files": [
            "frontend/dist/",
            "electron/",
            "backend/",
            "node_modules/",
            "package.json"
        ],
        "directories": {
            "buildResources": "assets",
            "output": "release"
        },
        "win": {
            "target": "nsis",
            "publisherName": "YourName",
            "verifyUpdateCodeSignature": false
        },
        "nsis": {
            "oneClick": false,
            "allowToChangeInstallationDirectory": true
        }
    }
}
```

```md
// readme.md
# React Frontend + Vite + Node.js Backend + Electron

A complete setup for building a cross-platform desktop application using React (frontend), Vite (development tooling), Node.js (backend), and Electron (desktop environment). This project serves as a template for developers looking to build modern desktop applications with a lightweight backend.

---

## Features

- **Frontend**: React powered by Vite for fast builds and development.
- **Backend**: Node.js with Express and ES6+.
- **Electron**: Cross-platform desktop application framework.
- **Integrated Workflow**:
  - Single command to run frontend, backend, and Electron together.
  - Easy packaging for production with `electron-builder`.

---

## Getting Started

### Prerequisites

- **Node.js**: Install from [Node.js website](https://nodejs.org/).

---

### Installation

1. Clone the repository:

   ```bash
   git clone https://github.com/rahil1202/react-electron-vite-template.git
   cd electron-react-vite-template
   ```

2. Install dependencies:

   ```bash
   npm install 
   cd frontend && npm install
   cd backend && npm install
   ```

---

### Development

To run the project in development mode:
Go to root directory

```bash
npm run dev
```

This will:

- Start the **React frontend** (`http://localhost:5173`).
- Start the **Node.js backend** (`http://localhost:4000`).
- Launch the **Electron desktop application**.

---

### Build for Production

1. Build the React frontend:

   ```bash
   npm run build
   ```

2. Package the app for distribution:

   ```bash
   npx electron-builder
   ```
If it fails run terminal as administrator and then run above code again.

3. The packaged app will be available in the `dist/` directory, with name `react-electron-vite-template Setup.exe`
   You may install it and use it. It can be share across easily

---

### Project Structure

```plaintext
project/
â”œâ”€â”€ backend/            # Node.js backend
â”‚   â”œâ”€â”€ src/            # Backend source code
â”‚   â””â”€â”€ package.json    # Backend dependencies
â”‚
â”œâ”€â”€ frontend/           # React frontend (with Vite)
â”‚   â”œâ”€â”€ src/            # React source code
â”‚   â””â”€â”€ package.json    # Frontend dependencies
â”‚
â”œâ”€â”€ electron/           # Electron main and preload scripts
â”‚   â”œâ”€â”€ main.js         # Main process
â”‚   â””â”€â”€ preload.js      # Preload script
â”‚
â”œâ”€â”€ package.json        # Root dependencies for Electron
â””â”€â”€ README.md           # Project documentation
```

---

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## Author

- GitHub: [rahil1202](https://github.com/rahil1202)
- Email: <rahilisvahora@gmail.com>
- LinkedIn:[rahil-vahora](https://linkedin.com/in/rahil-vahora)
```

```md
// readme_todo_next.md
To move **CogniCanva** toward a professional, Google-like desktop environment, we must address the remaining technical debt and functional gaps.

Here is the thorough list of problems categorized by priority:

### 1. High Priority: Data Integrity & OS Architecture
*   **Database Migration Reliability:** The current "on-the-fly" migration for the `rating` column is a hotfix. We need a robust versioning system for `cognicanvas.db` so that future schema changes (like adding efficiency rates) don't crash the app.
*   **Window Z-Index Management:** Currently, when multiple windows (Cryptor, Settings, Tasks) are open, clicking one doesn't necessarily bring it to the "front." We need a "Focus" system where the active window's Z-index is incremented.
*   **Shortcuts Path Normalization:** On Windows, paths like `C:/Users` vs `C:\Users` can break `child_process.exec`. We need a centralized backend utility to sanitize paths before executing `start ""`.
*   **Global Settings Persistence:** The `settings` table is implemented, but the Frontend doesn't yet load the theme (Canvas color) or saved shortcuts automatically on startup.

### 2. High Priority: Canvas Mechanics (CogniCanvas)
*   **Recursive Frame Movement:** If a Frame is inside another Frame (nested structure), the movement logic currently only moves direct children. We need recursive coordinate updates.
*   **Drag-to-Capture Precision:** The "Note Capture" logic currently uses a simple center-point check. This can feel "glitchy" with large notes and small frames. It needs a "Collision Detection" algorithm (AABB intersection).
*   **Teleport Links (Broken/Missing):** The `[[note:id]]` syntax is parsed, but clicking the link doesn't yet "pan and zoom" the camera to the target note.
*   **Note Scaling vs Content:** When a note is resized very small, the `TagManager` and `Content` overlap and become unreadable. We need "Adaptive UI" (hiding the tag bar if the height is < 100px).

### 3. Functional Gaps: The MPSI App Suite
*   **The "Calendar/Efficiency" Gap:** Tasks are logged, but there is no UI to see the history. We need a "Log Viewer" app that displays sessions by day, showing the calculated efficiency (Time vs Rating).
*   **Chronometer Persistence:** If the app is closed while a timer is running, the `start_time` is saved, but the UI doesn't "resume" the count automatically when the app restarts.
*   **Task Widget Customization:** Unlike Notes, Tasks don't yet have the right-click color picker or the ability to change their individual background colors.

### 4. Technical Debt: Performance & Warnings
*   **The "findDOMNode" Plague:** While fixed in `TaskWidget` and `WindowFrame`, this warning likely still exists in `Frame.jsx` and `Note.jsx`. Every `Draggable` instance must be verified for `nodeRef` usage.
*   **Canvas Render Bottleneck:** Re-rendering the entire canvas (every note and frame) when one note moves is inefficient. We should move to a more optimized state management (like `Zustand` or localized state) to prevent "Note Jitter."
*   **Search Regex Support:** The search currently only supports simple strings. For MPSI students, Regex support (e.g., searching `math|physics`) is a high-value tool.

### 5. Cryptor 2.0 (The Standalone Rework)
*   **Key Generator UI:** The current "Key Vault" is too simple. It needs a "Pro Mode" where the user can choose the NASM Degree (`d`), the specific mathematical operations (`I`), and the Transformation Constants (`TC`) manually.
*   **Large File Streaming:** Encrypting a 1GB file currently loads the whole buffer into memory, which will crash the app. We need to move from `fs.readFile` to `fs.createReadStream` to handle large MPSI lecture videos.

### 6. UX & "Google-Like" Polish
*   **Command Palette:** Implement `Ctrl + K` to open a global search bar (like Google Search or Spotlight) that can launch apps, search notes, or trigger system commands.
*   **Desktop "Dock" Feedback:** Icons in the left dock don't show "Active" indicators (e.g., a small dot underneath) if an app is open but minimized/behind others.

---

**Which one should we solve next?**
1.  **The "Front-End Focus" (Z-index + Teleport Links + nodeRef cleanup)**
2.  **The "Task Evolution" (Calendar/History App + Chronometer persistence)**
3.  **The "Cryptor 2.0" (Pro Key Gen + Large File Streaming)**

---

Understood. I have integrated the new crash report into the master list. Here is the thorough breakdown of all current issues and technical debt within **CogniCanva**.

### Group A: Critical Crashes & System Errors
1.  **Canvas Rendering Crash (`ReferenceError: view is not defined`):** The recent refactor from `view` state to `viewRef` caused a break in the JSX render. Line 252 is attempting to access a variable `view` that no longer exists in that scope.
2.  **Database Schema Mismatch (`SqliteError: no such column: rating`):** The backend is attempting to write to columns that don't exist in the user's local `cognicanvas.db`. The migration script failed to execute or was blocked.
3.  **Double-Click "Forbidden Area":** Clicks inside the note-populated area of the canvas fail to create new notes because the `transform-layer` is capturing pointer events without a proper fallback to the container.

### Group B: UI/UX & Mechanics (The "Desktop" Feel)
1.  **Zoom Anchor Logic:** Zooming currently centers on the top-left (0,0) or a static center rather than the user's mouse pointer, making navigation disorienting.
2.  **The "Inertia" Conflict:** Note/Frame movement feels laggy because CSS transitions are conflicting with real-time `react-draggable` coordinate updates.
3.  **Frame-Child Synchronization:** When a Frame moves, the notes inside must move recursively. When a Frame collapses, the notes must be visually and functionally "unmounted" to prevent accidental interaction.
4.  **`findDOMNode` Deprecation Warnings:** Several components (`TaskWidget`, `Note`, `Frame`) are triggering StrictMode warnings that will cause issues in future React versions.

### Group C: MPSI Suite (Tasks & Chronometer)
1.  **Task Widget UX:** Tasks currently lack a "Seconds" display, a functional "Stop" button in the UI, and a resize handle.
2.  **Chronometer Persistence:** If the app restarts, running timers do not visually resume counting despite being active in the database.
3.  **Session History (The "Calendar" Data):** We have the data structure for `ratings` and `session_notes`, but no interface to view the history of study sessions.
4.  **Task Color/Tag Integration:** Tasks need the same tagging and color-customization logic as Notes to allow for future "Efficiency Filtering."

### Group D: System Services & Apps
1.  **Settings App (The Control Panel):** No functional UI exists to manage theme colors (stored in DB) or to add/delete shortcuts using a native file picker.
2.  **Shortcut Path Normalization:** Windows paths (`\` vs `/`) are causing silent failures or defaulting to `C:/` when launching external MPSI apps.
3.  **Cryptor 2.0:** The encryption tool needs to be converted from a dashboard page to a standalone floating window with a "Vault" for managing NASM keys.

### Group E: Advanced Power Features
1.  **Teleport Links:** The `[[note:id]]` links are rendered but do not yet trigger the Canvas to pan/zoom to the target coordinate.
2.  **Command Palette (`Ctrl + K`):** No global search/action bar exists to allow "Google-like" navigation through the OS.
3.  **Search Regex Support:** Search is currently limited to plain text; complex filtering for MPSI study (e.g., `math AND urgent`) is missing.

---

**Which specific problem should we tackle first?** 
*(I recommend starting with **A1** and **A2** to stop the app from crashing, or **D1** to build the foundation for theme customization).*





AFTER SOME IMPROVEMENTS, WE ARE NOW HERE

# CogniCanvas: Project Status & Handover

## Critical Fixes Deployed
1.  **HUD Restoration:** Task Widgets are now rendered in Screen Space (HUD), meaning they stay fixed on your screen while you zoom/pan the canvas.
2.  **HTML Interpretation:** Notes now correctly display bold, italics, and custom links (`[[note:id]]`) without displaying raw HTML tags. The saving logic has been strictly scoped to avoid double-encoding.
3.  **Task Calendar:** A detailed "Day View" has been added. Clicking a square on the heatmap reveals the exact tasks and durations for that day.
4.  **Crash Fixes:** Removed the infinite loop in `TaskWidget` and the `useRef` crash.

## Known Omissions & Technical Debt
*   **Window Dragging:** The `App.jsx` uses a simplified window rendering logic. The Z-Index management (bringing a clicked window to front) is basic.
*   **Task Deletion:** I implemented a "Hide" logic for task termination in the widget. A true `DELETE /api/tasks/:id` endpoint in `server.js` was added in the previous step but ensure it is robust (cascading deletes for time logs).
*   **Performance:** `Canvas.jsx` re-renders frequently on zoom/pan. For large datasets (>100 notes), migrate the `view` state to a Ref-based loop (requestAnimationFrame) to decouple React renders from 60fps canvas updates.

## Roadmap for Next Developer
1.  **Mobile Companion App:** Build a simple React Native app that connects to the same IP (P2P logic from `p2p-service.js` is the foundation).
2.  **Search Regex UI:** The backend supports Regex, but the Frontend search bar needs a "Toggle Regex" button to switch between plain text and regex modes.
3.  **Encrypted Sync:** The `nasm-engine.js` is powerful. Use it to encrypt the entire SQLite DB file before syncing to cloud (Google Drive/Dropbox API).

## Debugging
*   **Notes:** Check console for `[Note X Debug]` to see exactly what HTML is being saved vs rendered.
*   **Tasks:** If tasks don't appear in HUD, verify `showTasks` prop in `Canvas.jsx` is true.

THIS STATE IS COMPLEMENTARY AND DOESN'T OVERHAUL THE PREVIOUS UPGRADES TO BE DONE

As of 18/2/26 finish on big guys and needed further devs are : Crypto app + HUD refinenement + documentation creation to create sustainably apps + gamification of time
```

```bat
// run.bat
cd C:\Users\aperonylo\Desktop\python\__NASMCrypto\cc-app
npm start
```

```js
// backend\server.js
// backend/server.js - CHUNK 1
const express = require("express");
const cors = require("cors");
const Database = require("better-sqlite3");
const path = require("path");
const fileService = require("./services/file-service");
// const dbService = require("./services/db-service"); // Temporarily ignored as per instruction
const systemService = require("./services/system-service");

const PORT = 4000;
const app = express();
// Helper: Safe Duration Calculator
const getDuration = (start, end) => {
    if (!start || !end) return 0;
    const s = new Date(start).getTime();
    const e = new Date(end).getTime();
    return isNaN(s) || isNaN(e) ? 0 : e - s;
};
// Args handling
const SECRET_TOKEN = process.argv[2];
const USER_DATA_PATH = process.argv[3];

if (!SECRET_TOKEN || !USER_DATA_PATH) {
    console.error("FATAL ERROR: Server started without token or path.");
    process.exit(1);
}

app.use(cors());
app.use(express.json());

// Security Middleware
app.use((req, res, next) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || authHeader !== `Bearer ${SECRET_TOKEN}`) {
        return res.status(403).json({ error: "Forbidden: Invalid token." });
    }
    next();
});

// Database Initialization
const db = new Database("cognicanvas.db");

// Register Regex Function for Search
db.function("regexp", (pattern, str) => {
    try {
        return new RegExp(pattern, "i").test(str) ? 1 : 0;
    } catch (e) {
        return 0;
    }
});
db.pragma("foreign_keys = ON");

// --- MIGRATION SYSTEM ---
const MIGRATIONS = [
    {
        version: 1,
        up: `
            CREATE TABLE IF NOT EXISTS frames (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, pos_x INTEGER, pos_y INTEGER, width INTEGER, height INTEGER, is_collapsed BOOLEAN DEFAULT 0);
            CREATE TABLE IF NOT EXISTS notes (id INTEGER PRIMARY KEY AUTOINCREMENT, content TEXT, pos_x INTEGER, pos_y INTEGER, width INTEGER, height INTEGER, color_hex TEXT, frame_id INTEGER, FOREIGN KEY (frame_id) REFERENCES frames(id) ON DELETE CASCADE);
            CREATE TABLE IF NOT EXISTS tags (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL UNIQUE, color_hex TEXT DEFAULT '#3b82f6');
            CREATE TABLE IF NOT EXISTS note_tags (note_id INTEGER, tag_id INTEGER, PRIMARY KEY (note_id, tag_id), FOREIGN KEY (note_id) REFERENCES notes(id) ON DELETE CASCADE, FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE);
            CREATE TABLE IF NOT EXISTS frame_tags (frame_id INTEGER, tag_id INTEGER, PRIMARY KEY (frame_id, tag_id), FOREIGN KEY (frame_id) REFERENCES frames(id) ON DELETE CASCADE, FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE);
            CREATE TABLE IF NOT EXISTS tasks (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, is_done BOOLEAN DEFAULT 0, created_at INTEGER, total_time_ms INTEGER DEFAULT 0, color_hex TEXT DEFAULT '#1f2937');
            CREATE TABLE IF NOT EXISTS time_logs (id INTEGER PRIMARY KEY AUTOINCREMENT, task_id INTEGER, start_time INTEGER, end_time INTEGER, FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE);
            CREATE TABLE IF NOT EXISTS task_tags (task_id INTEGER, tag_id INTEGER, PRIMARY KEY (task_id, tag_id), FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE, FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE);
            CREATE TABLE IF NOT EXISTS shortcuts (id INTEGER PRIMARY KEY AUTOINCREMENT, title TEXT, target TEXT, type TEXT DEFAULT 'url', icon TEXT DEFAULT 'ðŸš€');
            CREATE TABLE IF NOT EXISTS settings (key TEXT PRIMARY KEY, value TEXT);
        `,
    },
    {
        version: 2,
        up: `
            ALTER TABLE time_logs ADD COLUMN rating INTEGER DEFAULT 0;
            ALTER TABLE time_logs ADD COLUMN session_notes TEXT;
        `,
    },
    {
        version: 3,
        up: `
            ALTER TABLE tasks ADD COLUMN color_hex TEXT DEFAULT '#1f2937';
        `,
    },
    {
        version: 4,
        up: `
            ALTER TABLE time_logs ADD COLUMN manual_note TEXT;
        `,
    },
    {
        version: 5,
        up: `
            UPDATE tasks SET is_done = 0 WHERE is_done IS NULL;
        `,
    },
];

const runMigrations = () => {
    db.exec(`CREATE TABLE IF NOT EXISTS schema_version (version INTEGER DEFAULT 0)`);
    const result = db.prepare("SELECT version FROM schema_version").get();
    let currentVersion = result ? result.version : 0;

    if (!result) db.prepare("INSERT INTO schema_version (version) VALUES (0)").run();

    console.log(`[DB] Current Schema Version: ${currentVersion}`);

    db.transaction(() => {
        for (const migration of MIGRATIONS) {
            if (migration.version > currentVersion) {
                console.log(`[DB] Applying migration v${migration.version}...`);
                try {
                    const tableInfoTimeLogs = db.prepare("PRAGMA table_info(time_logs)").all();
                    const tableInfoTasks = db.prepare("PRAGMA table_info(tasks)").all();

                    if (migration.version === 2 && tableInfoTimeLogs.some((c) => c.name === "rating")) {
                        /* skip */
                    } else if (migration.version === 3 && tableInfoTasks.some((c) => c.name === "color_hex")) {
                        /* skip */
                    } else if (migration.version === 4 && tableInfoTimeLogs.some((c) => c.name === "manual_note")) {
                        /* skip */
                    } else {
                        db.exec(migration.up);
                    }
                } catch (e) {
                    if (!e.message.includes("duplicate column")) throw e;
                }
                currentVersion = migration.version;
            }
        }
        db.prepare("UPDATE schema_version SET version = ?").run(currentVersion);
    })();
    console.log(`[DB] Database is up to date (v${currentVersion}).`);
};

runMigrations();

// --- HELPERS ---
const getTagsFor = (table, id) => {
    return db.prepare(`SELECT t.name, t.color_hex FROM tags t JOIN ${table}_tags nt ON t.id = nt.tag_id WHERE nt.${table}_id = ?`).all(id);
};

// --- API ROUTES: GENERAL & CANVAS ---
app.get("/api/shortcuts", (req, res) => {
    try {
        const shortcuts = db.prepare("SELECT * FROM shortcuts").all();
        res.json(shortcuts);
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.post("/api/shortcuts", (req, res) => {
    try {
        const { title, target, type } = req.body;
        const stmt = db.prepare("INSERT INTO shortcuts (title, target, type) VALUES (?, ?, ?)");
        const info = stmt.run(title, target, type);
        res.json({ id: info.lastInsertRowid, ...req.body });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.delete("/api/shortcuts/:id", (req, res) => {
    db.prepare("DELETE FROM shortcuts WHERE id = ?").run(req.params.id);
    res.json({ success: true });
});

app.get("/api/settings", (req, res) => {
    const rows = db.prepare("SELECT * FROM settings").all();
    const settings = {};
    rows.forEach((r) => (settings[r.key] = r.value));
    res.json(settings);
});

app.post("/api/settings", (req, res) => {
    const { key, value } = req.body;
    db.prepare("INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)").run(key, value);
    res.json({ success: true });
});

app.get("/api/all", (req, res) => {
    const notes = db
        .prepare("SELECT * FROM notes")
        .all()
        .map((n) => ({ ...n, tags: getTagsFor("note", n.id) }));
    const frames = db
        .prepare("SELECT * FROM frames")
        .all()
        .map((f) => ({ ...f, tags: getTagsFor("frame", f.id) }));

    const tasks = db
        .prepare("SELECT * FROM tasks")
        .all()
        .map((task) => {
            // Check for active session (is_running)
            const activeLog = db.prepare("SELECT start_time FROM time_logs WHERE task_id = ? AND end_time IS NULL").get(task.id);
            const tags = getTagsFor("task", task.id);
            return {
                ...task,
                is_running: !!activeLog,
                current_session_start: activeLog ? activeLog.start_time : null,
                tags: tags,
            };
        });

    res.json({ notes, frames, tasks });
});

app.post("/api/notes", (req, res) => {
    const { content, pos_x, pos_y, width, height, color_hex } = req.body;
    const info = db.prepare("INSERT INTO notes (content, pos_x, pos_y, width, height, color_hex) VALUES (?, ?, ?, ?, ?, ?)").run(content, pos_x, pos_y, width, height, color_hex);
    res.status(201).json({ id: info.lastInsertRowid, ...req.body, tags: [] });
});

app.get("/api/search", (req, res) => {
    try {
        const query = req.query.q;
        if (!query) return res.status(200).json({ noteIds: [], frameIds: [] });

        const noteIds = db
            .prepare(`SELECT id FROM notes WHERE content REGEXP ?`)
            .all(query)
            .map((row) => row.id);

        const frameIds = db
            .prepare(`SELECT id FROM frames WHERE title REGEXP ?`)
            .all(query)
            .map((row) => row.id);

        res.status(200).json({ noteIds, frameIds });
    } catch (error) {
        try {
            const fallbackQuery = `%${query}%`;
            const noteIds = db
                .prepare(`SELECT id FROM notes WHERE content LIKE ?`)
                .all(fallbackQuery)
                .map((r) => r.id);
            const frameIds = db
                .prepare(`SELECT id FROM frames WHERE title LIKE ?`)
                .all(fallbackQuery)
                .map((r) => r.id);
            res.status(200).json({ noteIds, frameIds });
        } catch (e) {
            res.status(500).json({ error: error.message });
        }
    }
});

app.put("/api/notes/:id", (req, res) => {
    try {
        const { content, pos_x, pos_y, width, height, color_hex, frame_id } = req.body;
        const existing = db.prepare("SELECT * FROM notes WHERE id = ?").get(req.params.id);
        if (!existing) return res.status(404).json({ error: "Note not found" });

        const finalFrameId = frame_id === undefined ? existing.frame_id : frame_id;
        const stmt = db.prepare(`
        UPDATE notes SET 
        content = COALESCE(?, content), 
        pos_x = COALESCE(?, pos_x), 
        pos_y = COALESCE(?, pos_y), 
        width = COALESCE(?, width), 
        height = COALESCE(?, height), 
        color_hex = COALESCE(?, color_hex),
        frame_id = ?
        WHERE id = ?`);

        stmt.run(content, pos_x, pos_y, width, height, color_hex, finalFrameId, req.params.id);
        res.json({ success: true });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.delete("/api/notes/:id", (req, res) => {
    db.prepare("DELETE FROM notes WHERE id = ?").run(req.params.id);
    res.json({ success: true });
});

// --- TAGS ---
app.post("/api/tags/:itemType/:itemId", (req, res) => {
    const { itemType, itemId } = req.params;
    const { name } = req.body;

    let table;
    if (itemType === "notes") table = "note";
    else if (itemType === "frames") table = "frame";
    else if (itemType === "tasks") table = "task";
    else return res.status(400).json({ error: "Invalid item type" });

    db.transaction(() => {
        let tag = db.prepare("SELECT id FROM tags WHERE name = ?").get(name);
        if (!tag) {
            const info = db.prepare("INSERT INTO tags (name) VALUES (?)").run(name);
            tag = { id: info.lastInsertRowid };
        }
        db.prepare(`INSERT OR IGNORE INTO ${table}_tags (${table}_id, tag_id) VALUES (?, ?)`).run(itemId, tag.id);
    })();
    res.status(201).json({ message: "Tag added" });
});

app.delete("/api/:itemType/:itemId/tags/:tagName", (req, res) => {
    const { itemType, itemId, tagName } = req.params;
    let table;
    if (itemType === "notes") table = "note";
    else if (itemType === "frames") table = "frame";
    else if (itemType === "tasks") table = "task";

    const tag = db.prepare("SELECT id FROM tags WHERE name = ?").get(tagName);
    if (tag) {
        db.prepare(`DELETE FROM ${table}_tags WHERE ${table}_id = ? AND tag_id = ?`).run(itemId, tag.id);
    }
    res.json({ message: "Tag removed" });
});

app.put("/api/tags/:name", (req, res) => {
    db.prepare("UPDATE tags SET color_hex = ? WHERE name = ?").run(req.body.color_hex, req.params.name);
    res.json({ success: true });
});

// --- KEYS & CRYPTO (Stubbed to not fail, mostly ignored for now) ---
app.get("/api/keys", async (req, res) => {
    // dbService is ignored as per instructions, returning empty array
    res.json([]);
});
app.post("/api/keys", async (req, res) => {
    res.status(501).json({ error: "Not implemented in this version" });
});
app.delete("/api/keys/:id", async (req, res) => {
    res.status(501).json({ error: "Not implemented in this version" });
});
app.post("/api/encrypt", async (req, res) => {
    const { filePath, keyConfig, intensity, savePath } = req.body;
    try {
        const result = await fileService.encryptFile(
            filePath,
            keyConfig,
            intensity,
            savePath,
            () => {},
            () => {},
        );
        res.json(result);
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});
app.post("/api/decrypt", async (req, res) => {
    const { filePath, keyConfig, savePath } = req.body;
    try {
        const result = await fileService.decryptFile(
            filePath,
            keyConfig,
            savePath,
            () => {},
            () => {},
        );
        res.json(result);
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

// --- SYSTEM ---
app.post("/api/system/open", async (req, res) => res.json(await systemService.openExternal(req.body.target)));
app.post("/api/system/run", async (req, res) => res.json(await systemService.runCommand(req.body.command, req.body.args)));

// --- FRAMES ---
app.post("/api/frames", (req, res) => {
    try {
        const { title, pos_x, pos_y, width, height } = req.body;
        const stmt = db.prepare("INSERT INTO frames (title, pos_x, pos_y, width, height, is_collapsed) VALUES (?, ?, ?, ?, ?, 0)");
        const info = stmt.run(title, pos_x, pos_y, width, height);
        res.status(201).json({ id: info.lastInsertRowid, ...req.body });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.put("/api/frames/:id", (req, res) => {
    try {
        const { title, pos_x, pos_y, width, height, is_collapsed } = req.body;
        const updates = [];
        const params = [];

        const fields = { title, pos_x, pos_y, width, height, is_collapsed };
        for (const [key, val] of Object.entries(fields)) {
            if (val !== undefined) {
                updates.push(`${key} = ?`);
                params.push(val);
            }
        }

        params.push(req.params.id);
        db.prepare(`UPDATE frames SET ${updates.join(", ")} WHERE id = ?`).run(...params);
        res.json({ success: true });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.delete("/api/frames/:id", (req, res) => {
    db.prepare("DELETE FROM frames WHERE id = ?").run(req.params.id);
    res.json({ success: true });
});

// backend/server.js - CHUNK 2

// --- TASKS API ---

// 1. STATUS ENDPOINT (Heartbeat)
// Objective: Check if ANY task is currently running.
// GET: The "Authority" check for persistence
app.get("/api/tasks/active-session", (req, res) => {
    try {
        const activeLog = db
            .prepare(
                `
            SELECT t.id, t.title, t.color_hex, t.total_time_ms, l.start_time, l.id as log_id 
            FROM time_logs l 
            JOIN tasks t ON l.task_id = t.id 
            WHERE l.end_time IS NULL
        `,
            )
            .get();

        if (activeLog) {
            const tags = getTagsFor("task", activeLog.id);
            res.json({ ...activeLog, tags });
        } else {
            res.json(null);
        }
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.post("/api/tasks", (req, res) => {
    try {
        const { title, color_hex } = req.body;
        const stmt = db.prepare("INSERT INTO tasks (title, is_done, created_at, total_time_ms, color_hex) VALUES (?, 0, ?, 0, ?)");
        const info = stmt.run(title, Date.now(), color_hex || "#1f2937");
        res.status(201).json({ id: info.lastInsertRowid, title, is_done: 0, total_time_ms: 0, color_hex: color_hex || "#1f2937", tags: [] });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.put("/api/tasks/:id", (req, res) => {
    try {
        const { color_hex, title, is_done } = req.body;
        const updates = [];
        const params = [];

        if (color_hex !== undefined) {
            updates.push("color_hex = ?");
            params.push(color_hex);
        }
        if (title !== undefined) {
            updates.push("title = ?");
            params.push(title);
        }
        if (is_done !== undefined) {
            updates.push("is_done = ?");
            params.push(is_done ? 1 : 0);
        }

        if (updates.length === 0) return res.json({ success: true, message: "No fields to update" });

        params.push(req.params.id);
        db.prepare(`UPDATE tasks SET ${updates.join(", ")} WHERE id = ?`).run(...params);

        res.json({ success: true });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

app.delete("/api/tasks/:id", (req, res) => {
    try {
        const deleteTransaction = db.transaction((id) => {
            db.prepare("DELETE FROM time_logs WHERE task_id = ?").run(id);
            db.prepare("DELETE FROM task_tags WHERE task_id = ?").run(id);
            db.prepare("DELETE FROM tasks WHERE id = ?").run(id);
        });
        deleteTransaction(req.params.id);
        res.json({ success: true });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

// 2. START TASK (Validation)
// Objective: Prevent starting a new task if one is already running (Global Singleton).
app.post("/api/tasks/:id/start", (req, res) => {
    try {
        const { id } = req.params;
        const now = new Date().toISOString();
        const running = db.prepare(`SELECT t.id, t.title FROM time_logs l JOIN tasks t ON l.task_id = t.id WHERE l.end_time IS NULL`).get();

        if (running) {
            return res.status(409).json({ error: "Protocol already active", runningTask: running });
        }

        const info = db.prepare("INSERT INTO time_logs (task_id, start_time) VALUES (?, ?)").run(id, now);
        res.json({ logId: info.lastInsertRowid, start_time: now });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});

// 3. ATOMIC STOP
// Objective: Stop timer, update totals, and return the FULL updated task object to sync frontend.
// POST: Atomic Stop with full task return
app.post("/api/tasks/:id/stop", (req, res) => {
    try {
        const { manual_note } = req.body;
        const nowStr = new Date().toISOString();
        const log = db.prepare("SELECT * FROM time_logs WHERE task_id = ? AND end_time IS NULL").get(req.params.id);

        if (log) {
            const durationMs = new Date(nowStr).getTime() - new Date(log.start_time).getTime();

            db.transaction(() => {
                db.prepare("UPDATE time_logs SET end_time = ?, manual_note = ? WHERE id = ?").run(nowStr, manual_note || "", log.id);
                db.prepare("UPDATE tasks SET total_time_ms = total_time_ms + ? WHERE id = ?").run(durationMs, req.params.id);
            })();

            const updatedTask = db.prepare("SELECT * FROM tasks WHERE id = ?").get(req.params.id);
            res.json({
                success: true,
                task: { ...updatedTask, is_running: false, tags: getTagsFor("task", req.params.id) },
            });
        } else {
            res.status(400).json({ error: "No running timer" });
        }
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});
// NEW: Delete individual log
app.delete("/api/history/:id", (req, res) => {
    try {
        // We also need to deduct this log's duration from the task's total_time_ms
        const log = db.prepare("SELECT * FROM time_logs WHERE id = ?").get(req.params.id);
        if (log && log.end_time) {
            const duration = new Date(log.end_time).getTime() - new Date(log.start_time).getTime();
            
            db.transaction(() => {
                db.prepare("UPDATE tasks SET total_time_ms = total_time_ms - ? WHERE id = ?").run(duration, log.task_id);
                db.prepare("DELETE FROM time_logs WHERE id = ?").run(req.params.id);
            })();
        } else {
            // If it's a running log (active session), just delete it without time deduction
            db.prepare("DELETE FROM time_logs WHERE id = ?").run(req.params.id);
        }
        res.json({ success: true });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});
app.post("/api/dev/generate-logs", (req, res) => {
    try {
        const { taskId, count } = req.body;
        const now = new Date();
        const logs = [];
        
        const insertLog = db.prepare("INSERT INTO time_logs (task_id, start_time, end_time, rating, manual_note) VALUES (?, ?, ?, ?, ?)");
        const updateTask = db.prepare("UPDATE tasks SET total_time_ms = total_time_ms + ? WHERE id = ?");

        db.transaction(() => {
            for (let i = 0; i < count; i++) {
                // Random day in current month
                const day = Math.floor(Math.random() * 28) + 1;
                // Random duration 15m to 4h
                const durationMs = (Math.floor(Math.random() * 240) + 15) * 60 * 1000; 
                
                const start = new Date(now.getFullYear(), now.getMonth(), day, 9 + Math.floor(Math.random()*8), 0, 0);
                const end = new Date(start.getTime() + durationMs);

                insertLog.run(taskId, start.toISOString(), end.toISOString(), 3, "Auto-generated test log");
                updateTask.run(durationMs, taskId);
            }
        })();
        
        res.json({ success: true, message: `Generated ${count} logs` });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});
// 4. HISTORY WITH FILTERING
// Objective: Retrieve task logs with optional date range filtering for calendar view.
// GET: History with Range Filtering
app.get("/api/history", (req, res) => {
    const { start, end } = req.query;
    let sql = `SELECT l.*, t.title as task_title, t.color_hex FROM time_logs l JOIN tasks t ON l.task_id = t.id WHERE l.end_time IS NOT NULL`;
    const params = [];
    if (start && end) {
        sql += ` AND l.start_time >= ? AND l.start_time <= ?`;
        params.push(start, end);
    }
    sql += ` ORDER BY l.start_time DESC LIMIT 100`;
    res.json(db.prepare(sql).all(...params));
});

// --- END OF API ROUTES ---


app.post("/api/dev/init-test", (req, res) => {
    try {
        const now = new Date();
        const title = `TEST PROTOCOL ${now.getHours()}${now.getMinutes()}`;
        
        // 1. Create the Task
        const taskInfo = db.prepare("INSERT INTO tasks (title, created_at, color_hex, is_done) VALUES (?, ?, ?, 0)").run(title, now.getTime(), "#ef4444");
        const taskId = taskInfo.lastInsertRowid;
        
        let totalDuration = 0;
        const insertLog = db.prepare("INSERT INTO time_logs (task_id, start_time, end_time, rating, manual_note) VALUES (?, ?, ?, ?, ?)");
        
        // 2. Generate 15 logs spread over the current month
        db.transaction(() => {
            for (let i = 1; i <= 15; i++) {
                // Random day, random time
                const day = (i % 28) + 1; 
                const start = new Date(now.getFullYear(), now.getMonth(), day, 8 + (i%10), 0, 0);
                const durationMinutes = 30 + (i * 10); // 40m, 50m, etc.
                const end = new Date(start.getTime() + (durationMinutes * 60000));
                
                insertLog.run(taskId, start.toISOString(), end.toISOString(), 3, `Auto-gen log ${i}`);
                totalDuration += (durationMinutes * 60000);
            }
            // 3. Update Task Total
            db.prepare("UPDATE tasks SET total_time_ms = ? WHERE id = ?").run(totalDuration, taskId);
        })();

        res.json({ success: true, message: "Test Data Injected" });
    } catch (e) {
        res.status(500).json({ error: e.message });
    }
});
// Start Server
app.listen(PORT, "127.0.0.1", () => {
    console.log(`COGNICANVAS_BACKEND_READY on port ${PORT}`);
    // dbService.init(USER_DATA_PATH); // Ignored as per Q4 instruction
});
```

```js
// backend\services\db-service.js
// backend/services/db-service.js
const Datastore = require('nedb-promises');
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');
// REMOVED: const { app } = require('electron'); // This caused the crash

// CONSTANTS
const MASTER_PASSWORD = 'this-should-be-securely-obtained-from-user';
const SALT = 'nas-m-cryptor-static-salt';

class DatabaseService {
  constructor() {
    this.db = null;
    this.masterKey = null;
    this.dbPath = null; // Path will be set in init()
  }

  // Initialize: Derived key + Load DB. 
  // userDataPath is passed from server.js (who got it from main.js)
  async init(userDataPath) {
    if (!userDataPath) throw new Error("DatabaseService initialized without path");
    
    this.dbPath = path.join(userDataPath, 'secure.db');
    this.masterKey = crypto.pbkdf2Sync(MASTER_PASSWORD, SALT, 100000, 32, 'sha512');
    await this._load();
  }

  async _load() {
    try {
      const encryptedData = await fs.readFile(this.dbPath);
      const iv = encryptedData.slice(0, 16);
      const authTag = encryptedData.slice(16, 32);
      const ciphertext = encryptedData.slice(32);

      const decipher = crypto.createDecipheriv('aes-256-gcm', this.masterKey, iv);
      decipher.setAuthTag(authTag);
      
      const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
      
      this.db = Datastore.create({ inMemoryOnly: true });
      await this.db.loadDatabase();
      const docs = JSON.parse(decrypted.toString('utf-8'));
      await this.db.insert(docs);
      console.log("Secure DB loaded successfully.");

    } catch (error) {
      console.log("Creating new Secure DB at", this.dbPath);
      this.db = Datastore.create({ inMemoryOnly: true });
    }
  }

  async _persist() {
    if (!this.db) return;
    const docs = await this.db.find({});
    const data = JSON.stringify(docs);
    
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-gcm', this.masterKey, iv);
    
    const encrypted = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()]);
    const authTag = cipher.getAuthTag();

    await fs.writeFile(this.dbPath, Buffer.concat([iv, authTag, encrypted]));
  }

  async getKeys() { return this.db ? this.db.find({ type: 'key' }) : []; }
  
  async saveKey(key) {
    if (!this.db) return null;
    const result = await this.db.update({ _id: key._id }, { ...key, type: 'key' }, { upsert: true });
    await this._persist();
    return result;
  }
  
  async deleteKey(keyId) {
    if (!this.db) return null;
    const result = await this.db.remove({ _id: keyId, type: 'key' });
    await this._persist();
    return result;
  }
  
  async getPeers() { return this.db ? this.db.find({ type: 'peer' }) : []; }
  async addPeer(peerName, seedFilePath) {
      // Stub for peer addition
      const peer = { peerName, seedFilePath, type: 'peer' };
      await this.db.insert(peer);
      await this._persist();
      return peer;
  }
}

module.exports = new DatabaseService();
```

```js
// backend\services\file-service.js
// electron/services/file-service.js
const fs = require('fs').promises;
const path = require('path');
const { dialog } = require('electron');
const { processBuffer } = require('./nasm-engine');

class FileService {
  async encryptFile(filePath, keyConfig, intensity, savePath = null, onProgress = () => {}, onNotify = () => {}) {
    try {
      onProgress(0);
      onNotify({ title: 'Encryption', body: `Reading file ${path.basename(filePath)}...` });
      const sourceBuffer = await fs.readFile(filePath);

      onNotify({ title: 'Encryption', body: `Encrypting... This may take a while.` });
      const encryptedBuffer = processBuffer(sourceBuffer, keyConfig, intensity, (p) => onProgress(p));
      
      let finalSavePath = savePath;
      if (!finalSavePath) {
        const { canceled, filePath: chosenPath } = await dialog.showSaveDialog({
          defaultPath: `${filePath}.nasm`,
        });

        if (canceled || !chosenPath) {
          onNotify({ title: 'Cancelled', body: 'Save operation was cancelled.' });
          return { success: false, error: 'Cancelled by user.' };
        }

        finalSavePath = chosenPath;
      }

      await fs.writeFile(finalSavePath, encryptedBuffer);
      onNotify({ title: 'Success', body: `File successfully encrypted to ${path.basename(finalSavePath)}` });
      return { success: true, path: finalSavePath };

    } catch (error) {
      console.error('Encryption failed:', error);
      onNotify({ title: 'Error', body: `Encryption failed: ${error.message}` });
      return { success: false, error: error.message };
    }
  }

  async decryptFile(filePath, keyConfig, savePath = null, onProgress = () => {}, onNotify = () => {}) {
    // Similar structure to encryptFile, but calls processBuffer and suggests a decrypted filename.
    try {
      onProgress(0);
      onNotify({ title: 'Decryption', body: `Reading file ${path.basename(filePath)}...` });
      const sourceBuffer = await fs.readFile(filePath);

      onNotify({ title: 'Decryption', body: `Decrypting...` });
      const decryptedBuffer = processBuffer(sourceBuffer, keyConfig, 1, (p) => onProgress(p)); // Intensity is 1 for decryption

      const originalName = filePath.endsWith('.nasm') ? filePath.slice(0, -5) : `${filePath}.decrypted`;
      let finalSavePath = savePath;
      if (!finalSavePath) {
        const { canceled, filePath: chosenPath } = await dialog.showSaveDialog({
          defaultPath: originalName,
        });

        if (canceled || !chosenPath) {
          onNotify({ title: 'Cancelled', body: 'Save operation was cancelled.' });
          return { success: false, error: 'Cancelled by user.' };
        }

        finalSavePath = chosenPath;
      }

      await fs.writeFile(finalSavePath, decryptedBuffer);
      onNotify({ title: 'Success', body: `File successfully decrypted to ${path.basename(finalSavePath)}` });
      return { success: true, path: finalSavePath };

    } catch (error) {
      console.error('Decryption failed:', error);
      onNotify({ title: 'Error', body: `Decryption failed: ${error.message}` });
      return { success: false, error: error.message };
    }
  }
}

module.exports = new FileService();
```

```js
// backend\services\nasm-engine.js

//electron/services/nasm-engine.js
// This class encapsulates the entire state and logic of a NASMFAG sequence.
/*class NASMEngine {
  constructor(config) {
    this._config = config;
    this._cache = {}; // Memoization for performance
    this._parseOperations();
  }

  // CRITICAL: A safe replacement for eval().
  _parseOperations() {
    this._safeOps = this._config.I.map(opPair => {
      const prefix = opPair[0];
      const suffix = opPair[1];
      // In a real scenario, this would be a proper AST parser.
      // For this example, we'll handle simple arithmetic safely.
      const op = suffix.charAt(0);
      const num = parseFloat(suffix.substring(1));
      if (isNaN(num)) throw new Error(`Invalid operation: ${suffix}`);

      return (val) => {
        switch (op) {
          case '+': return val + num;
          case '-': return val - num;
          case '*': return val * num;
          case '/': return val / num;
          default: throw new Error(`Unsupported operator: ${op}`);
        }
      };
    });
  }

  // The core recursive function `f(x)`.
  _f(x) {
    if (x < 0) return 0;
    if (this._cache[x] !== undefined) return this._cache[x];

    let result;
    const { starts, d, TC, minBound, maxBound } = this._config;

    if (x < d) {
      result = starts[x];
    } else {
      let ntc = 0;
      for (let v = 0; v < x - d; v++) ntc += TC[v % TC.length];
      const opIndex = (x - d + ntc) % this._safeOps.length;
      const operation = this._safeOps[opIndex];
      result = operation(this._f(x - d));
    }

    const range = maxBound - minBound;
    if (range <= 0) return minBound;
    let bounded = Math.floor(result);
    this._cache[x] = minBound + ((bounded - minBound) % range + range) % range;
    return this._cache[x];
  }

  // Generator function to produce the keystream byte by byte, saving memory.
  *keystream(length, intensity) {
    for (let i = 0; i < length; i++) {
      let value = i;
      for (let j = 0; j < intensity; j++) {
        value = this._f(value + j * length); // Add complexity
      }
      yield value % 256; // Output a single byte
    }
  }
}
*/
// The public function that services will use.
/*function processBuffer(sourceBuffer, keyConfig, intensity, onProgress) {
  const engine = new NASMEngine(keyConfig);
  const resultBuffer = Buffer.alloc(sourceBuffer.length);
  const stream = engine.keystream(sourceBuffer.length, intensity);

  for (let i = 0; i < sourceBuffer.length; i++) {
    const keyByte = stream.next().value;
    resultBuffer[i] = sourceBuffer[i] ^ keyByte; // XOR encryption
    if (i % 4096 === 0) {
      onProgress(i / sourceBuffer.length);
    }
  }
  onProgress(1);
  return resultBuffer;
}

module.exports = { processBuffer };*/

const crypto = require('crypto');

// TABULA CHAOS: A pre-calculated non-linear substitution box.
// This replaces Math.sin/cos with a deterministic integer equivalent.
// (Generated using Math.sin(i) * 255 for values 0-255)
const TABULA_CHAOS = new Uint8Array([
   99, 124, 119, 123, 242, 107, 111, 197,  48,   1, 103,  43, 254, 215, 171, 118,
  202, 130, 201, 125, 250,  89,  71, 240, 173, 212, 162, 175, 156, 164, 114, 192,
  183, 253, 147,  38,  54,  63, 247, 204,  52, 165, 229, 241, 113, 216,  49,  21,
    4, 199,  35, 195,  24, 150,   5, 154,   7,  18, 128, 226, 235,  39, 178, 117,
    9, 131,  44,  26,  27, 110,  90, 160,  82,  59, 214, 179,  41, 227,  47, 132,
   83, 209,   0, 237,  32, 252, 177,  91, 106, 203, 190,  57,  74,  76,  88, 207,
  208, 239, 170, 251,  67,  77,  51, 133,  69, 249,   2, 127,  80,  60, 159, 168,
   81, 163,  64, 143, 146, 157,  56, 245, 188, 182, 218,  33,  16, 255, 243, 210,
  205,  12,  19, 236,  95, 151,  68,  23, 196, 167, 126,  61, 100,  93,  25, 115,
   96, 129,  79, 220,  34,  42, 144, 136,  70, 238, 184,  20, 222,  94,  11, 219,
  224,  50,  58,  10,  73,   6,  36,  92, 194, 211, 172,  98, 145, 149, 228, 121,
  231, 200,  55, 109, 141, 213,  78, 169, 108,  86, 244, 234, 101, 122, 174,   8,
  186, 120,  37,  46,  28, 166, 180, 198, 232, 221, 116,  31,  75, 189, 139, 138,
  112,  62, 181, 102,  72,   3, 246,  14,  97,  53,  87, 185, 134, 193,  29, 158,
  225, 248, 152,  17, 105, 217, 142, 148, 155,  30, 135, 233, 206,  85,  40, 223,
  140, 161, 137,  13, 191, 230,  66, 104,  65, 153,  45,  15, 176,  84, 187,  22
]);

class NASMEngineAeternitas {
  /**
   * @param {Object} constitutio - Config
   * @param {Buffer} initiumVector - IV (16 bytes)
   * @param {Number} tempus - Timestamp (Integer, e.g., Date.now())
   */
  constructor(constitutio, initiumVector, tempus) {
    this._constitutio = constitutio;
    this._memoria = Int32Array.from(constitutio.starts);
    this._caput = this._memoria.length;
    this._indexCycli = 0;

    // 1. MIX TEMPUS (Time) INTO MEMORY
    // We treat the timestamp as a "Salt" that shifts the entire state universe.
    // Use bitwise ops to ensure 32-bit integer safety.
    const tempusHigh = Math.floor(tempus / 0xFFFFFFFF) | 0;
    const tempusLow = (tempus & 0xFFFFFFFF) | 0;

    for (let i = 0; i < this._memoria.length; i++) {
      // Mix IV
      if (i < initiumVector.length) this._memoria[i] ^= initiumVector[i];
      
      // Mix Time (Mutation based on when encryption happened)
      this._memoria[i] ^= (i % 2 === 0) ? tempusLow : tempusHigh;
    }

    this._parareOperationes();
  }

  // Same robust operation parser as v3
  _parareOperationes() {
    this._operationesTutum = this._constitutio.I.map(parOp => {
      const suffix = parOp[1];
      const signum = suffix.charAt(0);
      const numerusRaw = parseFloat(suffix.substring(1));
      const numerus = Math.floor(numerusRaw) | 0; 
      return (pretium) => {
        pretium = pretium | 0;
        switch (signum) {
          case '+': return (pretium + numerus) | 0;
          case '-': return (pretium - numerus) | 0;
          case '*': return Math.imul(pretium, numerus) | 0;
          case '/': return pretium ^ numerus; // XOR is safer than division
          default: return (pretium + numerus) | 0;
        }
      };
    });
  }

  // SUBSTITUTIO: The replacement for "Math.sin"
  // Maps an integer input to a chaotic integer output using the Table
  _substitutio(val) {
    // Map value to 0-255 range
    const index = Math.abs(val) & 0xFF;
    return TABULA_CHAOS[index];
  }

  _statusProximus() {
    const { d, TC, minBound, maxBound } = this._constitutio;
    const ambitus = (maxBound - minBound) | 0;
    if (ambitus <= 0) return minBound;

    // A. FETCH HISTORY
    const indexHistoriae = (this._caput - d + this._memoria.length) % this._memoria.length;
    let pretium = this._memoria[indexHistoriae];

    // B. CYCLE MUTATION
    const valorCycli = TC[this._indexCycli % TC.length];
    this._indexCycli++;

    // C. OPERATION SELECTION
    const indexOp = Math.abs((this._caput + pretium + valorCycli)) % this._operationesTutum.length;
    pretium = this._operationesTutum[indexOp](pretium);

    // --- NEW: NON-LINEAR CHAOS LAYER (Replaces Sin/Cos/Log) ---
    // Instead of linear math, we substitute the value through the S-Box.
    // This destroys linear relationships (solving x + y = z).
    const chaos = this._substitutio(pretium);
    
    // Mix the chaos back into the price using XOR and Rotation
    pretium = (pretium ^ chaos) | 0;
    pretium = (pretium << 7) | (pretium >>> 25); // Rotate Left 7
    // -----------------------------------------------------------

    // D. FEEDBACK (CBC)
    const indexPrev = (this._caput - 1 + this._memoria.length) % this._memoria.length;
    pretium ^= this._memoria[indexPrev];

    // E. BOUND
    const result = minBound + (Math.abs(pretium) % ambitus);
    
    // F. STORE
    this._memoria[this._caput % this._memoria.length] = result;
    this._caput++;

    return result;
  }

  *keystream(len, intensity) {
    for (let i = 0; i < len; i++) {
      let val = 0;
      const rounds = intensity > 0 ? intensity : 1;
      for (let j = 0; j < rounds; j++) val = this._statusProximus();
      yield val & 0xFF;
    }
  }
}

// ---------------------------------------------------------
// PUBLIC API (Updated for Timestamp)
// ---------------------------------------------------------

/**
 * Output Structure:
 * [0-15]  : IV (16 bytes)
 * [16-23] : Tempus (8 bytes / 64-bit Timestamp)
 * [24...] : Encrypted Data
 */
function processBuffer(sourceBuffer, keyConfig, intensity, onProgress) {
  const initiumVector = crypto.randomBytes(16);
  
  // 1. CAPTURE TIME
  const tempus = Date.now(); // Milliseconds since epoch
  
  // Alloc: Source + 16 (IV) + 8 (Time)
  const receptaculum = Buffer.alloc(sourceBuffer.length + 16 + 8);
  
  initiumVector.copy(receptaculum, 0);
  
  // 2. WRITE TIME TO HEADER (Big Int 64-bit)
  receptaculum.writeBigInt64LE(BigInt(tempus), 16);

  const machina = new NASMEngineAeternitas(keyConfig, initiumVector, tempus);
  const fluxus = machina.keystream(sourceBuffer.length, intensity);

  for (let i = 0; i < sourceBuffer.length; i++) {
    receptaculum[i + 24] = sourceBuffer[i] ^ fluxus.next().value;
    if (onProgress && i % 4096 === 0) onProgress(i / sourceBuffer.length);
  }

  if (onProgress) onProgress(1);
  return receptaculum;
}

function restoreBuffer(cipherBuffer, keyConfig, intensity, onProgress) {
  if (cipherBuffer.length < 24) throw new Error("Fractus Data: Header missing.");

  const initiumVector = cipherBuffer.slice(0, 16);
  
  // 1. READ TIME FROM HEADER
  const tempusBig = cipherBuffer.readBigInt64LE(16);
  const tempus = Number(tempusBig); // Convert back to number for Engine

  const dataVera = cipherBuffer.slice(24);
  const receptaculum = Buffer.alloc(dataVera.length);
  
  const machina = new NASMEngineAeternitas(keyConfig, initiumVector, tempus);
  const fluxus = machina.keystream(dataVera.length, intensity);

  for (let i = 0; i < dataVera.length; i++) {
    receptaculum[i] = dataVera[i] ^ fluxus.next().value;
    if (onProgress && i % 4096 === 0) onProgress(i / dataVera.length);
  }

  if (onProgress) onProgress(1);
  return receptaculum;
}

module.exports = { processBuffer, restoreBuffer };
// ---------------------------------------------------------
```

```js
// backend\services\p2p-service.js
// electron/services/p2p-service.js
const crypto = require('crypto');
const fs = require('fs').promises;
// const DHT = require('dht-rpc'); // Hypothetical library
// const portKnock = require('port-knocking'); // Hypothetical library
const { dbService } = require('./db-service');
//const dbService = require('./db-service'); // Corrected from { dbService }

class P2PService {
  constructor() {
    // this.dht = new DHT(); // Initialize the DHT client
  }

  async createGenesisSeed(peerName) {
    const seed = crypto.randomBytes(256);
    const savePath = dialog.showSaveDialogSync({ defaultPath: `${peerName}-seed.nasmkey` });
    if (savePath) {
      await fs.writeFile(savePath, seed);
      return savePath;
    }
    return null;
  }

  // Derives the rendezvous strategy for the current time window.
  _getStrategy(seed) {
    const timeWindow = Math.floor(Date.now() / 10000); // 10-second window
    const hmac = crypto.createHmac('sha256', seed);
    hmac.update(String(timeWindow));
    const digest = hmac.digest();

    return {
      mailbox: digest.slice(0, 20), // 20-byte ID for DHT
      knockSequence: [digest.readUInt16BE(20), digest.readUInt16BE(22)],
      handshakeKey: digest.slice(24, 32),
    };
  }

  async sendFile(peerId, filePath, onProgress, onNotify) {
    onNotify({ title: 'P2P', body: `Preparing to send to peer ${peerId}...` });
    const peer = await dbService.getPeerById(peerId);
    if (!peer) throw new Error('Peer not found.');

    const strategy = this._getStrategy(peer.genesisSeed);

    // 1. Announce presence on the DHT
    // const myIp = await getPublicIp();
    // this.dht.put(strategy.mailbox, Buffer.from(myIp));

    // 2. Listen for their IP and initiate port knock.
    // ... complex logic for listening and knocking ...

    onNotify({ title: 'P2P', body: `Connection established. Sending file...` });
    // 3. Once connected, stream the file.
  }
}

module.exports = new P2PService();
```

```js
// backend\services\system-service.js
// backend/services/system-service.js
const { exec, spawn } = require('child_process');
const path = require('path');
const os = require('os');

class SystemService {
  
  // Open a URL or File using the default OS handler
  async openExternal(target) {
    const platform = os.platform();
    let command;
    
    // NORMALIZE PATH: Fix mixed slashes for Windows
    const safeTarget = path.normalize(target);

    if (platform === 'win32') {
      // WINDOWS FIX: 
      // 1. "start" needs a dummy title argument ("") before the path.
      // 2. We wrap the path in quotes to handle spaces.
      command = `start "" "${safeTarget}"`;
    } else if (platform === 'darwin') {
      command = `open "${safeTarget}"`;
    } else {
      command = `xdg-open "${safeTarget}"`;
    }

    console.log(`[System] Executing: ${command}`); // Debug log

    return new Promise((resolve) => {
      exec(command, (error) => {
        if (error) {
            console.error(`[System] Exec error: ${error.message}`);
            resolve({ success: false, error: error.message });
        } else {
            resolve({ success: true });
        }
      });
    });
  }

  // Execute a specific command (e.g., Run a Python script for MPSI)
  async runCommand(command, args = []) {
    return new Promise((resolve, reject) => {
      const process = spawn(command, args, { shell: true });
      
      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => stdout += data.toString());
      process.stderr.on('data', (data) => stderr += data.toString());

      process.on('close', (code) => {
        resolve({ 
            success: code === 0, 
            output: stdout, 
            error: stderr,
            code 
        });
      });
    });
  }
}

module.exports = new SystemService();
```

```js
// electron\ipc-handlers.js
// electron/ipc-handlers.js
const { ipcMain, dialog } = require('electron');
const { IPC_CHANNELS } = require('../shared/constants');
const fileService = require('../backend/services/file-service');
const dbService = require('../backend/services/db-service');
const p2pService = require('../backend/services/p2p-service');

function setupIpcHandlers(mainWindow) {
  const notify = (message) => mainWindow.webContents.send(IPC_CHANNELS.NOTIFY_USER, message);
  const progress = (percent) => mainWindow.webContents.send(IPC_CHANNELS.NOTIFY_PROGRESS, percent);

  // File System
  ipcMain.handle(IPC_CHANNELS.FILE_SELECT, async () => {
    const { canceled, filePaths } = await dialog.showOpenDialog();
    return canceled ? null : filePaths[0];
  });
  ipcMain.handle(IPC_CHANNELS.FILE_ENCRYPT, (evt, fp, key, intensity) => fileService.encryptFile(fp, key, intensity, progress, notify));
  ipcMain.handle(IPC_CHANNELS.FILE_DECRYPT, (evt, fp, key) => fileService.decryptFile(fp, key, progress, notify));

  // Keys
  ipcMain.handle(IPC_CHANNELS.DB_GET_KEYS, () => dbService.getKeys());
  ipcMain.handle(IPC_CHANNELS.DB_SAVE_KEY, (evt, key) => dbService.saveKey(key));
  ipcMain.handle(IPC_CHANNELS.DB_DELETE_KEY, (evt, id) => dbService.deleteKey(id));
  
  // Peers & P2P
  ipcMain.handle(IPC_CHANNELS.DB_GET_PEERS, () => dbService.getPeers());
  ipcMain.handle(IPC_CHANNELS.P2P_CREATE_SEED, (evt, name) => p2pService.createGenesisSeed(name));
  ipcMain.handle(IPC_CHANNELS.DB_ADD_PEER, (evt, name, path) => dbService.addPeer(name, path));
  ipcMain.handle(IPC_CHANNELS.P2P_SEND_FILE, (evt, peerId, fp) => p2pService.sendFile(peerId, fp, progress, notify));
}

module.exports = { setupIpcHandlers };
```

```js
// electron\main.js
// electron/main.js
const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const path = require('path');
const { spawn } = require('child_process');
const crypto = require('crypto');
// Remove the dbService import from here to prevent "app.getPath is not a function" errors
// We let the backend handle the DB entirely.

const SECRET_TOKEN = crypto.randomBytes(32).toString('hex');
let backendProcess = null;

function createWindow() {
  const mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  if (app.isPackaged) {
    mainWindow.loadFile(path.join(__dirname, '../frontend/dist/index.html'));
  } else {
    mainWindow.loadURL('http://localhost:5173');
    mainWindow.webContents.openDevTools();
  }
  return mainWindow;
}

function startBackend() {
  const backendPath = path.join(__dirname, '../backend/server.js');
  const userDataPath = app.getPath('userData');

  // FIXED: Use process.execPath (Electron) instead of 'node'
  // FIXED: Add ELECTRON_RUN_AS_NODE environment variable
  backendProcess = spawn(process.execPath, [backendPath, SECRET_TOKEN, userDataPath], {
    cwd: path.join(__dirname, '../backend'), 
    env: { 
      ...process.env, 
      ELECTRON_RUN_AS_NODE: '1' 
    },
    stdio: 'inherit'
  });

  backendProcess.on('error', (err) => {
    console.error('Failed to start backend process:', err);
  });
}
app.whenReady().then(async () => {
  startBackend();
  const mainWindow = createWindow();

  ipcMain.handle('get-secret-token', (event) => {
    if (event.sender === mainWindow.webContents) return SECRET_TOKEN;
    return null;
  });
  
  ipcMain.handle('dialog:open-file', async () => {
    const { canceled, filePaths } = await dialog.showOpenDialog();
    return canceled ? null : filePaths[0];
  });

  ipcMain.handle('dialog:save-file', async (event, options) => {
    const { canceled, filePath } = await dialog.showSaveDialog(options);
    return canceled ? null : filePath;
  });

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

app.on('quit', () => {
  if (backendProcess) backendProcess.kill();
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});
```

```js
// electron\preload.js
const { contextBridge, ipcRenderer } = require('electron');

// We define constants here to avoid "module not found" errors with relative paths during dev
const IPC_CHANNELS = {
  // File operations
  FILE_SELECT: 'file:select',
  FILE_ENCRYPT: 'file:encrypt',
  FILE_DECRYPT: 'file:decrypt',
  // Database
  DB_GET_KEYS: 'db:get-keys',
  DB_SAVE_KEY: 'db:save-key',
  DB_DELETE_KEY: 'db:delete-key',
  DB_GET_PEERS: 'db:get-peers',
  DB_ADD_PEER: 'db:add-peer',
  // P2P
  P2P_CREATE_SEED: 'p2p:create-seed',
  P2P_SEND_FILE: 'p2p:send-file',
  // Notifications
  NOTIFY_USER: 'notify:user',
  NOTIFY_PROGRESS: 'notify:progress',
};

contextBridge.exposeInMainWorld('nativeAPI', {
  // Security
  getSecretToken: () => ipcRenderer.invoke('get-secret-token'),
  
  // Dialogs
  selectFile: () => ipcRenderer.invoke('dialog:open-file'),
  showSaveDialog: (options) => ipcRenderer.invoke('dialog:save-file', options),

  // Events
  onProgress: (callback) => ipcRenderer.on(IPC_CHANNELS.NOTIFY_PROGRESS, (_event, value) => callback(value)),
  onNotification: (callback) => ipcRenderer.on(IPC_CHANNELS.NOTIFY_USER, (_event, value) => callback(value)),
  removeAllListeners: (channel) => ipcRenderer.removeAllListeners(channel),
});
```

```text
// frontend\.gitignore
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
```

```js
// frontend\eslint.config.js
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]
```

```html
// frontend\index.html
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  
  <meta http-equiv="Content-Security-Policy" 
  content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self' ws://localhost:5173 http://localhost:4000">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Vite + React + Electron Template</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.jsx"></script>
</body>

</html>
```

```json
// frontend\package.json
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/postcss": "^4.1.10",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-draggable": "^4.4.6",
    "react-resizable": "^3.0.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.17.0",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "postcss": "^8.5.5",
    "tailwindcss": "^4.1.10",
    "vite": "^6.0.5"
  }
}
```

```js
// frontend\postcss.config.js
export default {
  plugins: {
    "@tailwindcss/postcss": {},
  }
}
```

```js
// frontend\tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

```js
// frontend\vite.config.js
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  base: "./", // Ensures correct file paths in production
  plugins: [react()],
  build: {
    outDir: "dist",
    emptyOutDir: true,
  },
});
```

```js
// frontend\src\api.js
// frontend/src/api.js
const API_URL = 'http://localhost:4000/api';
let SECRET_TOKEN = null;

export async function initializeApi() {
  if (window.nativeAPI) {
    SECRET_TOKEN = await window.nativeAPI.getSecretToken();
  } else {
    console.warn("nativeAPI not found. Running in browser mode or preload failed.");
  }
}

export async function apiFetch(endpoint, options = {}) {
  if (!SECRET_TOKEN) await initializeApi();
  
  // Fallback for development if token is still missing
  const headers = {
    'Content-Type': 'application/json',
    ...(SECRET_TOKEN ? { 'Authorization': `Bearer ${SECRET_TOKEN}` } : {}),
    ...options.headers,
  };

  const response = await fetch(`${API_URL}${endpoint}`, { ...options, headers });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
  }
  return response.json();
}

// --- TASKS CORE ---



// Actions
// Updated toggleTask to accept body (for manual_note on stop)
export const toggleTask = (id, action, body = {}) => 
    apiFetch(`/tasks/${id}/${action}`, { 
        method: 'POST', 
        body: JSON.stringify(body) 
    });

export const terminateTask = (id) => updateTask(id, { is_done: 1 }); // Soft Delete
export const reviveTask = (id) => updateTask(id, { is_done: 0 }); // Undo Soft Delete


// Query specific range for Calendar
export const getLogsByRange = (startStr, endStr) => apiFetch(`/tasks/logs?view=range&start=${startStr}&end=${endStr}`);

// --- TAGS & SYSTEM ---
export const getTags = () => apiFetch('/tags');
export const addTagToTask = (taskId, tagName) => apiFetch(`/tags/tasks/${taskId}`, { method: 'POST', body: JSON.stringify({ name: tagName }) });
export const removeTagFromTask = (taskId, tagName) => apiFetch(`/tasks/${taskId}/tags/${tagName}`, { method: 'DELETE' });

// --- UTILS ---
export const selectFile = () => window.nativeAPI ? window.nativeAPI.selectFile() : null;
// Add these to frontend/src/api.js for completeness, even if not used in TaskWidget.jsx
// Update getHistory to handle optional range for lazy loading
// Utility to update log notes after session is over
export const updateLog = (logId, details) => 
    apiFetch(`/history/${logId}`, { method: 'PUT', body: JSON.stringify(details) });

export const getTasks = () => apiFetch('/all');
export const getActiveSession = () => apiFetch('/tasks/active-session');
export const getHistory = (start, end) => {
    const q = (start && end) ? `?start=${start}&end=${end}` : '';
    return apiFetch(`/history${q}`);
};
// frontend/src/api.js
export const deleteLog = (logId) => apiFetch(`/history/${logId}`, { method: 'DELETE' });
export const createTask = (title) => apiFetch('/tasks', { method: 'POST', body: JSON.stringify({ title }) });
export const startTask = (id) => apiFetch(`/tasks/${id}/start`, { method: 'POST' });
export const stopTask = (id, body) => apiFetch(`/tasks/${id}/stop`, { method: 'POST', body: JSON.stringify(body) });
export const updateTask = (id, data) => apiFetch(`/tasks/${id}`, { method: 'PUT', body: JSON.stringify(data) });
export const deleteTask = (id) => apiFetch(`/tasks/${id}`, { method: 'DELETE' });
```

```jsx
// frontend\src\App.jsx
import React, { useState, useEffect } from "react";
import { initializeApi } from "./api";
import Canvas from "./components/Canvas";
import WindowFrame from "./components/WindowFrame";
import CryptoApp from "./apps/CryptoApp";
import TasksApp from "./apps/TasksApp";
import HDWindowFrame from "./components/HDWindowFrame";
import ShortcutWidget from "./components/ShortcutWidget";
import SettingsApp from "./apps/SettingsApp";
import CommandPalette from "./components/CommandPalette";

function App() {
    const [openApps, setOpenApps] = useState([]);
    const [isReady, setIsReady] = useState(false);
    const [searchQuery, setSearchQuery] = useState("");
    const [activeFilters, setActiveFilters] = useState([]);
    const [availableTags, setAvailableTags] = useState([]);

    // Settings & Theme
    const [shortcuts, setShortcuts] = useState([]);
    const [theme, setTheme] = useState({ canvas_bg: "#242424" });
    const [isPaletteOpen, setIsPaletteOpen] = useState(false);

    // --- INITIALIZATION ---
    const fetchTags = async () => {
        try {
            const token = await window.nativeAPI.getSecretToken();
            const res = await fetch("http://localhost:4000/api/all", { headers: { Authorization: `Bearer ${token}` } });
            const data = await res.json();
            const tags = new Set();
            data.notes.forEach((n) => n.tags.forEach((t) => tags.add(t.name)));
            setAvailableTags(Array.from(tags));
        } catch (e) {
            console.error("Tag fetch error", e);
        }
    };

    const refreshConfig = async () => {
        const token = await window.nativeAPI.getSecretToken();
        // Load Shortcuts
        const sRes = await fetch("http://localhost:4000/api/shortcuts", { headers: { Authorization: `Bearer ${token}` } });
        setShortcuts(await sRes.json());
        // Load Settings
        const tRes = await fetch("http://localhost:4000/api/settings", { headers: { Authorization: `Bearer ${token}` } });
        const tData = await tRes.json();
        if (tData.canvas_bg) setTheme({ canvas_bg: tData.canvas_bg });
    };

    useEffect(() => {
        initializeApi().then(() => {
            setIsReady(true);
            fetchTags();
            refreshConfig();
        });

        // Event Listeners
        const handleToggleApp = (e) => toggleApp(e.detail);
        window.addEventListener("cognicanvas:data-updated", fetchTags);
        window.addEventListener("cognicanvas:config-updated", refreshConfig);
        window.addEventListener("cognicanvas:toggle-app", handleToggleApp);

        // Command Palette Shortcut
        const handleKeyDown = (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === "k") {
                e.preventDefault();
                setIsPaletteOpen((prev) => !prev);
            }
        };
        window.addEventListener("keydown", handleKeyDown);

        return () => {
            window.removeEventListener("cognicanvas:data-updated", fetchTags);
            window.removeEventListener("cognicanvas:config-updated", refreshConfig);
            window.removeEventListener("cognicanvas:toggle-app", handleToggleApp);
            window.removeEventListener("keydown", handleKeyDown);
        };
    }, []);

    const toggleApp = (appName) => {
        setOpenApps((prev) => (prev.includes(appName) ? prev.filter((a) => a !== appName) : [...prev, appName]));
    };

    const toggleFilter = (tagName) => {
        setActiveFilters((prev) => (prev.includes(tagName) ? prev.filter((t) => t !== tagName) : [...prev, tagName]));
    };

    const triggerAddFrame = () => {
        window.dispatchEvent(new CustomEvent("cognicanvas:add-frame"));
    };

    if (!isReady) return <div className="bg-[#1a1a1a] h-screen text-yellow-500 flex items-center justify-center font-mono">SYSTEM_BOOT...</div>;

    return (
        <div className="flex h-screen w-screen overflow-hidden bg-[#111] text-gray-100 font-sans select-none">
            {/* COMMAND PALETTE */}
            <CommandPalette isOpen={isPaletteOpen} onClose={() => setIsPaletteOpen(false)} />

            {/* SIDEBAR DOCK */}
            <nav className="w-16 bg-black flex flex-col items-center py-4 space-y-4 z-[100] border-r border-white/10">
                <div className="w-10 h-10 bg-yellow-400 rounded-lg flex items-center justify-center font-black text-black text-xl mb-4">C</div>
                <DockIcon label="Cryptor" active={openApps.includes("crypto")} onClick={() => toggleApp("crypto")}>
                    ðŸ”’
                </DockIcon>
                <DockIcon label="Tasks" active={openApps.includes("tasks")} onClick={() => toggleApp("tasks")}>
                    âœ…
                </DockIcon>
                <div className="flex-1" />
                <DockIcon label="Settings" active={openApps.includes("settings")} onClick={() => toggleApp("settings")}>
                    âš™ï¸
                </DockIcon>
            </nav>

            <div className="flex-1 flex flex-col relative">
                {/* HEADER */}
                <header className="h-14 bg-[#f8f9fa] border-b border-gray-300 flex items-center px-4 space-x-4 z-40 shadow-sm text-gray-800">
                    <button onClick={triggerAddFrame} className="bg-[#4285f4] text-white px-4 py-1.5 rounded-md text-sm font-bold hover:shadow-md active:scale-95 transition-all whitespace-nowrap">
                        + Frame
                    </button>

                    <div className="w-64 relative">
                        <input type="text" placeholder="Search content..." className="w-full bg-[#e9ecef] border-none rounded-lg px-4 py-2 text-sm outline-none focus:ring-2 focus:ring-blue-400 text-gray-700" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} />
                        <div className="absolute right-2 top-2 text-xs text-gray-400">Ctrl+K</div>
                    </div>

                    <div className="h-8 w-px bg-gray-300 mx-2"></div>

                    {/* Tag Filter */}
                    <div className="flex-1 flex items-center space-x-2 overflow-hidden">
                        <span className="text-xs font-bold text-gray-400 uppercase tracking-wide">Tags:</span>
                        <select
                            className="bg-white border border-gray-300 text-gray-700 text-xs rounded p-1 outline-none focus:border-blue-500"
                            onChange={(e) => {
                                if (e.target.value) {
                                    toggleFilter(e.target.value);
                                    e.target.value = "";
                                }
                            }}
                        >
                            <option value="">+ Add Filter</option>
                            {availableTags.map((tag) => (
                                <option key={tag} value={tag}>
                                    {tag}
                                </option>
                            ))}
                        </select>
                        <div className="flex items-center space-x-2 overflow-x-auto no-scrollbar">
                            {activeFilters.map((tag) => (
                                <div key={tag} className="px-2 py-1 bg-blue-100 text-blue-800 border border-blue-200 rounded-md text-xs font-bold flex items-center whitespace-nowrap">
                                    {tag}{" "}
                                    <button className="ml-1 text-blue-400 hover:text-blue-900" onClick={() => toggleFilter(tag)}>
                                        Ã—
                                    </button>
                                </div>
                            ))}
                        </div>
                        {activeFilters.length > 0 && (
                            <button onClick={() => setActiveFilters([])} className="text-xs text-red-500 hover:text-red-700 underline font-bold whitespace-nowrap">
                                Clear
                            </button>
                        )}
                    </div>
                </header>

                <div className="flex-1 relative z-10">
                    <Canvas searchQuery={searchQuery} activeFilters={activeFilters} showTasks={openApps.includes("tasks")} bgColor={theme.canvas_bg} />

                    {/* DESKTOP SHORTCUTS */}
                    <div className="absolute top-4 left-4 z-20 flex flex-col space-y-2 pointer-events-none">
                        {shortcuts.map((s) => (
                            <ShortcutWidget key={s.id} shortcut={s} />
                        ))}
                    </div>

                    {/* APP WINDOWS LAYER */}
                    <div className="absolute inset-0 z-50 pointer-events-none">
                        {/* TASKS APP WINDOW */}
                        {openApps.includes("tasks") && (
                            <div className="pointer-events-auto">
                                <HDWindowFrame title="Task Manager" onDelete={() => toggleApp("tasks")} onClose={() => toggleApp("tasks")} initialPos={{ x: 50, y: 50 }} initialSize={{ width: 500, height: 700 }}>
                                    <TasksApp />
                                </HDWindowFrame>
                            </div>
                        )}

                        {/* CRYPTO APP WINDOW */}
                        {openApps.includes("crypto") && (
                            <div className="pointer-events-auto">
                                <WindowFrame title="NASM Cryptor 2.0" onClose={() => toggleApp("crypto")} width={600} initialPos={{ x: 150, y: 150 }}>
                                    <CryptoApp />
                                </WindowFrame>
                            </div>
                        )}

                        {/* SETTINGS APP WINDOW */}
                        {openApps.includes("settings") && (
                            <div className="pointer-events-auto">
                                <WindowFrame title="System Settings" onClose={() => toggleApp("settings")} width={600} initialPos={{ x: 200, y: 200 }}>
                                    <SettingsApp />
                                </WindowFrame>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
}

const DockIcon = ({ children, label, onClick, active }) => (
    <button
        onClick={onClick}
        className={`w-10 h-10 rounded-xl flex items-center justify-center text-xl transition-all group relative
      ${active ? "bg-blue-600 text-white shadow-lg" : "bg-white/5 text-gray-500 hover:bg-white/10 hover:text-white"}
    `}
    >
        {children}
        <span className="absolute left-14 bg-black text-white text-[10px] font-bold px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none z-[110]">{label.toUpperCase()}</span>
    </button>
);

export default App;
```

```css
// frontend\src\index.css
@import "tailwindcss";

/* 
  STEP 2 (Optional but Recommended): This restores the dark background and light text
  from the original template, but in a non-conflicting way.
*/
body {
    background-color: #242424;
    color: rgba(255, 255, 255, 0.87);
}

/* 
  STEP 3: This is our custom CSS to create the placeholder effect for the
  editable divs on our notes.
*/
[contentEditable="true"]:empty::before {
    content: attr(data-placeholder);
    pointer-events: none; /* Lets you click "through" the placeholder */
    color: #6b7280; /* A slightly darker gray for better contrast on yellow */
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #242424; /* Fallback */
  overflow: hidden; /* Prevent native scrollbars, canvas handles panning */
}

/* --- AXIS 1: Visual States --- */

/* State: Note is being dragged */
.note-dragging {
  cursor: grabbing !important;
  opacity: 0.85;
  transition: opacity 0.2s ease;
  z-index: 9999 !important; /* Lift above everything else */
}

/* State: Note is in edit mode */
.note-editing {
  cursor: text !important;
  box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.6); /* Blue highlight ring */
  z-index: 50 !important;
}

/* Prevent text cursor flickering during drag on non-editable areas */
.no-drag-cursor {
  user-select: none;
}
/* --- Add this for the resize handle --- */
.react-resizable-handle {
    display: block;
    position: absolute;
    width: 20px;
    height: 20px;
    background-repeat: no-repeat;
    background-origin: content-box;
    background-position: bottom right;
    padding: 0 4px 4px 0;
    box-sizing: border-box;
    background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2IDYiIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmYwMCIgeD0iMHB4IiB5PSIwcHgiIGZpbGw9ImJsYWNrIj48ZyBvcGFjaXR5PSIwLjMwMiI+PHBhdGggZD0iTTQgNiA2IDYgNiA0IEwgNCA2IFoiIGZpbGw9ImJsYWNrIi8+PC9nPjwvc3ZnPg==");
    cursor: se-resize;
}
.react-resizable-handle:hover {
    background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMDAwL3N2ZyIgdmlld0JveD0iMCAwIDYgNiIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6I2ZmZmZmZjAwIiB4PSIwcHgiIHk9IjBweCIgZmlsbD0iYmxhY2siPjxnIG9wYWNpdHk9IjAuNSI+PHBhdGggZD0iTTQgNiA2IDYgNiA0IEwgNCA2IFoiIGZpbGw9ImJsYWNrIi8+PC9nPjwvc3ZnPg==");
}
.react-resizable-handle-sw {
    bottom: 0;
    left: 0;
    cursor: sw-resize;
    transform: rotate(90deg);
}
.react-resizable-handle-se {
    bottom: 0;
    right: 0;
    cursor: se-resize;
}
.react-resizable-handle-nw {
    top: 0;
    left: 0;
    cursor: nw-resize;
    transform: rotate(180deg);
}
.react-resizable-handle-ne {
    top: 0;
    right: 0;
    cursor: ne-resize;
    transform: rotate(270deg);
}
.react-resizable-handle-w,
.react-resizable-handle-e {
    top: 50%;
    margin-top: -10px;
    cursor: ew-resize;
}
.react-resizable-handle-w {
    left: 0;
    transform: rotate(135deg);
}
.react-resizable-handle-e {
    right: 0;
    transform: rotate(-45deg);
}
.react-resizable-handle-n,
.react-resizable-handle-s {
    left: 50%;
    margin-left: -10px;
    cursor: ns-resize;
}
.react-resizable-handle-n {
    top: 0;
    transform: rotate(225deg);
}
```

```jsx
// frontend\src\main.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';

// THIS IS THE FIX: Import the main CSS file which contains the
// @tailwind directives. This loads all of Tailwind's utility classes.
import './index.css'; 

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

```jsx
// frontend\src\apps\CryptoApp.jsx
import React, { useState, useEffect } from 'react';

const TabButton = ({ active, label, onClick }) => (
  <button 
    onClick={onClick}
    className={`flex-1 py-2 text-sm font-bold border-b-2 transition-colors
      ${active ? 'border-blue-500 text-blue-400' : 'border-transparent text-gray-500 hover:text-gray-300'}`}
  >
    {label}
  </button>
);

const CryptoApp = () => {
  const [tab, setTab] = useState('process'); // 'process' or 'vault'
  const [keys, setKeys] = useState([]);
  
  // Process State
  const [mode, setMode] = useState('encrypt'); // 'encrypt' or 'decrypt'
  const [selectedKeyId, setSelectedKeyId] = useState('');
  const [filePath, setFilePath] = useState('');
  const [intensity, setIntensity] = useState(10);
  const [status, setStatus] = useState({ msg: '', type: '' });

  // Init
  useEffect(() => {
    fetchKeys();
  }, []);

  const fetchKeys = async () => {
    try {
        const token = await window.nativeAPI.getSecretToken();
        const res = await fetch('http://localhost:4000/api/keys', { headers: { 'Authorization': `Bearer ${token}` } });
        setKeys(await res.json());
    } catch (e) { console.error(e); }
  };

  const handleSelectFile = async () => {
    const path = await window.nativeAPI.selectFile();
    if (path) setFilePath(path);
  };

  const execute = async () => {
    if (!filePath || !selectedKeyId) {
        setStatus({ msg: 'Missing File or Key', type: 'error' });
        return;
    }
    
    setStatus({ msg: 'Processing...', type: 'info' });
    const token = await window.nativeAPI.getSecretToken();
    const keyConfig = keys.find(k => k._id === selectedKeyId);
    
    // 1. Get Save Path
    const defaultName = mode === 'encrypt' ? `${filePath}.nasm` : filePath.replace('.nasm', '.dec');
    const savePath = await window.nativeAPI.showSaveDialog({ defaultPath: defaultName });
    if (!savePath) {
        setStatus({ msg: 'Cancelled', type: 'info' });
        return;
    }

    // 2. Execute
    try {
        const endpoint = mode === 'encrypt' ? '/api/encrypt' : '/api/decrypt';
        const res = await fetch(`http://localhost:4000${endpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
            body: JSON.stringify({ filePath, keyConfig, intensity, savePath })
        });
        const data = await res.json();
        
        if (data.success) setStatus({ msg: `Done! Saved to ${savePath.split(/[/\\]/).pop()}`, type: 'success' });
        else setStatus({ msg: data.error || 'Failed', type: 'error' });
    } catch (e) {
        setStatus({ msg: e.message, type: 'error' });
    }
  };

  // --- SUB-COMPONENT: VAULT ---
  const KeyVault = () => {
      const [newKeyName, setNewKeyName] = useState("");

      const createKey = async () => {
          // Simplified Key Gen for UX
          const newKey = {
              name: newKeyName || "New Key",
              d: 2, minBound: 32, maxBound: 126,
              starts: [10, 20], I: [['a', '+1']], TC: [1, 2] // Default basic NASM config
          };
          const token = await window.nativeAPI.getSecretToken();
          await fetch('http://localhost:4000/api/keys', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
              body: JSON.stringify(newKey)
          });
          setNewKeyName("");
          fetchKeys();
      };

      const deleteKey = async (id) => {
          const token = await window.nativeAPI.getSecretToken();
          await fetch(`http://localhost:4000/api/keys/${id}`, { method: 'DELETE', headers: { 'Authorization': `Bearer ${token}` } });
          fetchKeys();
      };

      return (
          <div className="space-y-4">
              <div className="flex gap-2">
                  <input 
                    className="flex-1 bg-gray-700 border border-gray-600 rounded px-2 py-1 text-white text-sm"
                    placeholder="Key Name..." 
                    value={newKeyName} 
                    onChange={e => setNewKeyName(e.target.value)}
                  />
                  <button onClick={createKey} className="bg-blue-600 text-white px-3 py-1 rounded text-sm font-bold">Generate</button>
              </div>
              <div className="space-y-2 h-48 overflow-y-auto pr-1">
                  {keys.map(k => (
                      <div key={k._id} className="flex justify-between items-center bg-gray-800 p-2 rounded border border-gray-700">
                          <div>
                              <div className="text-white font-bold text-sm">{k.name}</div>
                              <div className="text-xs text-gray-500 font-mono">NASM-d{k.d}</div>
                          </div>
                          <button onClick={() => deleteKey(k._id)} className="text-red-400 hover:text-red-300 text-xs font-bold">DEL</button>
                      </div>
                  ))}
              </div>
          </div>
      );
  };

  return (
    <div className="bg-gray-900 text-gray-200 h-full flex flex-col">
        {/* Tabs */}
        <div className="flex border-b border-gray-700">
            <TabButton active={tab === 'process'} label="PROCESSOR" onClick={() => setTab('process')} />
            <TabButton active={tab === 'vault'} label="KEY VAULT" onClick={() => setTab('vault')} />
        </div>

        {/* Content */}
        <div className="p-4 flex-1 overflow-y-auto">
            {tab === 'vault' ? <KeyVault /> : (
                <div className="space-y-5">
                    {/* 1. Mode Select */}
                    <div className="flex bg-gray-800 rounded p-1">
                        <button 
                            onClick={() => setMode('encrypt')} 
                            className={`flex-1 py-1 rounded text-xs font-bold transition-colors ${mode === 'encrypt' ? 'bg-red-600 text-white' : 'text-gray-400 hover:text-white'}`}
                        >
                            ENCRYPT
                        </button>
                        <button 
                            onClick={() => setMode('decrypt')} 
                            className={`flex-1 py-1 rounded text-xs font-bold transition-colors ${mode === 'decrypt' ? 'bg-green-600 text-white' : 'text-gray-400 hover:text-white'}`}
                        >
                            DECRYPT
                        </button>
                    </div>

                    {/* 2. File Input */}
                    <div 
                        onClick={handleSelectFile}
                        className="border-2 border-dashed border-gray-600 rounded-lg p-6 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-800 transition-colors"
                    >
                        <div className="text-2xl mb-1">ðŸ“„</div>
                        <div className="text-sm font-bold text-gray-300 truncate">
                            {filePath ? filePath.split(/[/\\]/).pop() : "Click to select file"}
                        </div>
                        <div className="text-xs text-gray-500">{filePath || "No file selected"}</div>
                    </div>

                    {/* 3. Key Select */}
                    <div>
                        <label className="text-xs font-bold text-gray-500 uppercase">Select Key</label>
                        <select 
                            value={selectedKeyId}
                            onChange={(e) => setSelectedKeyId(e.target.value)}
                            className="w-full bg-gray-800 border border-gray-600 text-white text-sm rounded p-2 mt-1 outline-none focus:border-blue-500"
                        >
                            <option value="">-- Choose Key --</option>
                            {keys.map(k => <option key={k._id} value={k._id}>{k.name}</option>)}
                        </select>
                    </div>

                    {/* 4. Intensity (Encrypt Only) */}
                    {mode === 'encrypt' && (
                        <div>
                            <div className="flex justify-between text-xs font-bold text-gray-500 uppercase">
                                <span>Time Intensity</span>
                                <span>{intensity}x</span>
                            </div>
                            <input 
                                type="range" min="1" max="100" 
                                value={intensity} 
                                onChange={(e) => setIntensity(parseInt(e.target.value))}
                                className="w-full mt-1 accent-red-500"
                            />
                        </div>
                    )}

                    {/* 5. Action */}
                    <button 
                        onClick={execute}
                        className={`w-full py-3 rounded font-bold text-white shadow-lg transition-transform active:scale-95
                            ${mode === 'encrypt' ? 'bg-red-600 hover:bg-red-500' : 'bg-green-600 hover:bg-green-500'}`}
                    >
                        {mode === 'encrypt' ? 'LOCK FILE' : 'UNLOCK FILE'}
                    </button>

                    {/* Status */}
                    {status.msg && (
                        <div className={`text-xs text-center p-2 rounded ${status.type === 'error' ? 'bg-red-900/50 text-red-200' : 'bg-green-900/50 text-green-200'}`}>
                            {status.msg}
                        </div>
                    )}
                </div>
            )}
        </div>
    </div>
  );
};

export default CryptoApp;
```

```jsx
// frontend\src\apps\SettingsApp.jsx
import React, { useState, useEffect } from 'react';

const SettingsApp = () => {
  const [activeTab, setActiveTab] = useState('shortcuts');
  const [shortcuts, setShortcuts] = useState([]);
  const [canvasColor, setCanvasColor] = useState('#242424');

  // --- SHORTCUTS LOGIC ---
  const fetchShortcuts = async () => {
      const token = await window.nativeAPI.getSecretToken();
      const res = await fetch('http://localhost:4000/api/shortcuts', { headers: { 'Authorization': `Bearer ${token}` } });
      const data = await res.json();
      setShortcuts(data || []);
      // Trigger App to reload widgets
      window.dispatchEvent(new CustomEvent('cognicanvas:config-updated'));
  };

  const handleAddShortcut = async () => {
      // 1. Ask User for File
      const filePath = await window.nativeAPI.selectFile();
      if (!filePath) return;

      // 2. Guess Name
      const name = filePath.split(/[/\\]/).pop();

      // 3. Save to DB
      const token = await window.nativeAPI.getSecretToken();
      await fetch('http://localhost:4000/api/shortcuts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ title: name, target: filePath, type: 'file' })
      });
      fetchShortcuts();
  };

  const handleDeleteShortcut = async (id) => {
      const token = await window.nativeAPI.getSecretToken();
      await fetch(`http://localhost:4000/api/shortcuts/${id}`, { method: 'DELETE', headers: { 'Authorization': `Bearer ${token}` } });
      fetchShortcuts();
  };

  // --- THEME LOGIC ---
  const saveTheme = async (color) => {
      setCanvasColor(color);
      const token = await window.nativeAPI.getSecretToken();
      await fetch('http://localhost:4000/api/settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
          body: JSON.stringify({ key: 'canvas_bg', value: color })
      });
      window.dispatchEvent(new CustomEvent('cognicanvas:config-updated'));
  };

  useEffect(() => {
      fetchShortcuts();
      // Fetch initial theme (could be refactored into a hook)
  }, []);

  return (
    <div className="flex h-full text-gray-800">
      {/* Sidebar */}
      <div className="w-1/4 bg-gray-100 border-r p-2 space-y-1">
          <button onClick={() => setActiveTab('shortcuts')} className={`w-full text-left px-2 py-1.5 rounded text-sm font-bold ${activeTab==='shortcuts' ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-200'}`}>Shortcuts</button>
          <button onClick={() => setActiveTab('theme')} className={`w-full text-left px-2 py-1.5 rounded text-sm font-bold ${activeTab==='theme' ? 'bg-blue-100 text-blue-700' : 'hover:bg-gray-200'}`}>Theme</button>
      </div>

      {/* Content */}
      <div className="flex-1 p-4 overflow-y-auto">
          {activeTab === 'shortcuts' && (
              <div className="space-y-4">
                  <div className="flex justify-between items-center">
                      <h3 className="font-bold">System Shortcuts</h3>
                      <button onClick={handleAddShortcut} className="bg-green-600 text-white px-3 py-1 rounded text-xs font-bold hover:bg-green-500">+ Add File/Exe</button>
                  </div>
                  <div className="space-y-2">
                      {shortcuts.map(s => (
                          <div key={s.id} className="flex justify-between items-center bg-white border p-2 rounded shadow-sm">
                              <div className="truncate flex-1 pr-2">
                                  <div className="font-bold text-sm">{s.title}</div>
                                  <div className="text-xs text-gray-400 truncate" title={s.target}>{s.target}</div>
                              </div>
                              <button onClick={() => handleDeleteShortcut(s.id)} className="text-red-500 hover:bg-red-50 p-1 rounded">ðŸ—‘ï¸</button>
                          </div>
                      ))}
                  </div>
              </div>
          )}

          {activeTab === 'theme' && (
              <div className="space-y-4">
                  <h3 className="font-bold">Appearance</h3>
                  <div>
                      <label className="block text-xs font-bold text-gray-500 mb-1">CANVAS BACKGROUND</label>
                      <div className="flex gap-2">
                          {['#242424', '#1e1e1e', '#0f172a', '#312e81', '#ffffff'].map(c => (
                              <button 
                                key={c}
                                className={`w-8 h-8 rounded-full border-2 ${canvasColor === c ? 'border-blue-500 scale-110' : 'border-transparent'}`}
                                style={{ backgroundColor: c }}
                                onClick={() => saveTheme(c)}
                              />
                          ))}
                      </div>
                  </div>
              </div>
          )}
      </div>
    </div>
  );
};

export default SettingsApp;
```

```jsx
// frontend\src\apps\TasksApp copy.jsx
import React, { useState, useEffect, useRef } from "react";
import * as API from "../api";
import "../styles/calendar.css";
import { ResizableBox } from "react-resizable";

// --- HELPER: TIME FORMATTING ---
const formatDuration = (ms) => {
    if (!ms || isNaN(ms)) return "0m";
    const hrs = Math.floor(ms / 3600000);
    const mins = Math.floor((ms % 3600000) / 60000);
    return hrs > 0 ? `${hrs}h ${mins}m` : `${mins}m`;
};

const formatDate = (date) => new Date(date).toLocaleDateString(undefined, { month: "short", day: "numeric", year: "numeric" });
const formatTime = (date) => new Date(date).toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });

// --- COMPONENT: TASKS APP ---
const TasksApp = () => {
    // --- STATE ---
    const [view, setView] = useState("dashboard"); // 'dashboard', 'history', 'calendar'

    // Calendar State
    const [calendarMode, setCalendarMode] = useState("month"); // 'year', 'month', 'week', 'day'
    const [selectedDate, setSelectedDate] = useState(new Date());
    const [zoomLevel, setZoomLevel] = useState(1);

    // Data State
    const [tasks, setTasks] = useState([]);
    const [logs, setLogs] = useState([]);
    const [newTask, setNewTask] = useState("");

    // History Accordion State
    const [expandedLogId, setExpandedLogId] = useState(null);
    const [noteDraft, setNoteDraft] = useState(""); // For editing notes inline

    // --- SYNCHRONIZATION & DATA ---
    const loadData = async () => {
        try {
            const [tData, lData] = await Promise.all([API.getTasks(), API.getHistory()]);
            setTasks(tData.tasks || []);
            setLogs(lData || []);
        } catch (e) {
            console.error("Load failed", e);
        }
    };
    // [Insert inside TasksApp component, before other effects]
    const containerRef = useRef(null);

    // DOM HACK: Force-hide the parent "WindowFrame" header and background
    useEffect(() => {
        // Traverse up to find the parent 'frame' or 'window' container
        // Based on standard React-Draggable/Window structures
        const me = containerRef.current;
        if (!me) return;

        // Find the closest parent that looks like a window frame
        const parentFrame = me.closest('.react-draggable, .window-frame, [class*="Frame"]');

        if (parentFrame) {
            // 1. Hide the header (usually the first child or class 'window-header')
            const header = parentFrame.querySelector('[class*="header"], [class*="bar"]');
            if (header) {
                header.style.display = "none"; // POOF. Gone.
                header.style.pointerEvents = "none";
            }

            // 2. Remove default styling from parent to let TaskApp handle it
            parentFrame.style.background = "transparent";
            parentFrame.style.boxShadow = "none";
            parentFrame.style.border = "none";
            parentFrame.style.overflow = "visible"; // Allow our resize handles to be seen
        }
    }, []);

    useEffect(() => {
        loadData();
        // Poll for updates
        const interval = setInterval(loadData, 5000);
        // Listen for sync events from TaskWidget or other windows
        const handleRemote = () => loadData();
        window.addEventListener("cognicanvas:data-updated", handleRemote);
        return () => {
            clearInterval(interval);
            window.removeEventListener("cognicanvas:data-updated", handleRemote);
        };
    }, []);

    // Broadcast update to sync TaskWidgets immediately
    const broadcastSync = () => {
        window.dispatchEvent(new CustomEvent("cognicanvas:data-updated"));
        loadData();
    };

    // --- ACTIONS ---
    const handleCreate = async (e) => {
        e.preventDefault();
        if (!newTask.trim()) return;
        await API.createTask(newTask);
        setNewTask("");
        broadcastSync();
    };

    const handleTaskAction = async (task, action) => {
        if (action === "toggle") {
            await API.toggleTask(task.id, task.is_running ? "stop" : "start");
        } else if (action === "terminate") {
            if (confirm("Retire task?")) await API.terminateTask(task.id);
        } else if (action === "delete") {
            if (confirm("Permanently delete?")) await API.deleteTask(task.id);
        }
        broadcastSync();
    };

    const saveNote = async (logId) => {
        // Mock API call - in reality needs an update endpoint for logs
        // For now we assume we can update the task or a specific log endpoint exists
        // console.log("Saving note:", noteDraft, " for log:", logId);
        // await API.updateLog(logId, { manual_note: noteDraft });
        // broadcastSync();
        alert("Note saving requires backend update endpoint for logs. Implemented in UI.");
    };

    const goToCalendarTime = (isoString) => {
        const date = new Date(isoString);
        setSelectedDate(date);
        setCalendarMode("day");
        setView("calendar");
        // Auto scroll happens in render via ID anchor if implemented, or just view switch
    };

    // --- RENDERERS ---

    // 1. THE MODERN HEADER (Floating Pill)
    const renderHeader = () => (
        // "h-14" reserves space at top. The pill floats inside.
        <div className="absolute top-0 left-0 right-0 h-14 z-50 flex justify-center items-start pointer-events-none">
            {/* The Pill Container */}
            <div className="group pointer-events-auto mt-2 relative">
                {/* 1. The Default State (Simple Pill) */}
                <div className="bg-[#1a1a1a] border border-gray-600 rounded-full px-4 py-1.5 shadow-lg flex items-center gap-2 transition-all duration-300 group-hover:opacity-0 absolute top-0 left-1/2 -translate-x-1/2 whitespace-nowrap">
                    <span className="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></span>
                    <span className="text-[10px] font-bold text-gray-300 tracking-widest uppercase">Task Manager</span>
                </div>

                {/* 2. The Expanded State (Hover) - "Expands Up/Out" */}
                {/* We use translate to make it appear to slide up/in from the simple pill */}
                <div
                    className="bg-[#111] border border-gray-500 rounded-xl p-1.5 shadow-2xl flex items-center gap-3 
                            opacity-0 translate-y-2 scale-95
                            group-hover:opacity-100 group-hover:translate-y-0 group-hover:scale-100 
                            transition-all duration-200 ease-out origin-top"
                >
                    {/* Drag Handle (The Grip) */}
                    <div className="drag-handle cursor-move px-2 py-1 hover:bg-gray-800 rounded flex items-center gap-2 border-r border-gray-700 mr-1">
                        <span className="text-xs font-bold text-white">â‹®â‹®</span>
                        <span className="text-[10px] font-bold text-gray-400 uppercase">Grip</span>
                    </div>

                    {/* Tabs */}
                    <div className="flex bg-black rounded p-0.5 border border-gray-800">
                        {["dashboard", "history", "calendar"].map((t) => (
                            <button
                                key={t}
                                onClick={() => setView(t)}
                                className={`px-3 py-1 text-[9px] font-bold uppercase rounded transition-colors
                                ${view === t ? "bg-blue-700 text-white" : "text-gray-500 hover:text-gray-300"}
                            `}
                            >
                                {t}
                            </button>
                        ))}
                    </div>

                    {/* Close Button */}
                    <button
                        onClick={() => {
                            // Logic to close the app - if strictly a component, we hide it,
                            // or if specific API exists to remove frame:
                            if (window.nativeAPI?.closeWindow) window.nativeAPI.closeWindow();
                        }}
                        className="w-5 h-5 flex items-center justify-center rounded-full bg-red-900/50 hover:bg-red-600 text-red-200 hover:text-white transition-colors ml-2"
                    >
                        Ã—
                    </button>
                </div>
            </div>
        </div>
    );

    const renderDashboard = () => {
        // Sort: Active first, then Archived
        const activeList = tasks.filter((t) => t.is_done === 0);
        const archivedList = tasks.filter((t) => t.is_done === 1);
        const combinedList = [...activeList, ...archivedList];
        const availableTags = [...new Set(tasks.flatMap(t => t.tags))];
        const [activeMenuId, setActiveMenuId] = useState(null); // For accordion state
        // Internal state for Color Picker visibility per task
        const [colorPickerId, setColorPickerId] = useState(null);

        const NOTE_COLORS = ["#111827", "#7f1d1d", "#7c2d12", "#14532d", "#1e3a8a", "#581c87", "#422006", "#713f12", "#164e63", "#4c1d95", "#0f172a", "#831843", "#3f2500", "#4b5563", "#9d174d", "#881337", "#202020"];

        const toggleWidgetVisibility = (taskId) => {
            // Dispatch event for TaskWidget to catch
            window.dispatchEvent(new CustomEvent("task:show-widget", { detail: { taskId } }));
        };

        return (
            <div className="h-full flex flex-col p-4 pt-16">
                {" "}
                {/* Padding top for header */}
                <div className="flex justify-between items-end mb-4 px-2">
                    <h2 className="text-xl font-bold text-white tracking-tighter">PROTOCOLS</h2>
                    <form onSubmit={handleCreate} className="flex gap-2">
                        <input value={newTask} onChange={(e) => setNewTask(e.target.value)} placeholder="New..." className="bg-[#111] border border-gray-700 rounded px-2 py-1 text-xs text-white focus:border-blue-500 outline-none w-32 focus:w-48 transition-all" />
                        <button className="bg-blue-700 hover:bg-blue-600 px-3 rounded text-white font-bold text-xs">+</button>
                    </form>
                </div>
                <div className="flex-1 overflow-y-auto custom-scroll pr-2 space-y-2">
                    {combinedList.map((task) => {
                        const isExpanded = activeMenuId === task.id; // Using activeMenuId as accordion state
                        const isArchived = task.is_done === 1;

                        return (
                            <div
                                key={task.id}
                                className={`rounded-lg border transition-all duration-300 overflow-hidden
                                ${isArchived ? "bg-black border-gray-800 opacity-60" : "bg-[#111] border-gray-700"}
                                ${isExpanded ? "border-blue-900 ring-1 ring-blue-900/50" : "hover:border-gray-600"}
                            `}
                            >
                                {/* Accordion Header */}
                                <div onClick={() => setActiveMenuId(isExpanded ? null : task.id)} className="flex items-center p-3 cursor-pointer select-none h-14">
                                    <div className="w-1.5 h-8 rounded-full mr-3" style={{ backgroundColor: task.color_hex || "#333" }} />

                                    <div className="flex-1 min-w-0">
                                        <h3 className={`font-bold text-sm truncate ${isArchived ? "line-through text-gray-500" : "text-gray-200"}`}>{task.title}</h3>
                                        <div className="flex items-center gap-2 text-[10px] font-mono text-gray-500">
                                            <span>{formatDuration(task.total_time_ms)}</span>
                                            {task.is_running && <span className="text-green-500 animate-pulse">â— REC</span>}
                                        </div>
                                    </div>

                                    <div className="text-gray-600 text-xs transform transition-transform duration-300">{isExpanded ? "â–²" : "â–¼"}</div>
                                </div>

                                {/* Accordion Body */}
                                <div className={`transition-all duration-300 ease-in-out bg-[#080808] border-t border-gray-800 ${isExpanded ? "max-h-48 opacity-100" : "max-h-0 opacity-0"}`}>
                                    <div className="p-3 grid grid-cols-2 gap-3">
                                        {/* Column 1: Primary Controls */}
                                        <div className="space-y-2">
                                            <button
                                                onClick={() => handleTaskAction(task, "toggle")}
                                                className={`w-full py-2 rounded text-xs font-bold uppercase tracking-wider flex items-center justify-center gap-2
                                                ${task.is_running ? "bg-red-900/30 text-red-400 hover:bg-red-900/50" : "bg-green-900/30 text-green-400 hover:bg-green-900/50"}`}
                                            >
                                                {task.is_running ? "âšâš Stop" : "â–¶ Start"}
                                            </button>

                                            <button onClick={() => toggleWidgetVisibility(task.id)} className="w-full py-1.5 rounded bg-gray-800 hover:bg-gray-700 text-gray-300 text-[10px] font-bold uppercase">
                                                ðŸ‘ Toggle Widget
                                            </button>
                                        </div>

                                        {/* Column 2: Management & Color */}
                                        <div className="space-y-2">
                                            <div className="flex gap-1 justify-between bg-black p-1 rounded border border-gray-800">
                                                {NOTE_COLORS.map((hex) => (
                                                    <button key={hex} onClick={() => API.updateTask(task.id, { color_hex: hex }).then(loadData)} style={{ backgroundColor: hex }} className={`w-4 h-4 rounded-full hover:scale-125 transition-transform ${task.color_hex === hex ? "ring-1 ring-white" : ""}`} />
                                                ))}
                                            </div>
                                            <div className="flex gap-2">
                                                <button onClick={() => handleTaskAction(task, "terminate")} className="flex-1 py-1 bg-gray-800 hover:bg-orange-900/30 text-orange-500 text-[10px] rounded">
                                                    Archive
                                                </button>
                                                <button onClick={() => handleTaskAction(task, "delete")} className="flex-1 py-1 bg-gray-800 hover:bg-red-900/30 text-red-500 text-[10px] rounded">
                                                    Delete
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        );
                    })}
                </div>
            </div>
        );
    };

    // 3. HISTORY VIEW (Accordion)
    const renderHistory = () => (
        <div className="h-full flex flex-col pt-10 bg-[#0a0a0a]">
            <div className="px-4 pb-2 border-b border-gray-800 mb-2">
                <h2 className="text-lg font-bold text-gray-300">Chronological Logs</h2>
            </div>
            <div className="flex-1 overflow-y-auto custom-scroll px-2 pb-10">
                {logs.map((log) => {
                    const isExpanded = expandedLogId === log.id;
                    const duration = log.end_time ? log.end_time - log.start_time : 0;

                    return (
                        <div key={log.id} className="mb-2 bg-[#111] border border-gray-800 rounded-lg overflow-hidden transition-colors hover:border-gray-700">
                            {/* Header Row */}
                            <div
                                onClick={() => {
                                    setExpandedLogId(isExpanded ? null : log.id);
                                    setNoteDraft(log.manual_note || "");
                                }}
                                className="flex items-center p-3 cursor-pointer select-none"
                            >
                                <div className="w-1 h-8 rounded mr-3" style={{ backgroundColor: log.color_hex || "#555" }} />
                                <div className="flex-1">
                                    <div className="flex justify-between items-center">
                                        <span className="font-bold text-gray-200 text-sm">{log.task_title}</span>
                                        <span className="font-mono text-blue-400 text-xs">{formatDuration(duration)}</span>
                                    </div>
                                    <div className="flex justify-between items-center mt-1">
                                        <span className="text-[10px] text-gray-500 uppercase tracking-wider">{formatDate(log.start_time)}</span>
                                        <span className="text-[10px] text-gray-600">{formatTime(log.start_time)}</span>
                                    </div>
                                </div>
                                <div className={`ml-3 text-gray-600 transition-transform duration-300 ${isExpanded ? "rotate-180" : ""}`}>â–¼</div>
                            </div>

                            {/* Expanded Details (Accordion) */}
                            <div
                                className={`bg-[#050505] border-t border-gray-800 transition-[max-height,opacity] duration-300 ease-in-out overflow-hidden
                                    ${isExpanded ? "max-h-60 opacity-100" : "max-h-0 opacity-0"}`}
                            >
                                <div className="p-4 flex gap-4">
                                    {/* Data Column */}
                                    <div className="flex-1 space-y-3">
                                        <div>
                                            <label className="text-[10px] uppercase text-gray-600 font-bold block mb-1">Session Note</label>
                                            <textarea value={noteDraft} onChange={(e) => setNoteDraft(e.target.value)} onBlur={() => saveNote(log.id)} placeholder="Add details about this session..." className="w-full bg-[#111] border border-gray-700 rounded p-2 text-xs text-gray-300 focus:border-blue-500 outline-none resize-none h-16" />
                                        </div>
                                    </div>

                                    {/* Actions Column */}
                                    <div className="w-1/3 flex flex-col justify-between border-l border-gray-800 pl-4">
                                        <div className="text-right">
                                            <div className="text-[10px] text-gray-500">Exact Start</div>
                                            <div className="text-xs font-mono text-gray-300">{new Date(log.start_time).toLocaleString()}</div>
                                        </div>
                                        <button onClick={() => goToCalendarTime(log.start_time)} className="bg-blue-900/30 hover:bg-blue-800 text-blue-300 text-xs px-3 py-2 rounded border border-blue-900/50 flex items-center justify-center gap-2 transition-colors">
                                            <span>ðŸ“… Jump to Calendar</span>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );

    const renderCalendar = () => {
        // --- Header Component ---
        const Header = () => (
            <div className="flex justify-between items-center px-4 py-3 bg-[#111] border-b border-gray-800 mt-12">
                {" "}
                {/* mt-12 clears the absolute header */}
                <div className="flex items-center gap-4">
                    <h2 className="text-lg font-bold text-white uppercase tracking-widest">{selectedDate.toLocaleString("default", { month: "long", year: "numeric" })}</h2>
                    <div className="flex bg-black rounded p-0.5 border border-gray-800">
                        {["month", "week", "day"].map((m) => (
                            <button key={m} onClick={() => setCalendarMode(m)} className={`px-3 py-1 text-[10px] font-bold uppercase rounded transition-colors ${calendarMode === m ? "bg-gray-700 text-white" : "text-gray-500 hover:text-white"}`}>
                                {m}
                            </button>
                        ))}
                    </div>
                </div>
                <div className="flex gap-1">
                    <button
                        onClick={() => {
                            const d = new Date(selectedDate);
                            d.setMonth(d.getMonth() - 1);
                            setSelectedDate(d);
                        }}
                        className="p-1 hover:bg-gray-800 rounded text-white"
                    >
                        â—€
                    </button>
                    <button onClick={() => setSelectedDate(new Date())} className="text-xs px-2 hover:bg-gray-800 rounded text-gray-300">
                        Today
                    </button>
                    <button
                        onClick={() => {
                            const d = new Date(selectedDate);
                            d.setMonth(d.getMonth() + 1);
                            setSelectedDate(d);
                        }}
                        className="p-1 hover:bg-gray-800 rounded text-white"
                    >
                        â–¶
                    </button>
                </div>
            </div>
        );

        // --- Month View ---
        if (calendarMode === "month") {
            const year = selectedDate.getFullYear();
            const month = selectedDate.getMonth();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const startOffset = new Date(year, month, 1).getDay();

            return (
                <div className="h-full flex flex-col bg-[#050505]">
                    <Header />
                    <div className="grid grid-cols-7 text-center py-1 border-b border-gray-800 text-[10px] text-gray-500 font-bold uppercase">
                        {["S", "M", "T", "W", "T", "F", "S"].map((d) => (
                            <div key={d}>{d}</div>
                        ))}
                    </div>
                    <div className="flex-1 grid grid-cols-7 gap-px bg-gray-800 overflow-y-auto custom-scroll">
                        {/* Empty Slots */}
                        {Array.from({ length: startOffset }).map((_, i) => (
                            <div key={`empty-${i}`} className="bg-[#080808]" />
                        ))}

                        {/* Days */}
                        {Array.from({ length: daysInMonth }).map((_, i) => {
                            const d = i + 1;
                            const currentDate = new Date(year, month, d);
                            const dateStr = currentDate.toDateString();

                            const dayLogs = logs.filter((l) => new Date(l.start_time).toDateString() === dateStr);
                            const totalMs = dayLogs.reduce((acc, l) => acc + (l.end_time ? l.end_time - l.start_time : 0), 0);

                            return (
                                <div
                                    key={d}
                                    onClick={() => {
                                        setSelectedDate(currentDate);
                                        setCalendarMode("day");
                                    }}
                                    className="bg-[#111] hover:bg-[#1a1a1a] p-1 cursor-pointer flex flex-col justify-between group transition-colors min-h-[80px]"
                                >
                                    <span className="text-xs font-bold text-gray-500 group-hover:text-white p-1">{d}</span>
                                    {totalMs > 0 && (
                                        <div className="px-1 pb-1">
                                            <div className="flex gap-0.5 mb-1 flex-wrap content-end">
                                                {dayLogs.slice(0, 6).map((l, idx) => (
                                                    <div key={idx} className="w-1.5 h-1.5 rounded-full" style={{ backgroundColor: l.color_hex || "#3b82f6" }} title={l.task_title} />
                                                ))}
                                                {dayLogs.length > 6 && <span className="text-[8px] text-gray-500 leading-none">+</span>}
                                            </div>
                                            <div className="text-[9px] text-green-400 font-mono text-right border-t border-gray-800 pt-0.5">{formatDuration(totalMs)}</div>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        }

        // --- Time Grid (Week/Day) ---
        const renderTimeGrid = (days) => (
            <div
                className="flex-1 overflow-auto bg-[#080808] relative custom-scroll"
                onWheel={(e) => {
                    if (e.ctrlKey) {
                        setZoomLevel((z) => Math.min(3, Math.max(0.5, z + (e.deltaY > 0 ? -0.1 : 0.1))));
                    }
                }}
            >
                <div className="flex min-h-full ml-10">
                    {/* Time Axis */}
                    <div className="fixed left-0 w-10 bg-[#111] border-r border-gray-800 h-full z-10 mt-[88px] pointer-events-none">
                        {" "}
                        {/* Margin top matches header height roughly */}
                        {Array.from({ length: 24 }).map((_, i) => (
                            <div key={i} className="text-[9px] text-gray-500 text-right pr-1 pt-0.5 border-b border-gray-800/30" style={{ height: `${60 * zoomLevel}px` }}>
                                {i}:00
                            </div>
                        ))}
                    </div>

                    {/* Columns */}
                    {days.map((dateObj, idx) => {
                        const dateStr = dateObj.toDateString();
                        const dayLogs = logs.filter((l) => new Date(l.start_time).toDateString() === dateStr);

                        return (
                            <div key={idx} className="flex-1 border-r border-gray-800/50 relative min-w-[150px]">
                                <div className="sticky top-0 bg-[#111]/90 backdrop-blur text-center text-xs font-bold text-gray-400 py-2 border-b border-gray-700 z-10">{dateObj.toLocaleDateString(undefined, { weekday: "short", day: "numeric" })}</div>
                                {/* Grid Lines */}
                                {Array.from({ length: 24 }).map((_, i) => (
                                    <div key={i} className="border-b border-gray-800/20 w-full absolute pointer-events-none" style={{ top: `${i * 60 * zoomLevel + 33}px`, height: `${60 * zoomLevel}px` }} />
                                ))}

                                {/* Logs */}
                                {dayLogs.map((log) => {
                                    const start = new Date(log.start_time);
                                    const end = log.end_time ? new Date(log.end_time) : new Date();
                                    const startMin = start.getHours() * 60 + start.getMinutes();
                                    const durationMin = (end - start) / 60000;
                                    const task = tasks.find((t) => t.title === log.task_title);

                                    return (
                                        <div
                                            key={log.id}
                                            className="absolute left-1 right-1 rounded border shadow-sm overflow-hidden hover:z-20 hover:scale-[1.02] transition-all cursor-pointer group"
                                            style={{
                                                top: `${startMin * zoomLevel + 33}px`, // +33 for date header
                                                height: `${Math.max(20, durationMin * zoomLevel)}px`,
                                                backgroundColor: `${task?.color_hex || "#333"}E6`,
                                                borderColor: task?.color_hex || "#555",
                                            }}
                                            title={`${log.task_title}\n${log.manual_note || ""}`}
                                        >
                                            <div className="px-1 py-0.5 h-full">
                                                <div className="text-[10px] font-bold text-white truncate">{log.task_title}</div>
                                                {(zoomLevel > 0.8 || durationMin > 30) && <div className="text-[9px] text-white/80 truncate opacity-70 group-hover:opacity-100">{log.manual_note || formatDuration(end - start)}</div>}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        );
                    })}
                </div>
            </div>
        );

        if (calendarMode === "week") {
            const start = new Date(selectedDate);
            const day = start.getDay() || 7;
            if (day !== 1) start.setHours(-24 * (day - 1));
            const days = Array.from({ length: 7 }, (_, i) => {
                const d = new Date(start);
                d.setDate(start.getDate() + i);
                return d;
            });
            return (
                <div className="h-full flex flex-col bg-[#050505]">
                    <Header />
                    {renderTimeGrid(days)}
                </div>
            );
        }

        return (
            <div className="h-full flex flex-col bg-[#050505]">
                <Header />
                {renderTimeGrid([selectedDate])}
            </div>
        );
    };

    // [Wrap the entire RETURN statement of the component in this ResizableBox]
    return (
        <div ref={containerRef} className="relative h-full w-full">
            <ResizableBox
                width={500} // Default Start Width
                height={600} // Default Start Height
                minConstraints={[350, 400]}
                maxConstraints={[1200, 1000]}
                resizeHandles={["se", "e", "s"]} // Bottom-Right, Right, Bottom
                className="bg-black border border-gray-800 rounded-xl shadow-2xl flex flex-col overflow-hidden relative"
            >
                {renderHeader()} {/* The New Pill Header */}
                <div className="flex-1 overflow-hidden relative bg-[#050505]">
                    {view === "dashboard" && renderDashboard()}
                    {view === "history" && renderHistory()}
                    {view === "calendar" && renderCalendar()}
                </div>
            </ResizableBox>
        </div>
    );
};

export default TasksApp;
```

```jsx
// frontend\src\apps\TasksApp.jsx
import React, { useState, useEffect, useRef } from "react";
import "react-resizable/css/styles.css"; // Basic styles for resizable handles
import * as API from "../api";
import "../styles/calendar.css"; // Ensure you have basic calendar styles or Tailwind

// --- HELPER: TIME FORMATTING ---
const formatDuration = (ms) => {
    if (!ms || isNaN(ms)) return "0m";
    const hrs = Math.floor(ms / 3600000);
    const mins = Math.floor((ms % 3600000) / 60000);
    return hrs > 0 ? `${hrs}h ${mins}m` : `${mins}m`;
};
// --- HOOK: TASK SYSTEM ---
const useTaskSystem = (setTasks, setLogs) => {
    const [activeSession, setActiveSession] = useState(null);

    const refreshActive = async () => {
        const session = await API.getActiveSession();
        setActiveSession(session);
    };

    const handleStart = async (taskId) => {
        try {
            await API.startTask(taskId);
            await refreshActive();
            window.dispatchEvent(new CustomEvent("cognicanvas:data-updated"));
        } catch (e) {
            if (e.message.includes("already running")) {
                // Backend returns 409 with running task info
                if (confirm("Another protocol is active. Stop it and switch?")) {
                    // Logic to stop current and start new could go here
                }
            } else {
                alert(e.message);
            }
        }
    };

    const handleStop = async (taskId, noteDraft = "") => {
        const result = await API.stopTask(taskId, { manual_note: noteDraft });
        if (result.success) {
            // Atomic update: Replace the task in the list with the fresh one from DB
            setTasks((prev) => prev.map((t) => (t.id === taskId ? result.task : t)));
            setActiveSession(null);
            window.dispatchEvent(new CustomEvent("cognicanvas:data-updated"));
        }
    };

    return { activeSession, refreshActive, handleStart, handleStop };
};
// Helper: Safe Duration Calculator
const getDuration = (start, end) => {
    if (!start || !end) return 0;
    const s = new Date(start).getTime();
    const e = new Date(end).getTime();
    return isNaN(s) || isNaN(e) ? 0 : e - s;
};
const formatDate = (date) => new Date(date).toLocaleDateString(undefined, { month: "short", day: "numeric", year: "numeric" });
const formatTime = (date) => new Date(date).toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });

// --- COMPONENT: TASKS APP ---
const TasksApp = ({ windowAPI, isHeaderOnly }) => {
    const scrollRef = useRef(null); // Add this at the top of TasksApp
    // Inside TasksApp Component:

    const [activeSession, setActiveSession] = useState(null);
    const [tasks, setTasks] = useState([]);
    const [logs, setLogs] = useState([]);
    const [view, setView] = useState("dashboard"); // 'dashboard', 'history', 'calendar'

    // Calendar Specific State
    const [calendarMode, setCalendarMode] = useState("month"); // 'year', 'month', 'week', 'day'
    const [selectedDate, setSelectedDate] = useState(new Date());
    const [zoomLevel, setZoomLevel] = useState(1);

    // Dashboard Specific State
    const [activeMenuId, setActiveMenuId] = useState(null); // Accordion toggle for tasks
    const [colorPickerId, setColorPickerId] = useState(null); // (Optional) for inline color picking

    // History Specific State
    const [expandedLogId, setExpandedLogId] = useState(null);
    const [noteDraft, setNoteDraft] = useState("");

    // Data State

    const [newTask, setNewTask] = useState("");

    // Ref for resizing context
    const containerRef = useRef(null);
    const { refreshActive, handleStart, handleStop } = useTaskSystem(setTasks, setLogs);
    // Updated LoadData: Only fetch Task definitions and Heartbeat
    const loadBaseData = async () => {
        try {
            const tData = await API.getTasks();
            setTasks(tData.tasks || []);
            await refreshActive();
        } catch (e) {
            console.error("Base load failed", e);
        }
    };

    // NEW: Specialized Loader for History/Calendar (Lazy Loading)
    useEffect(() => {
        const loadLogs = async () => {
            if (view === "dashboard") return;

            let start, end;
            if (view === "calendar") {
                const year = selectedDate.getFullYear();
                const month = selectedDate.getMonth();

                if (calendarMode === "month") {
                    // Get FULL month range (1st 00:00 to Last Day 23:59)
                    start = new Date(year, month, 1).toISOString();
                    end = new Date(year, month + 1, 0, 23, 59, 59, 999).toISOString();
                } else if (calendarMode === "day") {
                    start = new Date(year, month, selectedDate.getDate(), 0, 0, 0).toISOString();
                    end = new Date(year, month, selectedDate.getDate(), 23, 59, 59, 999).toISOString();
                } else if (calendarMode === "year") {
                    // Fetch whole year
                    start = new Date(year, 0, 1).toISOString();
                    end = new Date(year, 11, 31, 23, 59, 59).toISOString();
                }
            }

            // Pass these directly to API
            const lData = await API.getHistory(start, end);
            setLogs(lData || []);
        };
        loadLogs();
    }, [view, calendarMode, selectedDate]);

    // Update initial load
    useEffect(() => {
        loadBaseData();
        const interval = setInterval(refreshActive, 30000); // Pulse check every 30s
        return () => clearInterval(interval);
    }, []);
    // --- WIDGET SYNC HELPER ---
    const toggleWidgetVisibility = (taskId) => {
        window.dispatchEvent(new CustomEvent("task:toggle-visibility", { detail: { taskId } }));
    };
    // -------------------------------------------------------------------------
    // 1. STATE MANAGEMENT (ALL HOOKS TOP LEVEL)
    // -------------------------------------------------------------------------

    // UI View State

    // -------------------------------------------------------------------------
    // 2. SYNCHRONIZATION & DATA LOADING
    // -------------------------------------------------------------------------

    const loadData = async () => {
        try {
            const [tData, lData] = await Promise.all([API.getTasks(), API.getHistory()]);
            setTasks(tData.tasks || []);
            setLogs(lData || []);
        } catch (e) {
            console.error("Load failed", e);
        }
    };

    // Initial Load & Polling
    useEffect(() => {
        loadData();
        const interval = setInterval(loadData, 5000);

        // Listen for sync events (e.g., from TaskWidget)
        const handleRemote = () => loadData();
        window.addEventListener("cognicanvas:data-updated", handleRemote);

        return () => {
            clearInterval(interval);
            window.removeEventListener("cognicanvas:data-updated", handleRemote);
        };
    }, []);

    // Broadcast update helper
    const broadcastSync = () => {
        window.dispatchEvent(new CustomEvent("cognicanvas:data-updated"));
        loadData();
    };

    // -------------------------------------------------------------------------
    // 3. ACTIONS (CRUD)
    // -------------------------------------------------------------------------

    const handleTaskAction = async (task, action) => {
        if (action === "toggle") {
            try {
                if (task.is_running || activeSession?.id === task.id) {
                    const res = await API.stopTask(task.id, { manual_note: noteDraft });
                    setTasks((prev) => prev.map((t) => (t.id === task.id ? res.task : t)));
                    setNoteDraft("");
                } else {
                    await API.startTask(task.id);
                }
                await refreshActive();
                window.dispatchEvent(new CustomEvent("cognicanvas:data-updated"));
            } catch (e) {
                alert(e.message);
            }
        } else if (action === "terminate") {
            if (confirm("Retire task?")) {
                await API.terminateTask(task.id);
                loadBaseData();
            }
        } else if (action === "delete") {
            if (confirm("Permanently delete?")) {
                await API.deleteTask(task.id);
                // OPTIMISTIC UPDATE: Remove immediately to kill the widget
                setTasks((prev) => prev.filter((t) => t.id !== task.id));
                // Then reload just in case
                setTimeout(loadBaseData, 100);
            }
        }
    };

    const handleCreate = async (e) => {
        e.preventDefault();
        if (!newTask.trim()) return;
        await API.createTask(newTask);
        setNewTask("");
        loadBaseData(); // Refresh list
    };

    const saveNote = async (logId) => {
        // Implement API call to save note for specific log
        // console.log("Saving note:", noteDraft, " for log:", logId);
        // await API.updateLog(logId, { manual_note: noteDraft });
        broadcastSync();
    };

    const handleUpdateColor = async (taskId, hex) => {
        await API.updateTask(taskId, { color_hex: hex });
        broadcastSync();
    };

    const goToCalendarTime = (isoString) => {
        const date = new Date(isoString);
        // Setting these states triggers the specialized useEffect in Step 3
        setSelectedDate(date);
        setCalendarMode("day");
        setView("calendar");

        // Scroll logic remains same...
        setTimeout(() => {
            if (scrollRef.current) {
                const hours = date.getHours();
                const scrollTarget = hours * 60 * zoomLevel;
                scrollRef.current.scrollTo({ top: scrollTarget, behavior: "smooth" });
            }
        }, 150);
    };

    // NOTE COLORS PRESET
    const NOTE_COLORS = ["#111827", "#7f1d1d", "#7c2d12", "#14532d", "#1e3a8a", "#581c87", "#422006", "#713f12", "#164e63", "#4c1d95", "#0f172a", "#831843"];
    // -------------------------------------------------------------------------
    // 4. RENDERERS (VIEW COMPONENTS)
    // -------------------------------------------------------------------------

    // A. THE PILL HEADER (Floating, Interactable, Drag Handle)
    const renderHeader = () => (
        // Changed: -top-7 pushes it slightly above/flush with the top edge
        <div className="absolute -top-2 left-0 right-0 h-14 z-50 flex justify-center items-start pointer-events-none">
            {/* The Pill Container */}
            <div className="group pointer-events-auto mt-2 relative">
                {/* 1. Default State (Simple Pill) */}
                <div className="bg-[#1a1a1a] border border-gray-600 rounded-full px-4 py-1.5 shadow-lg flex items-center gap-2 transition-all duration-300 group-hover:opacity-0 absolute top-0 left-1/2 -translate-x-1/2 whitespace-nowrap">
                    <span className="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></span>
                    <span className="text-[10px] font-bold text-gray-300 tracking-widest uppercase">Task Manager</span>
                </div>

                {/* 2. Expanded State (Hover) */}
                <div className="bg-[#111] border border-gray-500 rounded-xl p-1.5 shadow-2xl flex items-center gap-3 opacity-0 translate-y-2 scale-95 group-hover:opacity-100 group-hover:translate-y-0 group-hover:scale-100 transition-all duration-200 ease-out origin-top">
                    {/* FIXED: DRAG HANDLE CONNECTED TO HDWindowFrame */}
                    <div className={`${windowAPI?.dragHandleClass || "custom-window-drag"} cursor-move px-2 py-1 hover:bg-gray-800 rounded flex items-center gap-2 border-r border-gray-700 mr-1`}>
                        <span className="text-xs font-bold text-white">â‹®â‹®</span>
                        <span className="text-[10px] font-bold text-gray-400 uppercase">Grip</span>
                    </div>
                    {/* Navigation Tabs */}
                    <div className="flex bg-black rounded p-0.5 border border-gray-800">
                        {["dashboard", "history", "calendar"].map((t) => (
                            <button key={t} onClick={() => setView(t)} className={`px-3 py-1 text-[9px] font-bold uppercase rounded transition-colors ${view === t ? "bg-blue-700 text-white" : "text-gray-500 hover:text-gray-300"}`}>
                                {t}
                            </button>
                        ))}
                    </div>
                    <button
                        onClick={async () => {
                            const taskId = prompt("Enter Task ID to fill with data:");
                            if (taskId) await API.apiFetch("/dev/generate-logs", { method: "POST", body: JSON.stringify({ taskId, count: 10 }) });
                            alert("Generated. Refreshing...");
                            window.dispatchEvent(new CustomEvent("cognicanvas:data-updated"));
                        }}
                        className="text-[8px] text-gray-700 hover:text-white"
                    >
                        DEV
                    </button>
                    <button
                        onClick={async () => {
                            await API.apiFetch("/dev/init-test", { method: "POST" });
                            loadBaseData(); // Refresh tasks
                            // Force refresh logs if in calendar view
                            if (view === "calendar") {
                                const d = new Date(selectedDate);
                                setSelectedDate(new Date(d.getTime() + 1)); // Hack to trigger useEffect
                            }
                            alert("Test Data Generated");
                        }}
                        className="px-3 py-1 text-[9px] font-bold uppercase rounded text-purple-500 hover:bg-purple-900/20"
                    >
                        + Test Data
                    </button>
                    {/* FIXED: CLOSE BUTTON NOW CALLS THE API */}
                    <button onClick={() => windowAPI?.close?.()} className="w-5 h-5 flex items-center justify-center rounded-full bg-red-900/50 hover:bg-red-600 text-red-200 hover:text-white transition-colors ml-2">
                        Ã—
                    </button>
                </div>
            </div>
        </div>
    );

    // B. DASHBOARD VIEW
    const renderDashboard = () => {
        const activeList = tasks.filter((t) => t.is_done === 0);
        const archivedList = tasks.filter((t) => t.is_done === 1);
        const combinedList = [...activeList, ...archivedList];
        // Inside TasksApp.jsx Dashboard render:
        const toggleWidgetVisibility = (taskId) => {
            // This event is caught by the new TaskWidget listener
            window.dispatchEvent(
                new CustomEvent("task:toggle-visibility", {
                    detail: { taskId },
                }),
            );
        };
        return (
            <div className="h-full flex flex-col p-4 pt-16">
                <div className="flex justify-between items-end mb-4 px-2">
                    <h2 className="text-xl font-bold text-white tracking-tighter">PROTOCOLS</h2>
                    <form onSubmit={handleCreate} className="flex gap-2">
                        <input value={newTask} onChange={(e) => setNewTask(e.target.value)} placeholder="New Protocol..." className="bg-[#111] border border-gray-700 rounded px-2 py-1 text-xs text-white focus:border-blue-500 outline-none w-32 focus:w-48 transition-all" />
                        <button className="bg-blue-700 hover:bg-blue-600 px-3 rounded text-white font-bold text-xs">+</button>
                    </form>
                </div>

                <div className="flex-1 overflow-y-auto custom-scroll pr-2 space-y-2">
                    {combinedList.map((task) => {
                        const isExpanded = activeMenuId === task.id;
                        const isArchived = task.is_done === 1;

                        return (
                            <div key={task.id} className={`rounded-lg border transition-all duration-300 overflow-hidden ${isArchived ? "bg-black border-gray-800 opacity-60" : "bg-[#111] border-gray-700"} ${isExpanded ? "border-blue-900 ring-1 ring-blue-900/50" : "hover:border-gray-600"}`}>
                                {/* Task Header */}
                                <div onClick={() => setActiveMenuId(isExpanded ? null : task.id)} className="flex items-center p-3 cursor-pointer select-none h-14">
                                    <div className="w-1.5 h-8 rounded-full mr-3" style={{ backgroundColor: task.color_hex || "#333" }} />
                                    <div className="flex-1 min-w-0">
                                        <h3 className={`font-bold text-sm truncate ${isArchived ? "line-through text-gray-500" : "text-gray-200"}`}>{task.title}</h3>
                                        <div className="flex items-center gap-2 text-[10px] font-mono text-gray-500">
                                            <span>{formatDuration(task.total_time_ms)}</span>
                                            {task.is_running && <span className="text-green-500 animate-pulse">â— REC</span>}
                                        </div>
                                    </div>
                                    <div className="text-gray-600 text-xs">{isExpanded ? "â–²" : "â–¼"}</div>
                                </div>

                                {/* Task Details (Accordion) */}
                                <div className={`transition-all duration-300 ease-in-out bg-[#080808] border-t border-gray-800 ${isExpanded ? "max-h-48 opacity-100" : "max-h-0 opacity-0"}`}>
                                    <div className="p-3 grid grid-cols-2 gap-3">
                                        <div className="space-y-2">
                                            <button onClick={() => handleTaskAction(task, "toggle")} className={`w-full py-2 rounded text-xs font-bold uppercase tracking-wider flex items-center justify-center gap-2 ${task.is_running ? "bg-red-900/30 text-red-400" : "bg-green-900/30 text-green-400"}`}>
                                                {task.is_running ? "âšâš Stop" : "â–¶ Start"}
                                            </button>
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    toggleWidgetVisibility(task.id);
                                                }}
                                                className="w-full py-2 rounded text-xs font-bold uppercase tracking-wider bg-blue-900/30 text-blue-400"
                                            >
                                                ðŸ‘ Toggle Widget
                                            </button>
                                        </div>
                                        <div className="space-y-2">
                                            <div className="flex gap-1 justify-between bg-black p-1 rounded border border-gray-800">
                                                {NOTE_COLORS.map((hex) => (
                                                    <button key={hex} onClick={() => handleUpdateColor(task.id, hex)} style={{ backgroundColor: hex }} className="w-4 h-4 rounded-full hover:scale-125 transition-transform" />
                                                ))}
                                            </div>
                                            <div className="flex gap-2">
                                                <button onClick={() => handleTaskAction(task, "terminate")} className="flex-1 py-1 bg-gray-800 hover:bg-orange-900/30 text-orange-500 text-[10px] rounded">
                                                    Archive
                                                </button>
                                                <button onClick={() => handleTaskAction(task, "delete")} className="flex-1 py-1 bg-gray-800 hover:bg-red-900/30 text-red-500 text-[10px] rounded">
                                                    Delete
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        );
                    })}
                </div>
            </div>
        );
    };

    // C. HISTORY VIEW
    const renderHistory = () => (
        <div className="h-full flex flex-col pt-10 bg-[#0a0a0a]">
            <div className="px-4 pb-2 border-b border-gray-800 mb-2 mt-4">
                <h2 className="text-lg font-bold text-gray-300">Chronological Logs</h2>
            </div>
            <div className="flex-1 overflow-y-auto custom-scroll px-2 pb-10">
                {logs.map((log) => {
                    const isExpanded = expandedLogId === log.id;
                    return (
                        <div key={log.id} className="mb-2 bg-[#111] border border-gray-800 rounded-lg overflow-hidden hover:border-gray-700">
                            <div
                                onClick={() => {
                                    setExpandedLogId(isExpanded ? null : log.id);
                                    setNoteDraft(log.manual_note || "");
                                }}
                                className="flex items-center p-3 cursor-pointer select-none"
                            >
                                <div className="w-1 h-8 rounded mr-3" style={{ backgroundColor: log.color_hex || "#555" }} />

                                <div className="flex-1">
                                    <div className="flex justify-between items-center">
                                        <span className="font-bold text-gray-200 text-sm">{log.task_title}</span>
                                        <span className="font-mono text-blue-400 text-xs">{formatDuration(getDuration(log.start_time, log.end_time))}</span>
                                    </div>
                                    <div className="flex justify-between items-center mt-1">
                                        <span className="text-[10px] text-gray-500 uppercase tracking-wider">{formatDate(log.start_time)}</span>
                                        <span className="text-[10px] text-gray-600">{formatTime(log.start_time)}</span>
                                    </div>
                                </div>
                            </div>

                            {isExpanded && (
                                <div className="bg-[#050505] border-t border-gray-800 p-4 flex flex-col gap-4 animate-in fade-in slide-in-from-top-1 duration-200">
                                    {/* Data Grid */}
                                    <div className="grid grid-cols-2 gap-4 text-xs">
                                        <div className="space-y-2">
                                            <div>
                                                <div className="text-gray-500 uppercase text-[9px] font-bold">Task Name</div>
                                                <div className="text-gray-200 font-bold">{log.task_title}</div>
                                            </div>
                                            <div>
                                                <div className="text-gray-500 uppercase text-[9px] font-bold">Duration</div>
                                                <div className="text-blue-400 font-mono text-sm">{formatDuration(getDuration(log.start_time, log.end_time))}</div>
                                            </div>
                                        </div>
                                        <div className="space-y-2 border-l border-gray-800 pl-4">
                                            <div>
                                                <div className="text-gray-500 uppercase text-[9px] font-bold">Start Time</div>
                                                <div className="text-gray-300 font-mono">{new Date(log.start_time).toLocaleString()}</div>
                                            </div>
                                            <div>
                                                <div className="text-gray-500 uppercase text-[9px] font-bold">End Time</div>
                                                <div className="text-gray-300 font-mono">{log.end_time ? new Date(log.end_time).toLocaleString() : "Still Active"}</div>
                                            </div>
                                        </div>
                                        <div className="col-span-2 pt-2 border-t border-gray-800/50">
                                            <div className="flex justify-between text-[9px] text-gray-500 uppercase font-bold">
                                                <span>Day Start: {new Date(log.start_time).toLocaleDateString()}</span>
                                                <span>Day End: {new Date(log.start_time).toLocaleDateString()}</span>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Note Section & Action */}
                                    <div className="flex gap-4 items-end mt-2 pt-4 border-t border-gray-800">
                                        <div className="flex-1">
                                            <div className="text-gray-500 uppercase text-[9px] font-bold mb-1">Session Note</div>
                                            <textarea value={noteDraft} onChange={(e) => setNoteDraft(e.target.value)} onBlur={() => saveNote(log.id)} className="w-full bg-[#111] border border-gray-700 rounded p-2 text-xs text-gray-300 h-16 resize-none focus:border-blue-500 outline-none" placeholder="Add session notes..." />
                                        </div>
                                        <button onClick={() => goToCalendarTime(log.start_time)} className="bg-blue-900/30 hover:bg-blue-800 text-blue-300 text-xs px-4 py-3 rounded border border-blue-900/50 transition-colors h-16 flex items-center">
                                            ðŸ“… Jump to Date
                                        </button>
                                        <button
                                            onClick={async (e) => {
                                                e.stopPropagation();
                                                if (confirm("Delete this specific session log? Time will be deducted.")) {
                                                    await API.deleteLog(log.id);
                                                    // Trigger reload
                                                    window.dispatchEvent(new CustomEvent("cognicanvas:data-updated"));
                                                }
                                            }}
                                            className="text-red-500 hover:text-red-400 text-[10px] uppercase font-bold border border-red-900/50 bg-red-900/10 px-3 rounded hover:bg-red-900/30 transition-colors"
                                        >
                                            Delete Log
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>
    );
    // D. CALENDAR VIEW
    const renderCalendar = () => {
        // Calendar Header Helper
        const CalendarHeader = () => (
            <div className="flex justify-between items-center px-4 py-3 bg-[#111] border-b border-gray-800 mt-12">
                <div className="flex items-center gap-4">
                    <h2 className="text-lg font-bold text-white uppercase tracking-widest">{
                    selectedDate.toLocaleString("default", { month: "long", year: "numeric" }) 
                    }</h2>
                    <div className="flex bg-black rounded p-0.5 border border-gray-800">
                        {["year", "month", "week", "day"].map((m) => (
                            <button key={m} onClick={() => setCalendarMode(m)} className={`px-3 py-1 text-[10px] font-bold uppercase rounded transition-colors ${calendarMode === m ? "bg-gray-700 text-white" : "text-gray-500 hover:text-white"}`}>
                                {m}
                            </button>
                        ))}
                    </div>
                </div>
                <div className="flex gap-1">
                    <button
                        onClick={() => {
                            const d = new Date(selectedDate);
                            if (calendarMode === "year") d.setFullYear(d.getFullYear() - 1);
                            else if (calendarMode === "month") d.setMonth(d.getMonth() - 1);
                            else if (calendarMode === "week") d.setDate(d.getDate() - 7);
                            else if (calendarMode === "day") d.setDate(d.getDate() - 1);
                            setSelectedDate(d);
                        }}
                        className="p-1 hover:bg-gray-800 rounded text-white"
                    >
                        â—€
                    </button>
                    <button onClick={() => setSelectedDate(new Date())} className="p-1 hover:bg-gray-800 rounded text-white">
                        Today
                    </button>
                    <button
                        onClick={() => {
                            const d = new Date(selectedDate);
                            if (calendarMode === "year") d.setFullYear(d.getFullYear() + 1);
                            else if (calendarMode === "month") d.setMonth(d.getMonth() + 1);
                            else if (calendarMode === "week") d.setDate(d.getDate() + 7);
                            else if (calendarMode === "day") d.setDate(d.getDate() + 1);
                            setSelectedDate(d);
                        }}
                        className="p-1 hover:bg-gray-800 rounded text-white"
                    >
                        â–¶
                    </button>
                </div>
            </div>
        );

        // 1. Month Mode
        if (calendarMode === "month") {
            const year = selectedDate.getFullYear();
            const month = selectedDate.getMonth();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const startOffset = new Date(year, month, 1).getDay();
            const monthLogs = logs.filter((l) => {
                const d = new Date(l.start_time);
                return d.getMonth() === selectedDate.getMonth() && d.getFullYear() === selectedDate.getFullYear();
            });
            const monthTotalMs = monthLogs.reduce((acc, l) => acc + getDuration(l.start_time, l.end_time), 0);
            return (
                <div className="h-full flex flex-col bg-[#050505]">
                    <CalendarHeader />
                    <div className="px-4 py-1.5 bg-blue-900/10 border-b border-blue-900/30 flex justify-between items-center">
                        <span className="text-[10px] font-black text-blue-400 uppercase tracking-widest">Month Statistics</span>
                        <div className="flex gap-4">
                            <span className="text-[10px] text-gray-400 font-mono">Sessions: {monthLogs.length}</span>
                            <span className="text-[10px] text-green-400 font-mono font-bold">Total: {formatDuration(monthTotalMs)}</span>
                        </div>
                    </div>
                    <div className="grid grid-cols-7 text-center py-1 border-b border-gray-800 text-[10px] text-gray-500 font-bold uppercase">
                        {["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map((d) => (
                            <div key={d}>{d}</div>
                        ))}
                    </div>
                    <div className="flex-1 grid grid-cols-7 gap-px bg-gray-800 overflow-y-auto custom-scroll">
                        {Array.from({ length: startOffset }).map((_, i) => (
                            <div key={`empty-${i}`} className="bg-[#080808]" />
                        ))}
                        {Array.from({ length: daysInMonth }).map((_, i) => {
                            const d = i + 1;
                            const currentDate = new Date(year, month, d);
                            const dateStr = currentDate.toDateString();
                            const dayLogs = logs.filter((l) => new Date(l.start_time).toDateString() === dateStr);
                            const totalMs = dayLogs.reduce((acc, l) => acc + getDuration(l.start_time, l.end_time), 0);

                            return (
                                <div
                                    key={d}
                                    onClick={() => {
                                        setSelectedDate(currentDate);
                                        setCalendarMode("day");
                                    }}
                                    className="bg-[#111] hover:bg-[#1a1a1a] p-1 cursor-pointer flex flex-col justify-between group transition-colors min-h-[80px]"
                                >
                                    <span className={`text-xs font-bold p-1 ${currentDate.toDateString() === new Date().toDateString() ? "text-blue-500" : "text-gray-500 group-hover:text-white"}`}>{d}</span>
                                    {totalMs > 0 && (
                                        <div className="px-1 pb-1">
                                            <div className="flex gap-0.5 mb-1 flex-wrap content-end">
                                                {dayLogs.slice(0, 6).map((l, idx) => (
                                                    <div key={idx} className="w-1.5 h-1.5 rounded-full" style={{ backgroundColor: l.color_hex || "#3b82f6" }} title={l.task_title} />
                                                ))}
                                            </div>
                                            <div className="text-[9px] text-green-400 font-mono text-right border-t border-gray-800 pt-0.5">{formatDuration(totalMs)}</div>
                                        </div>
                                    )}
                                    <div className="px-1 py-1 bg-black/40 text-[10px] text-blue-400 font-mono flex justify-between">
                                        <span>Total:{formatDuration(totalMs)}</span>
                                        <span className="font-bold -left-5"></span>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        }
        // 0. Year Mode (NEW)
        if (calendarMode === "year") {
            const year = selectedDate.getFullYear();
            const months = Array.from({ length: 12 });
            return (
                <div className="h-full flex flex-col bg-[#050505]">
                    <CalendarHeader />
                    <div className="flex-1 grid grid-cols-3 gap-3 p-4 overflow-y-auto custom-scroll">
                        {months.map((_, i) => {
                            const monthLogs = logs.filter((l) => new Date(l.start_time).getFullYear() === year && new Date(l.start_time).getMonth() === i);
                            const totalMs = monthLogs.reduce((acc, l) => acc + getDuration(l.start_time, l.end_time), 0);
                            return (
                                <div
                                    key={i}
                                    onClick={() => {
                                        setSelectedDate(new Date(year, i, 1));
                                        setCalendarMode("month");
                                    }}
                                    className="bg-[#11] border border-gray-800 hover:border-blue-800 hover:bg-blue-900/10 rounded-lg p-3 cursor-pointer flex flex-col items-center justify-center transition-all min-h-[100px]"
                                >
                                    <span className="text-sm font-bold text-gray-300 uppercase tracking-widest">{new Date(year, i).toLocaleString("default", { month: "short" })}</span>
                                    <span className="text-lg font-mono font-black text-blue-400 mt-2">{formatDuration(totalMs)}</span>
                                    <span className="text-[10px] text-gray-500 mt-1">{monthLogs.length} Sessions</span>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        }
        // 2. Time Grid (Week/Day)
        // 2. Time Grid (Week/Day) - FIXED SCROLLING
        const renderTimeGrid = (days) => (
            <div
                ref={scrollRef}
                className="flex-1 overflow-auto bg-[#080808] relative custom-scroll flex"
                onWheel={(e) => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        setZoomLevel((z) => Math.min(3, Math.max(0.2, z + (e.deltaY > 0 ? -0.05 : 0.05))));
                    }
                }}
            >
                {/* LEFT TIME AXIS: The background spans the full height of the content */}
                <div className="sticky left-0 bg-[#111] border-r border-gray-800 z-20 flex-shrink-0" style={{ height: `${24 * 60 * zoomLevel + 32}px` }}>
                    <div className="h-8 border-b border-gray-800 bg-[#111] sticky top-0 z-30" /> {/* Top corner intersection */}
                    {Array.from({ length: 24 }).map((_, i) => (
                        <div key={i} className="text-[10px] text-gray-500 font-mono text-right pr-2 border-b border-gray-800/20" style={{ height: `${60 * zoomLevel}px`, lineHeight: `${20 * zoomLevel}px` }}>
                            {i}:00
                        </div>
                    ))}
                </div>

                <div className="flex flex-1" style={{ height: `${24 * 60 * zoomLevel + 32}px` }}>
                    {days.map((dateObj, idx) => {
                        const dateStr = dateObj.toDateString();
                        const dayLogs = logs.filter((l) => new Date(l.start_time).toDateString() === dateStr);
                        return (
                            <div key={idx} className="flex-1 border-r border-gray-800/50 relative min-w-[200px] bg-[#0c0c0c]">
                                {/* TOP DATE HEADER: Sticky and covers the full width */}
                                <div className="sticky top-0 bg-[#111] h-8 flex items-center justify-center text-[10px] font-bold text-gray-300 border-b border-gray-700 z-10 shadow-md">
                                    <span>{dateObj.toLocaleDateString(undefined, { weekday: "short", day: "numeric" })}</span>
                                </div>

                                <div className="relative w-full" style={{ height: `${24 * 60 * zoomLevel}px` }}>
                                    {/* Grid Lines */}
                                    {Array.from({ length: 24 }).map((_, i) => (
                                        <div key={i} className="border-b border-gray-800/10 w-full absolute" style={{ top: `${i * 60 * zoomLevel}px`, height: `${60 * zoomLevel}px` }} />
                                    ))}

                                    {/* LOG BLOCKS */}
                                    {dayLogs.map((log) => {
                                        const start = new Date(log.start_time);
                                        const end = log.end_time ? new Date(log.end_time) : new Date();

                                        // Calculate position in minutes from midnight
                                        const startMinutes = start.getHours() * 60 + start.getMinutes();
                                        const durationMinutes = (end.getTime() - start.getTime()) / 60000;

                                        return (
                                            <div
                                                key={log.id}
                                                className="absolute left-1 right-1 rounded border overflow-hidden text-[9px] p-1 flex flex-col shadow-sm hover:z-50 hover:scale-[1.02] transition-all"
                                                style={{
                                                    top: `${startMinutes * zoomLevel}px`,
                                                    height: `${Math.max(20, durationMinutes * zoomLevel)}px`, // Min height for visibility
                                                    backgroundColor: `${log.color_hex || "#3b82f6"}33`, // 20% opacity
                                                    borderColor: log.color_hex || "#3b82f6",
                                                }}
                                                onClick={() => {
                                                    setExpandedLogId(log.id);
                                                    setView("history"); // Jump to history details
                                                }}
                                            >
                                                <span className="font-bold text-white truncate">{log.task_title}</span>
                                                <span className="opacity-70">
                                                    {formatTime(start)} - {formatTime(end)}
                                                </span>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        );
                    })}
                </div>
            </div>
        );

        const gridDays =
            calendarMode === "week"
                ? Array.from({ length: 7 }, (_, i) => {
                      const d = new Date(selectedDate);
                      const day = d.getDay() || 7;
                      if (day !== 1) d.setHours(-24 * (day - 1));
                      d.setDate(d.getDate() + i);
                      return d;
                  })
                : [selectedDate];

        return (
            <div className="h-full flex flex-col bg-[#050505]">
                <CalendarHeader />
                {renderTimeGrid(gridDays)}
            </div>
        );
    };

    // -------------------------------------------------------------------------
    // 5. MAIN RENDER
    // -------------------------------------------------------------------------
    return (
        <div className="h-full w-full flex flex-col pt-10 overflow-visible relative">
            {/* Pill floats in the pt-10 zone */}
            {renderHeader()}
            
            {/* The Body uses flex-1 to fill the remaining HDWindowFrame space */}
            <div className="flex-1 flex flex-col bg-[#050505] rounded-xl border border-gray-800/50 shadow-2xl overflow-hidden relative">
                {view === "dashboard" && renderDashboard()}
                {view === "history" && renderHistory()}
                {view === "calendar" && renderCalendar()}
            </div>

            {/* Visual resize handle in bottom right corner */}
            <div className="absolute bottom-1 right-1 pointer-events-none opacity-20">
                <div className="w-4 h-4 border-r-2 border-b-2 border-white"></div>
            </div>
        </div>
    );
};

export default TasksApp;
```

```jsx
// frontend\src\components\Canvas.jsx
import React, { useState, useEffect, useRef } from "react";
import Note from "./Note";
import Frame from "./Frame";
import TaskWidget from "./TaskWidget";

const Canvas = ({ searchQuery = "", activeFilters = [], onTagClick, showTasks, bgColor = "#242424" }) => {
    const [data, setData] = useState({ notes: [], frames: [], tasks: [] });

    // View State: Separate Ref for physics (instant) and State for rendering (reactive)
    const viewRef = useRef({ x: 0, y: 0, scale: 1 });
    const [viewState, setViewState] = useState({ x: 0, y: 0, scale: 1 });

    const [isPanning, setIsPanning] = useState(false);
    const [isTeleporting, setIsTeleporting] = useState(false);

    const containerRef = useRef(null);

    // --- SYNC REFS & STATE ---
    const setView = (newView) => {
        viewRef.current = { ...viewRef.current, ...newView };
        setViewState(viewRef.current);
    };
    const fetchData = async () => {
        try {
            const token = await window.nativeAPI.getSecretToken();
            // Fetch latest data
            const res = await fetch("http://localhost:4000/api/all", {
                headers: { Authorization: `Bearer ${token}` },
            });
            const json = await res.json();

            // Update state
            setData(json);
            // NOTE: Do NOT dispatch 'cognicanvas:data-updated' here,
            // or you will create an infinite loop.
        } catch (e) {
            console.error(e);
        }
    };

    // REPLACED: Added listener for global sync
  useEffect(() => {
    // 1. Initial Load
    fetchData(); 

    // 2. Listen for updates from TasksApp or Widgets
    const handleRemoteUpdate = () => fetchData();
    window.addEventListener('cognicanvas:data-updated', handleRemoteUpdate);

    // 3. Cleanup
    return () => window.removeEventListener('cognicanvas:data-updated', handleRemoteUpdate);
  }, []);

    // --- LOGIC: Filter Matching ---
    const getFilterMatch = (item) => {
        const contentStr = (item.content || item.title || "").toLowerCase();
        const normSearch = searchQuery.toLowerCase();
        const matchesSearch = !searchQuery || contentStr.includes(normSearch);
        const matchesTags = activeFilters.length === 0 || (item.tags && item.tags.some((tag) => activeFilters.includes(tag.name)));
        return matchesSearch && matchesTags;
    };

    // --- NAVIGATION (Smooth Teleport) ---
    const teleportTo = (x, y) => {
        const container = containerRef.current;
        if (!container) return;

        setIsTeleporting(true); // Enable CSS transition

        const { clientWidth, clientHeight } = container;
        const newScale = 1; // Reset zoom to 1:1 for clarity

        const newX = clientWidth / 2 - x * newScale;
        const newY = clientHeight / 2 - y * newScale;

        setView({ x: newX, y: newY, scale: newScale });

        // Disable transition after animation to restore snappy panning
        setTimeout(() => setIsTeleporting(false), 350);
    };

    const focusOnItem = (type, id) => {
        const itemId = parseInt(id);
        let target = null;
        if (type === "note") target = data.notes.find((n) => n.id === itemId);
        else if (type === "frame") target = data.frames.find((f) => f.id === itemId);

        if (target) {
            const cx = target.pos_x + target.width / 2;
            const cy = target.pos_y + target.height / 2;
            teleportTo(cx, cy);
        }
    };

    // --- INTERACTIONS ---

    // 1. Native Wheel Zoom (Passive)
    useEffect(() => {
        const container = containerRef.current;
        if (!container) return;

        const handleWheelNative = (e) => {
            e.preventDefault();
            const current = viewRef.current;
            const rect = container.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const worldX = (mouseX - current.x) / current.scale;
            const worldY = (mouseY - current.y) / current.scale;

            const delta = -e.deltaY * 0.001;
            const newScale = Math.min(Math.max(current.scale + delta, 0.05), 4);

            const newX = mouseX - worldX * newScale;
            const newY = mouseY - worldY * newScale;

            setView({ x: newX, y: newY, scale: newScale });
        };

        container.addEventListener("wheel", handleWheelNative, { passive: false });
        return () => container.removeEventListener("wheel", handleWheelNative);
    }, []);

    // 2. Mouse Down (Strict Pan Guard)
    const handleMouseDown = (e) => {
        // INTERACTION GUARD:
        // Ignore pan if clicking specific interactive elements or draggables
        if (e.target.closest(".react-draggable") || e.target.closest("button") || e.target.closest("input") || e.target.closest(".pointer-events-auto")) {
            // Catch explicitly interactive children
            return;
        }

        // Logic: Middle Mouse (1) OR Left Click (0) + Alt
        const isMiddleMouse = e.button === 1 || e.buttons === 4;
        const isAltPan = e.button === 0 && e.altKey;

        if (isMiddleMouse || isAltPan) {
            e.preventDefault();
            setIsPanning(true);
        }
    };

    const handleMouseMove = (e) => {
        if (!isPanning) return;
        setView({ x: viewRef.current.x + e.movementX, y: viewRef.current.y + e.movementY });
    };

    const handleMouseUp = () => setIsPanning(false);

    // --- CRUD ACTIONS ---
    const handleDoubleClick = async (e) => {
        if (e.target !== containerRef.current && e.target.id !== "transform-layer") return;
        const rect = containerRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left - viewRef.current.x) / viewRef.current.scale;
        const y = (e.clientY - rect.top - viewRef.current.y) / viewRef.current.scale;
        const token = await window.nativeAPI.getSecretToken();
        await fetch("http://localhost:4000/api/notes", { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` }, body: JSON.stringify({ content: "New Note", pos_x: x - 100, pos_y: y - 100, width: 200, height: 200, color_hex: "#ffffff" }) });
        fetchData();
    };

    const handleNoteUpdateDrag = async (id, changes) => {
        let updates = { ...changes };
        if (changes.pos_x !== undefined) {
            const note = data.notes.find((n) => n.id === id);
            if (note) {
                const cx = changes.pos_x + note.width / 2;
                const cy = changes.pos_y + note.height / 2;
                const parentFrame = data.frames.find((f) => !f.is_collapsed && cx >= f.pos_x && cx <= f.pos_x + f.width && cy >= f.pos_y && cy <= f.pos_y + f.height);
                updates.frame_id = parentFrame ? parentFrame.id : null;
            }
        }
        setData((prev) => ({ ...prev, notes: prev.notes.map((n) => (n.id === id ? { ...n, ...updates } : n)) }));
        const token = await window.nativeAPI.getSecretToken();
        await fetch(`http://localhost:4000/api/notes/${id}`, { method: "PUT", headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` }, body: JSON.stringify(updates) });
    };

    const handleFrameDrag = (frameId, dx, dy) => {
        setData((prev) => ({
            ...prev,
            frames: prev.frames.map((f) => (f.id === frameId ? { ...f, pos_x: f.pos_x + dx, pos_y: f.pos_y + dy } : f)),
            notes: prev.notes.map((n) => (n.frame_id === frameId ? { ...n, pos_x: n.pos_x + dx, pos_y: n.pos_y + dy } : n)),
        }));
    };

    const handleFrameStop = async (id, finalPos) => {
        const token = await window.nativeAPI.getSecretToken();
        await fetch(`http://localhost:4000/api/frames/${id}`, { method: "PUT", headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` }, body: JSON.stringify(finalPos) });
        const children = data.notes.filter((n) => n.frame_id === id);
        for (const child of children) {
            await fetch(`http://localhost:4000/api/notes/${child.id}`, { method: "PUT", headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` }, body: JSON.stringify({ pos_x: child.pos_x, pos_y: child.pos_y }) });
        }
    };

    const handleUpdateFrame = async (id, changes) => {
        setData((prev) => ({ ...prev, frames: prev.frames.map((f) => (f.id === id ? { ...f, ...changes } : f)) }));
        const token = await window.nativeAPI.getSecretToken();
        await fetch(`http://localhost:4000/api/frames/${id}`, { method: "PUT", headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` }, body: JSON.stringify(changes) });
    };

    const handleTagAction = async (action, type, id, tagName) => {
        const token = await window.nativeAPI.getSecretToken();
        const url = action === "add" ? `http://localhost:4000/api/tags/${type}/${id}` : `http://localhost:4000/api/${type}/${id}/tags/${tagName}`;
        await fetch(url, { method: action === "add" ? "POST" : "DELETE", headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` }, body: action === "add" ? JSON.stringify({ name: tagName }) : undefined });
        fetchData();
    };

    // --- RENDER PREPARATION ---
    const notesToRender = data.notes
        .map((note) => {
            if (note.frame_id) {
                const parent = data.frames.find((f) => f.id === note.frame_id);
                if (parent && parent.is_collapsed) return null;
            }
            const isMatch = getFilterMatch(note);
            const isDimmed = (searchQuery || activeFilters.length > 0) && !isMatch;
            return (
                <Note
                    key={note.id}
                    note={note}
                    scale={viewState.scale}
                    isDimmed={isDimmed}
                    onNoteUpdate={handleNoteUpdateDrag}
                    onNoteDelete={async (id) => {
                        await fetch(`http://localhost:4000/api/notes/${id}`, { method: "DELETE", headers: { Authorization: `Bearer ${await window.nativeAPI.getSecretToken()}` } });
                        fetchData();
                    }}
                    onTagAdd={(type, id, name) => handleTagAction("add", type, id, name)}
                    onTagRemove={(type, id, name) => handleTagAction("remove", type, id, name)}
                    onDataChange={fetchData}
                    onNavigate={focusOnItem}
                />
            );
        })
        .filter(Boolean);

    const tasksToRender = data.tasks.map(task => {
      // Logic: Show if it matches search OR if it is currently running
      // This ensures active tasks don't disappear when you clear filters
      const isMatch = getFilterMatch(task);
      const shouldShow = isMatch || task.is_running;

      if (!shouldShow) return null;

      return (
         <div key={task.id} className="pointer-events-auto relative inline-block">
                <TaskWidget
                    task={task}
                    // When the widget stops/starts, it notifies the system
                    onUpdate={() => {
                        window.dispatchEvent(new CustomEvent("cognicanvas:data-updated"));
                    }}
                />
         </div>
      );
  }).filter(Boolean);

    return (
        <div
            ref={containerRef}
            onDoubleClick={handleDoubleClick}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
            className="w-full h-full overflow-hidden relative"
            style={{
                backgroundColor: bgColor,
                cursor: isPanning ? "grabbing" : "default",
            }}
        >
            {/* 1. WORLD SPACE (Transformed) */}
            <div
                id="transform-layer"
                style={{
                    transform: `translate(${viewState.x}px, ${viewState.y}px) scale(${viewState.scale})`,
                    transformOrigin: "0 0",
                    position: "absolute",
                    width: "100%",
                    height: "100%",
                    // Smoothly animate ONLY when teleporting to avoid physics lag
                    transition: isTeleporting ? "transform 0.35s cubic-bezier(0.2, 0.8, 0.2, 1)" : "none",
                    pointerEvents: "none", // Allow click-through to background
                }}
            >
                {/* Grid */}
                <div className="absolute opacity-10 top-[-200000px] left-[-200000px] w-[400000px] h-[400000px] pointer-events-none" style={{ backgroundImage: "radial-gradient(#888 1px, transparent 1px)", backgroundSize: "40px 40px" }} />

                {/* WORLD ITEMS - Re-enable events for interactivity */}
                <div className="pointer-events-auto">
                    {data.frames.map((frame) => (
                        <Frame
                            key={frame.id}
                            frame={frame}
                            scale={viewState.scale}
                            onUpdate={handleUpdateFrame}
                            onDelete={async (id) => {
                                await fetch(`http://localhost:4000/api/frames/${id}`, { method: "DELETE", headers: { Authorization: `Bearer ${await window.nativeAPI.getSecretToken()}` } });
                                fetchData();
                            }}
                            onDrag={handleFrameDrag}
                            onDragStop={handleFrameStop}
                        />
                    ))}
                    {notesToRender}
                </div>
            </div>

            {/* 2. HUD SPACE (Overlay) */}
            <div className="absolute inset-0 pointer-events-none overflow-hidden">
                {/* Container is pointer-events-none, ensuring clicks pass through to Canvas */}
                <div className="w-full h-full relative">{showTasks && tasksToRender}</div>
            </div>

            {/* DEBUG INFO */}
            <div className="absolute bottom-4 right-4 bg-black/50 backdrop-blur-md text-white px-3 py-1 rounded-full text-xs font-mono select-none pointer-events-none">
                {Math.round(viewState.scale * 100)}% | {Math.round(viewState.x)},{Math.round(viewState.y)}
            </div>
        </div>
    );
};

export default Canvas;
```

```jsx
// frontend\src\components\CommandPalette.jsx
import React, { useState, useEffect, useRef } from 'react';

const CommandPalette = ({ isOpen, onClose, onNavigate }) => {
  const [query, setQuery] = useState("");
  const [selectedIndex, setSelectedIndex] = useState(0);
  const inputRef = useRef(null);

  // Static Actions
  const ACTIONS = [
    { id: 'app:tasks', title: 'Open Tasks', icon: 'âœ…', action: () => window.dispatchEvent(new CustomEvent('cognicanvas:toggle-app', { detail: 'tasks' })) },
    { id: 'app:crypto', title: 'Open Cryptor', icon: 'ðŸ”’', action: () => window.dispatchEvent(new CustomEvent('cognicanvas:toggle-app', { detail: 'crypto' })) },
    { id: 'app:settings', title: 'Open Settings', icon: 'âš™ï¸', action: () => window.dispatchEvent(new CustomEvent('cognicanvas:toggle-app', { detail: 'settings' })) },
    { id: 'canvas:add-frame', title: 'New Frame', icon: 'squares', action: () => window.dispatchEvent(new CustomEvent('cognicanvas:add-frame')) },
    { id: 'sys:reload', title: 'Reload System', icon: 'ðŸ”„', action: () => window.location.reload() }
  ];

  const filteredItems = ACTIONS.filter(item => item.title.toLowerCase().includes(query.toLowerCase()));

  useEffect(() => {
    if (isOpen) {
      setTimeout(() => inputRef.current?.focus(), 50);
      setQuery("");
      setSelectedIndex(0);
    }
  }, [isOpen]);

  const handleKeyDown = (e) => {
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      setSelectedIndex(prev => (prev + 1) % filteredItems.length);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      setSelectedIndex(prev => (prev - 1 + filteredItems.length) % filteredItems.length);
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (filteredItems[selectedIndex]) {
        filteredItems[selectedIndex].action();
        onClose();
      }
    } else if (e.key === 'Escape') {
      onClose();
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-[9999] bg-black/60 backdrop-blur-sm flex items-start justify-center pt-[20vh]" onClick={onClose}>
      <div className="w-[600px] bg-[#1e1e1e] border border-gray-700 rounded-xl shadow-2xl overflow-hidden flex flex-col animate-in fade-in zoom-in-95 duration-100" onClick={e => e.stopPropagation()}>
        
        {/* Input */}
        <div className="flex items-center px-4 py-3 border-b border-gray-700">
          <span className="text-gray-400 text-lg mr-3">ðŸ”</span>
          <input 
            ref={inputRef}
            type="text" 
            className="flex-1 bg-transparent text-white text-lg outline-none placeholder-gray-500"
            placeholder="Type a command..."
            value={query}
            onChange={e => { setQuery(e.target.value); setSelectedIndex(0); }}
            onKeyDown={handleKeyDown}
          />
          <span className="text-xs text-gray-500 border border-gray-600 px-1.5 py-0.5 rounded">ESC</span>
        </div>

        {/* List */}
        <div className="max-h-[300px] overflow-y-auto py-2">
          {filteredItems.length === 0 ? (
            <div className="px-4 py-3 text-gray-500 text-sm">No results found.</div>
          ) : (
            filteredItems.map((item, index) => (
              <div 
                key={item.id}
                className={`px-4 py-3 flex items-center cursor-pointer transition-colors
                  ${index === selectedIndex ? 'bg-blue-600 text-white' : 'text-gray-300 hover:bg-gray-800'}
                `}
                onClick={() => { item.action(); onClose(); }}
                onMouseEnter={() => setSelectedIndex(index)}
              >
                <span className="mr-3 text-lg">{item.icon}</span>
                <span className="font-medium">{item.title}</span>
                {index === selectedIndex && <span className="ml-auto text-xs opacity-70">â†µ Enter</span>}
              </div>
            ))
          )}
        </div>
        
        {/* Footer */}
        <div className="bg-[#111] px-4 py-1.5 border-t border-gray-700 text-[10px] text-gray-500 flex justify-between">
            <span>CogniCanvas OS v1.0</span>
            <span>Use â†‘â†“ to navigate</span>
        </div>
      </div>
    </div>
  );
};

export default CommandPalette;
```

```jsx
// frontend\src\components\Frame.jsx
import React, { useRef, useState, useEffect } from "react";
import Draggable from "react-draggable";
import { ResizableBox } from "react-resizable";
import "react-resizable/css/styles.css";

const Frame = ({ frame, scale, onUpdate, onDelete, onDrag, onDragStop }) => {
  const nodeRef = useRef(null); // StrictMode compliance
  const [title, setTitle] = useState(frame.title);

  // Sync internal state if props change externally
  useEffect(() => {
    setTitle(frame.title);
  }, [frame.title]);

  const handleResizeStop = (e, data) => {
    onUpdate(frame.id, { width: data.size.width, height: data.size.height });
  };

  const handleTitleBlur = () => {
    if (title !== frame.title) {
      onUpdate(frame.id, { title });
    }
  };

  const toggleCollapse = () => {
    onUpdate(frame.id, { is_collapsed: !frame.is_collapsed });
  };

  return (
    <Draggable
      nodeRef={nodeRef}
      handle=".frame-handle"
      position={{ x: frame.pos_x, y: frame.pos_y }}
      scale={scale}
      onDrag={(e, data) => onDrag(frame.id, data.deltaX, data.deltaY)} // Real-time visual sync for children
      onStop={(e, data) => onDragStop(frame.id, { pos_x: data.x, pos_y: data.y })} // Persist on stop
    >
      <div
        ref={nodeRef}
        className="absolute z-10 group"
        style={{
          width: frame.width,
          height: frame.is_collapsed ? 'auto' : frame.height,
        }}
      >
        <ResizableBox
          width={frame.width}
          height={frame.is_collapsed ? 50 : frame.height}
          onResizeStop={handleResizeStop}
          minConstraints={[200, 50]}
          resizeHandles={frame.is_collapsed ? ['e'] : ['se', 'e', 's']}
          handle={
             !frame.is_collapsed && 
             <span className="react-resizable-handle react-resizable-handle-se opacity-0 group-hover:opacity-100 transition-opacity" />
          }
        >
          <div className="w-full h-full border-2 border-dashed border-gray-400/30 rounded-xl flex flex-col bg-gray-500/5 hover:bg-gray-500/10 transition-colors backdrop-blur-sm">
            
            {/* HEADER / DRAG HANDLE */}
            <div className="frame-handle h-10 flex items-center justify-between px-3 cursor-move bg-gray-700/20 rounded-t-xl select-none">
              <div className="flex items-center gap-2 text-white/70">
                <button 
                   onClick={toggleCollapse}
                   className="hover:text-white transition-colors text-xs"
                >
                  {frame.is_collapsed ? 'â–¶' : 'â–¼'}
                </button>
                <input
                  type="text"
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  onBlur={handleTitleBlur}
                  onMouseDown={(e) => e.stopPropagation()} // Allow clicking input without dragging
                  className="bg-transparent border-none outline-none font-bold font-mono text-sm w-40 text-white/80 focus:text-white placeholder-white/20"
                />
              </div>
              <button
                onClick={(e) => { e.stopPropagation(); onDelete(frame.id); }}
                className="text-white/30 hover:text-red-400 font-bold px-2"
                onMouseDown={(e) => e.stopPropagation()}
              >
                Ã—
              </button>
            </div>

            {/* COLLAPSED HINT */}
            {frame.is_collapsed && (
                <div className="px-3 py-1 text-xs text-white/40 italic">
                    {Math.round(frame.width)}px wide container (Collapsed)
                </div>
            )}

            {/* BACKGROUND LABEL (Visual Aid when expanded) */}
            {!frame.is_collapsed && (
               <div className="absolute bottom-2 right-2 text-white/5 font-black text-4xl pointer-events-none select-none uppercase">
                   FRAME
               </div>
            )}
          </div>
        </ResizableBox>
      </div>
    </Draggable>
  );
};

export default Frame;
```

```jsx
// frontend\src\components\HDWindowFrame.jsx
import React, { useState, useRef, useEffect, useCallback } from 'react';

const HDWindowFrame = ({ children, windowAPI: externalAPI, initialPos = { x: 100, y: 100 }, initialSize = { width: 500, height: 600 }, onDelete, onUpdate }) => {
    // 1. Local State (Used for initial render and final sync)
    const [pos, setPos] = useState(initialPos);
    const [size, setSize] = useState({ w: initialSize.width, h: initialSize.height });

    // 2. Direct DOM Access (To bypass React rendering during drag)
    const frameRef = useRef(null);

    // 3. Interaction State
    const interaction = useRef({
        active: false,
        type: null,
        startMouse: { x: 0, y: 0 },
        startRect: { x: 0, y: 0, w: 0, h: 0 }
    });

    const windowAPI = {
        dragHandleClass: "hd-drag-handle",
        size: size,
        close: () => onDelete?.()
    };

    // --- MOUSE DOWN ---
    const onMouseDown = (e) => {
        const target = e.target;
        let type = null;

        // Identify handles
        if (target.classList.contains('rs-e')) type = 'resize-e';
        else if (target.classList.contains('rs-s')) type = 'resize-s';
        else if (target.classList.contains('rs-se')) type = 'resize-se';
        else if (target.closest(`.${windowAPI.dragHandleClass}`)) type = 'move';

        if (!type || target.tagName === 'BUTTON' || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') return;

        e.preventDefault();
        e.stopPropagation();

        // Snapshot current values from DOM or State
        interaction.current = {
            active: true,
            type: type,
            startMouse: { x: e.clientX, y: e.clientY },
            // We use the current committed state as the baseline
            startRect: { x: pos.x, y: pos.y, w: size.w, h: size.h }
        };

        document.body.style.userSelect = 'none';
        document.body.style.cursor = type.includes('resize') 
            ? (type === 'resize-e' ? 'ew-resize' : 'nwse-resize') 
            : 'move';

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        // Optimization: Force GPU layer
        if (frameRef.current) {
            frameRef.current.style.transition = 'none';
            frameRef.current.style.willChange = 'width, height, left, top';
            frameRef.current.style.zIndex = '9999';
        }
    };

    // --- MOUSE MOVE (Direct DOM) ---
    const onMouseMove = useCallback((e) => {
        if (!interaction.current.active || !frameRef.current) return;

        requestAnimationFrame(() => {
            if (!interaction.current.active) return;

            const { type, startMouse, startRect } = interaction.current;
            const dx = e.clientX - startMouse.x;
            const dy = e.clientY - startMouse.y;
            const el = frameRef.current;

            if (type === 'move') {
                el.style.left = `${startRect.x + dx}px`;
                el.style.top = `${startRect.y + dy}px`;
            } else {
                let newW = startRect.w;
                let newH = startRect.h;

                if (type === 'resize-e' || type === 'resize-se') {
                    newW = Math.max(380, startRect.w + dx);
                    el.style.width = `${newW}px`;
                }
                if (type === 'resize-s' || type === 'resize-se') {
                    newH = Math.max(450, startRect.h + dy);
                    el.style.height = `${newH}px`;
                }
            }
        });
    }, []);

    // --- MOUSE UP ---
    const onMouseUp = useCallback(() => {
        if (!interaction.current.active) return;

        interaction.current.active = false;
        
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
        document.body.style.userSelect = 'auto';
        document.body.style.cursor = 'auto';

        if (frameRef.current) {
            frameRef.current.style.willChange = 'auto';
            frameRef.current.style.zIndex = ''; 

            // Read final DOM state
            const finalX = parseFloat(frameRef.current.style.left);
            const finalY = parseFloat(frameRef.current.style.top);
            const finalW = parseFloat(frameRef.current.style.width);
            const finalH = parseFloat(frameRef.current.style.height);

            // Update React State (Single Render)
            setPos({ x: finalX, y: finalY });
            setSize({ w: finalW, h: finalH });

            onUpdate?.({ x: finalX, y: finalY, w: finalW, h: finalH, type: interaction.current.type });
        }
    }, [onUpdate]);

    useEffect(() => {
        if (frameRef.current && !interaction.current.active) {
            frameRef.current.style.left = `${pos.x}px`;
            frameRef.current.style.top = `${pos.y}px`;
            frameRef.current.style.width = `${size.w}px`;
            frameRef.current.style.height = `${size.h}px`;
        }
    }, [pos, size]);

    return (
        <div 
            ref={frameRef}
            className="absolute z-50 flex flex-col overflow-visible shadow-2xl"
            style={{ 
                left: pos.x, 
                top: pos.y, 
                width: size.w, 
                height: size.h
            }}
            onMouseDown={onMouseDown}
        >
            {/* 
                CRITICAL FIX: 
                1. Removed the "Header Zone" duplicate render.
                2. Removed internal background/border styles (TasksApp handles its own bg/border).
                3. We render children EXACTLY ONCE.
            */}
            <div className="w-full h-full relative">
                {React.isValidElement(children) 
                    ? React.cloneElement(children, { windowAPI }) 
                    : children
                }
            </div>

            {/* --- RESIZE HANDLES (1/3 Rule) --- */}
            
            {/* Right Edge (Middle 1/3) */}
            <div className="rs-e absolute right-[-6px] top-[33.3%] h-[33.3%] w-[12px] cursor-ew-resize z-[110] group flex justify-center" title="Resize Width">
                <div className="rs-e w-1 h-full bg-transparent group-hover:bg-blue-500/50 rounded-full transition-colors" />
            </div>
            
            {/* Bottom Edge (Middle 1/3) */}
            <div className="rs-s absolute bottom-[-6px] left-[33.3%] w-[33.3%] h-[12px] cursor-ns-resize z-[110] group flex flex-col justify-center" title="Resize Height">
                <div className="rs-s h-1 w-full bg-transparent group-hover:bg-blue-500/50 rounded-full transition-colors" />
            </div>
            
            {/* Bottom Right Corner */}
            <div className="rs-se absolute bottom-[-6px] right-[-6px] w-8 h-8 cursor-nwse-resize z-[120] flex items-end justify-end p-2 group">
                <div className="rs-se w-3 h-3 border-r-2 border-b-2 border-gray-600 group-hover:border-blue-500 transition-colors" />
            </div>
        </div>
    );
};

export default HDWindowFrame;
```

```jsx
// frontend\src\components\KeyConfigForm.jsx
// frontend/src/components/KeyConfigForm.jsx
import React, { useState } from 'react';

// A simple reusable input component.
const FormInput = ({ label, value, onChange }) => (
  <label className="block">
    <span className="text-gray-700">{label}</span>
    <input type="text" value={value} onChange={onChange} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
  </label>
);

// A component for a list of values that can be added/removed.
const DynamicListInput = ({ label, items, setItems }) => {
  const handleItemChange = (index, value) => {
    const newItems = [...items];
    newItems[index] = value;
    setItems(newItems);
  };
  const addItem = () => setItems([...items, '']);
  const removeItem = (index) => setItems(items.filter((_, i) => i !== index));

  return (
    <div>
      <h3 className="text-lg font-medium">{label}</h3>
      {items.map((item, index) => (
        <div key={index} className="flex items-center space-x-2 mt-2">
          <input type="text" value={item} onChange={(e) => handleItemChange(index, e.target.value)} className="flex-grow rounded-md border-gray-300 shadow-sm" />
          <button onClick={() => removeItem(index)} className="px-2 py-1 bg-red-500 text-white rounded">-</button>
        </div>
      ))}
      <button onClick={addItem} className="mt-2 px-2 py-1 bg-green-500 text-white rounded">+</button>
    </div>
  );
};

function KeyConfigForm({ initialData, onSave, onCancel }) {
  const [key, setKey] = useState(initialData || {});

  const handleChange = (field) => (e) => {
    setKey({ ...key, [field]: e.target.value });
  };
  
  const handleListChange = (field) => (items) => {
    setKey({ ...key, [field]: items });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    // In a real app, perform validation here using a library like Zod.
    onSave(key);
  };

  return (
    <form onSubmit={handleSubmit} className="p-4 bg-white rounded-lg shadow-md space-y-4">
      <h2 className="text-xl font-bold">{key._id ? 'Edit Key' : 'Create New Key'}</h2>
      <FormInput label="Key Name" value={key.name || ''} onChange={handleChange('name')} />
      <FormInput label="Degree (d)" value={key.d || ''} onChange={handleChange('d')} />
      <FormInput label="Min Bound" value={key.minBound || '32'} onChange={handleChange('minBound')} />
      <FormInput label="Max Bound" value={key.maxBound || '126'} onChange={handleChange('maxBound')} />
      <DynamicListInput label="Start Values (starts)" items={key.starts || []} setItems={handleListChange('starts')} />
      <DynamicListInput label="Operations (I)" items={key.I || []} setItems={handleListChange('I')} />
      <DynamicListInput label="Transformation (TC)" items={key.TC || []} setItems={handleListChange('TC')} />
      <div className="flex justify-end space-x-2">
        <button type="button" onClick={onCancel} className="px-4 py-2 bg-gray-300 rounded">Cancel</button>
        <button type="submit" className="px-4 py-2 bg-blue-600 text-white rounded">Save</button>
      </div>
    </form>
  );
}

export default KeyConfigForm;    
```

```jsx
// frontend\src\components\Note.jsx
import React, { useRef, useState, useEffect, useLayoutEffect, useCallback } from "react";
import TagManager from "./TagManager";

const NOTE_COLORS = [
    { hex: '#ffffff', name: 'White', border: '#cbd5e1', header: '#f1f5f9' },
    { hex: '#fff59d', name: 'Yellow', border: '#fbc02d', header: '#fff176' },
    { hex: '#b2dfdb', name: 'Teal', border: '#00897b', header: '#80cbc4' },
    { hex: '#f8bbd0', name: 'Pink', border: '#ec407a', header: '#f48fb1' },
    { hex: '#c5e1a5', name: 'Green', border: '#7cb342', header: '#aed581' },
    { hex: '#ffcc80', name: 'Orange', border: '#fb8c00', header: '#ffb74d' },
    { hex: '#d1c4e9', name: 'Purple', border: '#7e57c2', header: '#b39ddb' },
    { hex: '#303030', name: 'Dark', border: '#000000', header: '#424242' },
    { hex: '#242424', name: 'Darker', border: '#000000', header: '#303030' },
    { hex: '#f83bff', name: 'Hot Pink', border: '#c000c0', header: '#f06292' },
];

// HELPER: Wiki-Style Links
const renderViewMode = (content) => {
    const safeContent = String(content || "");
    const internalLinkRegex = /\[\[(note|frame):(\d+)\]\]/g;
    let html = safeContent.replace(/\n/g, '<br>');
    html = html.replace(internalLinkRegex, (match, type, id) => {
        return `<span class="note-link inline-flex items-center gap-1 bg-blue-600/10 text-blue-700 px-1.5 py-0.5 rounded cursor-pointer select-none border border-blue-600/20 text-xs font-bold mx-0.5 hover:bg-blue-600/20" data-type="${type}" data-id="${id}">ðŸ”— ${type.toUpperCase()}:${id}</span>`;
    });
    return html;
};

const Note = ({ note, onNoteUpdate, onNoteDelete, onTagAdd, onTagRemove, onDataChange, onNavigate, scale = 1, isDimmed }) => {
    // REFS
    const noteRef = useRef(null); 
    const editRef = useRef(null);
    
    // STATES
    const [isEditing, setIsEditing] = useState(false);
    const [isDragging, setIsDragging] = useState(false); // Restored State
    const [localContent, setLocalContent] = useState(note.content);
    const [showColorMenu, setShowColorMenu] = useState(false);
    const [showCopyFeedback, setShowCopyFeedback] = useState(false);

    // Initial Positions (Synced with DB)
    const [pos, setPos] = useState({ x: note.pos_x, y: note.pos_y });
    const [size, setSize] = useState({ w: note.width, h: note.height });

    // INTERACTION STATE (Mutable, no re-renders for physics)
    const interaction = useRef({
        active: false,
        type: null, 
        startMouse: { x: 0, y: 0 },
        startRect: { x: 0, y: 0, w: 0, h: 0 }
    });

    // Sync state with props when not interacting
    useEffect(() => {
        if (!interaction.current.active) {
            setPos({ x: note.pos_x, y: note.pos_y });
            setSize({ w: note.width, h: note.height });
        }
    }, [note.pos_x, note.pos_y, note.width, note.height]);

    useEffect(() => {
        if (!isEditing) setLocalContent(note.content);
    }, [note.content, isEditing]);

    // UX: Focus text area on edit
    useLayoutEffect(() => {
        if (isEditing && editRef.current) {
            editRef.current.focus();
            const range = document.createRange();
            const sel = window.getSelection();
            range.selectNodeContents(editRef.current);
            range.collapse(false);
            sel.removeAllRanges();
            sel.addRange(range);
        }
    }, [isEditing]);

    // --- MANUAL PHYSICS SYSTEM ---

    const onMouseDown = (e) => {
        if (isEditing) return; 

        const target = e.target;
        let type = null;

        if (target.classList.contains('resize-handle')) type = 'resize';
        else if (target.closest('.drag-handle')) type = 'move';

        if (!type || target.tagName === 'BUTTON') return;

        e.preventDefault();
        e.stopPropagation();

        if (type === 'move') setIsDragging(true); // Trigger Ghost Render

        interaction.current = {
            active: true,
            type: type,
            startMouse: { x: e.clientX, y: e.clientY },
            startRect: { x: pos.x, y: pos.y, w: size.w, h: size.h }
        };

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        // Optimization: Lift to top
        if (noteRef.current) {
            noteRef.current.style.zIndex = "9999";
            noteRef.current.style.transition = "none"; 
        }
    };

    const onMouseMove = useCallback((e) => {
        if (!interaction.current.active || !noteRef.current) return;

        requestAnimationFrame(() => {
            if (!interaction.current.active) return;
            
            const { type, startMouse, startRect } = interaction.current;
            const dx = (e.clientX - startMouse.x) / scale;
            const dy = (e.clientY - startMouse.y) / scale;
            const el = noteRef.current;

            if (type === 'move') {
                const newX = startRect.x + dx;
                const newY = startRect.y + dy;
                el.style.left = `${newX}px`;
                el.style.top = `${newY}px`;
            } else if (type === 'resize') {
                const newW = Math.max(200, startRect.w + dx);
                const newH = Math.max(150, startRect.h + dy);
                el.style.width = `${newW}px`;
                el.style.height = `${newH}px`;
            }
        });
    }, [scale]);

    const onMouseUp = useCallback(() => {
        if (!interaction.current.active) return;
        
        setIsDragging(false); // Remove Ghost
        interaction.current.active = false;
        
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);

        if (noteRef.current) {
            // Read final DOM state
            const finalX = parseFloat(noteRef.current.style.left);
            const finalY = parseFloat(noteRef.current.style.top);
            const finalW = parseFloat(noteRef.current.style.width);
            const finalH = parseFloat(noteRef.current.style.height);

            noteRef.current.style.zIndex = "";
            noteRef.current.style.transition = "";

            // Update React State
            setPos({ x: finalX, y: finalY });
            setSize({ w: finalW, h: finalH });

            // Update DB
            onNoteUpdate(note.id, { 
                pos_x: finalX, 
                pos_y: finalY, 
                width: finalW, 
                height: finalH 
            });
        }
    }, [note.id, onNoteUpdate]);


    // --- RENDERING ---
    const colorObj = NOTE_COLORS.find(c => c.hex === note.color_hex) || NOTE_COLORS[0];
    const isDark = note.color_hex === '#303030' || note.color_hex === '#242424';
    const textColor = isDark ? 'text-gray-100' : 'text-gray-900';

    const handleViewClick = (e) => {
        if (e.target.closest('.note-link')) {
            e.stopPropagation(); e.preventDefault();
            const link = e.target.closest('.note-link');
            if (onNavigate) onNavigate(link.dataset.type, link.dataset.id);
            return;
        }
        e.stopPropagation(); 
        setIsEditing(true);
    };

    const handleBlur = () => {
        setIsEditing(false);
        if (editRef.current && editRef.current.innerText !== note.content) {
            onNoteUpdate(note.id, { content: editRef.current.innerText });
        }
    };

    return (
        <>
            {/* 1. GHOST PROXY (The visual anchor that stays behind) */}
            {isDragging && (
                <div 
                    className="absolute rounded-lg border-2 border-dashed opacity-30 z-10 pointer-events-none transition-none"
                    style={{
                        left: pos.x,
                        top: pos.y,
                        width: size.w,
                        height: size.h,
                        backgroundColor: colorObj.hex,
                        borderColor: colorObj.border
                    }}
                />
            )}

            {/* 2. REAL NOTE (The Moving Element) */}
            <div 
                ref={noteRef}
                className={`absolute flex flex-col rounded-lg overflow-hidden shadow-lg hover:shadow-xl transition-shadow 
                    ${isDimmed ? "opacity-30 pointer-events-none" : ""} 
                    ${isDragging ? "opacity-60 grayscale cursor-grabbing" : ""}`}
                style={{ 
                    left: pos.x, 
                    top: pos.y, 
                    width: size.w, 
                    height: size.h,
                    backgroundColor: colorObj.hex,
                    border: `1px solid ${colorObj.border}`,
                }}
                onMouseDown={onMouseDown}
            >
                {/* HEADER (Drag Handle) */}
                <div 
                    className="drag-handle h-9 min-h-[36px] w-full cursor-grab active:cursor-grabbing flex items-center justify-between px-2 select-none border-b transition-colors duration-200"
                    style={{ backgroundColor: colorObj.header, borderColor: colorObj.border }}
                >
                    <span className={`text-[10px] font-mono font-bold uppercase tracking-wider px-1.5 py-0.5 rounded bg-black/5 ${isDark ? 'text-white/60' : 'text-black/50'}`}>
                        #{note.id}
                    </span>

                    <div className="flex items-center gap-1.5" onMouseDown={(e) => e.stopPropagation()}>
                        {/* Color Picker */}
                        <div className="relative flex items-center">
                            <button 
                                onClick={() => setShowColorMenu(!showColorMenu)}
                                className="w-4 h-4 rounded-full border border-black/10 hover:scale-110 transition-transform shadow-sm"
                                style={{ backgroundColor: colorObj.hex }}
                            />
                            {showColorMenu && (
                                <div className="absolute top-6 right-0 bg-white border border-gray-200 shadow-2xl rounded-lg p-2 grid grid-cols-4 gap-2 w-36 z-[9999]">
                                    {NOTE_COLORS.map(c => (
                                        <button 
                                            key={c.hex} 
                                            className="w-6 h-6 rounded-full border border-gray-300 hover:scale-110 shadow-sm transition-transform"
                                            style={{ backgroundColor: c.hex }}
                                            onClick={() => { onNoteUpdate(note.id, { color_hex: c.hex }); setShowColorMenu(false); }}
                                        />
                                    ))}
                                </div>
                            )}
                        </div>
                        <div className={`h-4 w-px ${isDark ? 'bg-white/20' : 'bg-black/10'}`} />
                        <button onClick={() => { navigator.clipboard.writeText(`[[note:${note.id}]]`); setShowCopyFeedback(true); setTimeout(() => setShowCopyFeedback(false), 2000); }} 
                            className={`text-xs font-bold hover:scale-110 transition-transform ${isDark ? 'text-white/60 hover:text-white' : 'text-black/40 hover:text-black'}`}
                        >
                            {showCopyFeedback ? 'âœ“' : 'ðŸ”—'}
                        </button>
                        <button onClick={() => onNoteDelete(note.id)} 
                            className={`text-xs font-bold hover:scale-110 transition-transform hover:text-red-500 ${isDark ? 'text-white/60' : 'text-black/40'}`}
                        >
                            âœ•
                        </button>
                    </div>
                </div>

                {/* CONTENT */}
                <div className="flex-grow w-full relative overflow-hidden bg-transparent">
                    {!isEditing && (
                        <div 
                            className={`w-full h-full p-4 overflow-y-auto whitespace-pre-wrap font-sans duration-200 leading-relaxed cursor-text ${textColor}`}
                            onClick={handleViewClick}
                            dangerouslySetInnerHTML={{ __html: renderViewMode(localContent) }}
                        />
                    )}
                    {isEditing && (
                        <div 
                            ref={editRef}
                            contentEditable
                            suppressContentEditableWarning
                            className={`w-full h-full p-4 overflow-y-auto whitespace-pre-wrap font-sans transition-colors duration-200 leading-relaxed outline-none focus:ring-2 focus:ring-blue-500/20 ${textColor}`}
                            onBlur={handleBlur}
                        >
                            {localContent}
                        </div>
                    )}
                </div>

                {/* FOOTER */}
                <div className={`px-2 py-1.5 transition-colors duration-200 border-t bg-black/5 ${isDark ? 'border-white/10' : 'border-black/5'}`}>
                    <TagManager 
                        tags={note.tags || []} 
                        onAddTag={(t) => onTagAdd("notes", note.id, t)} 
                        onRemoveTag={(t) => onTagRemove("notes", note.id, t)} 
                        onDataChange={onDataChange} 
                    />
                </div>

                {/* MANUAL RESIZE HANDLE */}
                <div 
                    className={`resize-handle absolute bottom-0 right-0 w-5 h-5 cursor-nwse-resize z-20 flex items-end justify-end p-1 group opacity-0 group-hover:opacity-100 hover:opacity-100`}
                >
                     <div className={`pointer-events-none w-2 h-2 border-r-2 border-b-2 ${isDark ? 'border-white/40' : 'border-black/30'}`} />
                </div>
            </div>
        </>
    );
};

export default Note;
```

```jsx
// frontend\src\components\Notification.jsx
// frontend/src/components/Notification.jsx
import React, { useState, useEffect } from 'react';

function Notification({ message, duration = 5000 }) {
  const [visible, setVisible] = useState(false);

  useEffect(() => {
    if (message) {
      setVisible(true);
      const timer = setTimeout(() => {
        setVisible(false);
      }, duration);
      return () => clearTimeout(timer);
    }
  }, [message, duration]);

  if (!visible) return null;

  return (
    <div className="fixed top-5 right-5 bg-blue-500 text-white p-4 rounded-lg shadow-lg animate-fade-in-out">
      <h3 className="font-bold">{message.title}</h3>
      <p>{message.body}</p>
    </div>
  );
}

export default Notification;
```

```jsx
// frontend\src\components\ShortcutWidget.jsx
import React, { useState } from 'react';

const ShortcutWidget = ({ shortcut }) => {
  const [status, setStatus] = useState("Idle");

  const execute = async () => {
    // Check if the API is actually available
    if (!window.nativeAPI) {
      console.error("Native API not initialized");
      setStatus("Init Error");
      return;
    }

    setStatus("Running...");
    try {
      // FIXED: Changed from window.electronAPI to window.nativeAPI
      const token = await window.nativeAPI.getSecretToken();
      
      let url, body;
      if (shortcut.type === 'command') {
          url = 'http://localhost:4000/api/system/run';
          body = { command: shortcut.command, args: shortcut.args };
      } else {
          url = 'http://localhost:4000/api/system/open';
          body = { target: shortcut.target };
      }

      const res = await fetch(url, {
          method: 'POST',
          headers: { 
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(body)
      });
      
      const data = await res.json();
      if (data.success || data.code === 0) {
          setStatus("Done âœ…");
      } else {
          setStatus("Error âŒ");
      }
      
      setTimeout(() => setStatus("Idle"), 2000);
    } catch (e) {
      console.error(e);
      setStatus("Failed âš ï¸");
    }
  };

  return (
    <div 
      className="bg-gray-800 text-white p-3 rounded-lg shadow-lg w-48 flex items-center justify-between cursor-pointer hover:bg-gray-700 transition border border-gray-600 pointer-events-auto" 
      onClick={execute}
    >
      <div className="overflow-hidden">
        <div className="font-bold text-sm truncate">{shortcut.title}</div>
        <div className="text-[10px] uppercase tracking-tighter text-gray-400">{status}</div>
      </div>
      <div className="text-xl ml-2">ðŸš€</div>
    </div>
  );
};

export default ShortcutWidget;
```

```jsx
// frontend\src\components\TagManager.jsx
import React, { useRef } from "react";

// Helper Component for individual Tag Pills
const TagPill = ({ tag, onRemove, onColorChange }) => (
    <div 
        onClick={() => onColorChange(tag)} 
        className="flex items-center text-white text-xs font-semibold px-2 py-1 rounded-full cursor-pointer transition-transform hover:scale-105 select-none" 
        style={{ backgroundColor: tag.color_hex || '#3b82f6' }} 
        title="Double-click to change color"
    >
        <span>{tag.name}</span>
        <button
            onClick={(e) => {
                e.stopPropagation();
                onRemove(tag.name);
            }}
            className="ml-2 text-white opacity-50 hover:opacity-100 font-bold"
        >
            Ã—
        </button>
    </div>
);

const TagManager = ({ tags, onAddTag, onRemoveTag, onDataChange }) => {
    const colorInputRef = useRef(null);
    const tagToChangeRef = useRef(null);

    const handleKeyDown = (e) => {
        if (e.key === "Enter" && e.currentTarget.value.trim() !== "") {
            e.preventDefault();
            onAddTag(e.currentTarget.value.trim());
            e.currentTarget.value = "";
        }
    };

    const handleColorChange = (tag) => {
        tagToChangeRef.current = tag;
        if (colorInputRef.current) colorInputRef.current.click();
    };

    const onColorSelected = async (e) => {
        const newColor = e.target.value;
        const tag = tagToChangeRef.current;
        if (!tag || !newColor) return;

        try {
            const token = await window.nativeAPI.getSecretToken();
            await fetch(`http://localhost:4000/api/tags/${tag.name}`, {
                method: "PUT",
                headers: { 
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${token}` 
                },
                body: JSON.stringify({ color_hex: newColor }),
            });
            onDataChange(); // Refresh canvas data
        } catch (err) {
            console.error("Failed to update tag color", err);
        }
    };

    return (
        <div className="flex flex-wrap items-center gap-2 p-2 border-t border-black border-opacity-10 bg-white bg-opacity-20 mt-auto">
            {/* Hidden Color Input for Picker */}
            <input 
                type="color" 
                ref={colorInputRef} 
                onChange={onColorSelected} 
                className="w-0 h-0 opacity-0 absolute pointer-events-none" 
            />

            {(tags || []).map((tag) => (
                <TagPill 
                    key={tag.name} 
                    tag={tag} 
                    onRemove={onRemoveTag} 
                    onColorChange={handleColorChange} 
                />
            ))}
            
            <input 
                type="text" 
                onKeyDown={handleKeyDown} 
                placeholder="+ tag" 
                className="bg-transparent text-xs text-gray-600 placeholder-gray-400 focus:outline-none w-16 hover:w-24 transition-all" 
                onClick={(e) => e.stopPropagation()} 
            />
        </div>
    );
};

export default TagManager;
```

```jsx
// frontend\src\components\TaskWidget.jsx
import React, { useState, useEffect, useRef } from "react";
import Draggable from "react-draggable";
import { ResizableBox } from "react-resizable";
import * as API from "../api";
import "react-resizable/css/styles.css";

// --- HELPER: TIME FORMAT ---
const formatTime = (ms) => {
    if (!ms || ms < 0 || isNaN(ms)) return "00:00:00";
    const s = Math.floor((ms / 1000) % 60)
        .toString()
        .padStart(2, "0");
    const m = Math.floor((ms / 1000 / 60) % 60)
        .toString()
        .padStart(2, "0");
    const h = Math.floor(ms / 1000 / 3600)
        .toString()
        .padStart(2, "0");
    return `${h}:${m}:${s}`;
};

const TaskWidget = ({ task, onUpdate }) => {
    const nodeRef = useRef(null);

    // --- STATE ---
    // We initialize state, but we also watch for prop changes below
    const [localTask, setLocalTask] = useState(task);
    const [isVisible, setIsVisible] = useState(task.is_running);
    const [noteDraft, setNoteDraft] = useState("");

    // Timer State
    const [totalElapsed, setTotalElapsed] = useState(0);
    const [sessionElapsed, setSessionElapsed] = useState(0);

    // Random position only on first mount
    const [defaultPos] = useState({
        x: Math.random() * (window.innerWidth - 300) + 100,
        y: Math.random() * (window.innerHeight - 300) + 100,
    });

    // --- 1. REACTIVITY: Keep Local State in Sync with Props ---
    useEffect(() => {
        setLocalTask(task);
        // If the prop says it's running, force visibility
        if (task.is_running) setIsVisible(true);
    }, [task]);

    // --- 2. GLOBAL EVENT LISTENER (The "Remote Control") ---
    useEffect(() => {
        const handleSignals = async (e) => {
            // A. Visibility Toggle Signal
            if (e.type === "task:toggle-visibility") {
                if (e.detail.taskId === localTask.id) {
                    setIsVisible((prev) => !prev);
                }
            }
            // B. Data Update Signal (Re-fetch specific task to stay accurate)
            else if (e.type === "cognicanvas:data-updated") {
                try {
                    const data = await API.getTasks();
                    const updated = data.tasks.find((t) => t.id === localTask.id);

                    if (!updated) {
                        // Task was deleted from DB, hide myself
                        setIsVisible(false);
                        return;
                    }

                    setLocalTask(updated);
                    if (updated.is_running && !localTask.is_running) {
                        setIsVisible(true);
                    }
                } catch (err) {
                    console.error("Widget sync error:", err);
                }
            }
        };

        window.addEventListener("task:toggle-visibility", handleSignals);
        window.addEventListener("cognicanvas:data-updated", handleSignals);

        return () => {
            window.removeEventListener("task:toggle-visibility", handleSignals);
            window.removeEventListener("cognicanvas:data-updated", handleSignals);
        };
    }, [localTask.id, localTask.is_running]);

    // --- 3. CLOCK LOGIC ---
    useEffect(() => {
        const updateClocks = () => {
            if (!localTask.is_running) {
                setTotalElapsed(parseInt(localTask.total_time_ms) || 0);
                setSessionElapsed(0);
                return;
            }

            const startTime = new Date(localTask.current_session_start).getTime();
            const now = Date.now();
            const sessionDiff = Math.max(0, now - startTime);

            // Current Session Time
            setSessionElapsed(sessionDiff);
            // Total = Previous Total + Current Session
            setTotalElapsed((parseInt(localTask.total_time_ms) || 0) + sessionDiff);
        };

        // Run immediately and then interval
        updateClocks();
        const interval = setInterval(updateClocks, 1000);
        return () => clearInterval(interval);
    }, [localTask.is_running, localTask.current_session_start, localTask.total_time_ms]);

    // --- ACTIONS ---
    const handleToggle = async (e) => {
        e.stopPropagation(); // Prevent drag
        const action = localTask.is_running ? "stop" : "start";

        try {
            const result = await API.toggleTask(localTask.id, action, { manual_note: noteDraft });

            if (action === "stop") {
                setNoteDraft(""); // Clear note on stop
                // Optional: Hide widget on stop?
                // setIsVisible(false);
            }

            // Broadcast update so TasksApp and other Widgets know
            window.dispatchEvent(new CustomEvent("cognicanvas:data-updated"));
            if (onUpdate) onUpdate();
        } catch (err) {
            if (err.message.includes("already running")) {
                alert("Another protocol is active. Please terminate it first.");
            } else {
                console.error(err);
            }
        }
    };

    if (!isVisible) return null;

    // --- STYLES ---
    const glowStyle = {
        boxShadow: localTask.is_running ? `0 10px 30px -10px ${localTask.color_hex || "#3b82f6"}aa` : `0 4px 15px -5px rgba(0,0,0,0.5)`,
        borderColor: localTask.is_running
            ? `${localTask.color_hex}ff` // Full opacity when running
            : `${localTask.color_hex}66`, // 40% opacity when idle
        borderTopWidth: "4px", // Thicker top bar in task color
    };
    return (
        <Draggable nodeRef={nodeRef} handle=".drag-handle" defaultPosition={defaultPos}>
            <div ref={nodeRef} className="absolute z-50 pointer-events-auto">
                <ResizableBox
                    width={180}
                    height={170}
                    minConstraints={[160, 160]}
                    maxConstraints={[300, 300]}
                    className="rounded-2xl backdrop-blur-md overflow-hidden transition-opacity ease-in-out transition-colors duration-300"
                    style={{
                        ...glowStyle,
                        backgroundColor: "#000000aa",
                        borderWidth: "1px",
                    }}
                >
                    {/* FIX: Wrap everything in a single container div */}
                    <div className="w-full h-full flex flex-col">
                        {/* HEADER / DRAG HANDLE */}
                        <div
                            className="drag-handle h-9 cursor-move flex justify-between items-center px-3 border-b border-white/10 hover:brightness-125 transition-all shrink-0"
                            style={{ backgroundColor: `${localTask.color_hex}33` }} // 20% tint of task color
                        >
                            <div className="flex items-center gap-2">
                                <div className={`w-2 h-2 rounded-full ${localTask.is_running ? "animate-pulse" : ""}`} style={{ backgroundColor: localTask.color_hex }} />
                                <span className="text-[10px] font-black text-white uppercase tracking-widest">{localTask.is_running ? "Running" : "Standby"}</span>
                            </div>
                            <button onClick={() => setIsVisible(false)} className="text-gray-500 hover:text-white text-lg leading-none mb-1">
                                &times;
                            </button>
                        </div>

                        {/* CONTENT */}
                        <div className="flex-1 flex flex-col p-3 relative min-h-0">
                            {/* TITLE */}
                            <div className="text-center mb-2">
                                <h4 className="text-white text-xs font-bold truncate px-1" title={localTask.title}>
                                    {localTask.title}
                                </h4>
                            </div>

                            {/* TIMERS */}
                            <div className="flex-1 flex flex-col justify-center items-center">
                                <div className="text-2xl font-mono font-bold text-white tracking-tight drop-shadow-md">{formatTime(totalElapsed)}</div>
                                {localTask.is_running && <div className="text-[10px] font-mono text-green-400 mt-1 bg-green-900/20 px-2 rounded">Session: {formatTime(sessionElapsed)}</div>}
                            </div>

                            {/* CONTROLS */}
                            <div className="mt-3 flex flex-col gap-2">
                                {localTask.is_running && <input className="bg-black/50 border border-gray-700 rounded px-2 py-1 text-[10px] text-white focus:border-blue-500 outline-none w-full" placeholder="Session note..." value={noteDraft} onChange={(e) => setNoteDraft(e.target.value)} onMouseDown={(e) => e.stopPropagation()} />}

                                <button
                                    onClick={handleToggle}
                                    onMouseDown={(e) => e.stopPropagation()}
                                    className={`w-full py-2 rounded text-[10px] font-black uppercase tracking-widest transition-all duration-300
        ${localTask.is_running ? "bg-red-500/10 text-red-500 border border-red-500/50 hover:bg-red-600 hover:text-white" : "text-white shadow-lg hover:brightness-110 active:scale-95"}`}
                                    style={
                                        !localTask.is_running
                                            ? {
                                                  backgroundColor: localTask.color_hex,
                                                  boxShadow: `0 4px 15px -2px ${localTask.color_hex}66`,
                                              }
                                            : {}
                                    }
                                >
                                    {localTask.is_running ? "Terminate Session" : "Execute Protocol"}
                                </button>
                            </div>
                        </div>
                    </div>{" "}
                    {/* End of wrapper div */}
                </ResizableBox>
            </div>
        </Draggable>
    );
};

export default TaskWidget;
```

```jsx
// frontend\src\components\WindowFrame.jsx
import React, { useRef } from 'react'; 
import Draggable from 'react-draggable';

const WindowFrame = ({ title, onClose, children, initialPos = { x: 100, y: 100 }, width = 500, chromeless = false }) => {
  const nodeRef = useRef(null);

  // 1. DETERMINE MODE
  // If the title is TasksApp, or the prop is explicitly set, we go "Chromeless"
  const isChromeless = chromeless || title === "TasksApp";

  return (
        <Draggable 
            nodeRef={nodeRef} 
            handle={`.${windowAPI.dragHandleClass}`} 
            defaultPosition={initialPos}
            // Use onStop to persist coordinates
            onStop={(e, data) => onUpdate?.({ x: data.x, y: data.y, w: size.width, h: size.height })}
        >
            <div 
                ref={nodeRef} 
                className="absolute z-50 group" 
                style={{ width: size.width, height: size.height, touchAction: 'none' }}
            >
                <ResizableBox
                    width={size.width}
                    height={size.height}
                    minConstraints={[350, 400]}
                    onResize={(e, data) => {
                        setSize({ width: data.size.width, height: data.size.height });
                    }}
                    onResizeStop={(e, data) => {
                        onUpdate?.({ w: data.size.width, h: data.size.height });
                    }}
                    resizeHandles={['e', 's', 'se']}
                    handle={(h) => (
                        <div className={`absolute z-[60] opacity-0 group-hover:opacity-100 transition-opacity
                            ${h === 'e' ? 'right-0 top-0 w-2 h-full cursor-ew-resize bg-blue-500/20' : 
                              h === 's' ? 'bottom-0 left-0 h-2 w-full cursor-ns-resize bg-blue-500/20' : 
                              'bottom-0 right-0 w-6 h-6 cursor-nwse-resize flex items-end justify-end p-1'}`}
                        >
                            {h === 'se' && <div className="w-2 h-2 border-r-2 border-b-2 border-blue-400" />}
                        </div>
                    )}
                >
                    {/* The content wrapper must have absolute fill to avoid collapsing */}
                    <div className="absolute inset-0 pointer-events-auto overflow-visible">
                        {React.isValidElement(children) ? React.cloneElement(children, { windowAPI }) : children}
                    </div>
                </ResizableBox>
            </div>
        </Draggable>
    );
};

export default WindowFrame;
```

```jsx
// frontend\src\pages\Dashboard.jsx
// frontend/src/pages/Dashboard.jsx
import React, { useState, useEffect } from 'react';
// In Dashboard.jsx
import ShortcutWidget from '../components/ShortcutWidget';

// /!\ WARNING /!\
// This file was edited to remove all IPC calls to the main process.
// The backend server now handles all operations via REST API calls.
// Ensure the backend server is running and accessible for this to work.
// If window.electronAPI calls are found here, be careful if they are available or not.
// If not, replace them with appropriate API calls to the backend server.
/* Example replacement:

// In the same React component (e.g., KeyManager.jsx)

// No longer importing 'api' for IPC calls, as it's now for HTTP or removed.
// Access window.electronAPI directly, as it's exposed by the preload script.

const handleOpenFile = async () => {
  // Ensure window.electronAPI is available before calling its methods
  if (window.electronAPI && window.electronAPI.selectFile) {
    const filePath = await window.electronAPI.selectFile();
    if (filePath) {
      console.log('Selected file:', filePath);
    }
  } else {
    console.error("Electron API for file selection not available.");
  }
};


*/
import { getKeys, encryptFile, decryptFile, selectFile } from "../api";

function Dashboard() {
  const [selectedFile, setSelectedFile] = useState(null);
  const [keys, setKeys] = useState([]);
  const [selectedKeyId, setSelectedKeyId] = useState('');
  const [intensity, setIntensity] = useState(10); // Default intensity

  useEffect(() => {
    getKeys().then(setKeys);
  }, []);

  const handleFileSelect = async () => {
    const path = await selectFile();
    if (path) {
      setSelectedFile({ path, name: path.split(/[/\\]/).pop() });
    }
  };

  const handleEncrypt = async () => {
    if (!selectedFile || !selectedKeyId) {
      alert('Please select a file and a key.');
      return;
    }
    const selectedKey = keys.find(k => k._id === selectedKeyId);
    await encryptFile(selectedFile.path, selectedKey, intensity);
    setSelectedFile(null); // Clear after operation
  };

  const handleDecrypt = async () => {
    if (!selectedFile || !selectedKeyId) {
      alert('Please select a file and a key.');
      return;
    }
    const selectedKey = keys.find(k => k._id === selectedKeyId);
    await decryptFile(selectedFile.path, selectedKey);
    setSelectedFile(null); // Clear after operation
  };

  return (
    <div>
      <h1 className="text-3xl font-bold mb-6">Dashboard</h1>
      <div className="bg-white p-6 rounded-lg shadow-lg">
        {/* File Selection */}
        <div className="mb-4">
          <button onClick={handleFileSelect} className="px-4 py-2 bg-blue-500 text-white rounded">
            Select File
          </button>
          {selectedFile && <span className="ml-4 text-gray-700">Selected: {selectedFile.name}</span>}
        </div>

        {/* Key and Intensity Selection */}
        <div className="flex items-center space-x-4 mb-6">
          <select value={selectedKeyId} onChange={(e) => setSelectedKeyId(e.target.value)} className="p-2 border rounded">
            <option value="">-- Select a Key --</option>
            {keys.map(key => <option key={key._id} value={key._id}>{key.name}</option>)}
          </select>
          <label className="flex items-center space-x-2">
            <span>Time Intensity:</span>
            <input 
              type="range" 
              min="1" 
              max="1000" 
              value={intensity} 
              onChange={(e) => setIntensity(parseInt(e.target.value))} 
              className="w-48"
            />
            <span>{intensity}</span>
          </label>
        </div>

        {/* Action Buttons */}
        <div className="flex space-x-4">
          <button onClick={handleEncrypt} className="px-6 py-3 bg-green-600 text-white font-bold rounded hover:bg-green-700 disabled:bg-gray-400" disabled={!selectedFile || !selectedKeyId}>
            Encrypt
          </button>
          <button onClick={handleDecrypt} className="px-6 py-3 bg-red-600 text-white font-bold rounded hover:bg-red-700 disabled:bg-gray-400" disabled={!selectedFile || !selectedKeyId}>
            Decrypt
          </button>
        </div>
      </div>
      // Inside your render/return:
<div className="absolute top-20 left-20">
    <ShortcutWidget 
        shortcut={{ 
            title: "MPSI Drive", 
            target: "C:\\Users\\aperonylo\\Documents\\MPSI", 
            type: "url" 
        }} 
    />
</div>
<div className="absolute top-40 left-20">
    <ShortcutWidget 
        shortcut={{ 
            title: "Wolfram Alpha", 
            target: "https://www.wolframalpha.com", 
            type: "url" 
        }} 
    />
</div>
    </div>
    
  );
}

export default Dashboard;
```

```jsx
// frontend\src\pages\KeyManager.jsx
// frontend/src/pages/KeyManager.jsx
import React, { useState, useEffect } from 'react';
import { getKeys, saveKey } from '../api.js'; // Import the new API module
// Assume KeyConfigForm is a component for editing key details
import KeyConfigForm from '../components/KeyConfigForm'; 

function KeyManager() {
  const [keys, setKeys] = useState([]);
  const [selectedKey, setSelectedKey] = useState(null);

  const refreshKeys = () => {
    getKeys().then(setKeys);
  };

  useEffect(() => {
    refreshKeys();
  }, []);

  const handleSaveKey = async (keyData) => {
    await saveKey(keyData);
    refreshKeys();
    setSelectedKey(null); // Close the form
  };

  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-4">Key Manager</h1>
      <div className="flex space-x-4">
        <div className="w-1/3">
          <button onClick={() => setSelectedKey({})} className="w-full p-2 bg-blue-500 text-white rounded">
            Create New Key
          </button>
          <ul className="mt-4 space-y-2">
            {keys.map(key => (
              <li key={key._id} onClick={() => setSelectedKey(key)} className="p-2 border rounded cursor-pointer hover:bg-gray-200">
                {key.name}
              </li>
            ))}
          </ul>
        </div>
        <div className="w-2/3">
          {selectedKey && (
            <KeyConfigForm
              initialData={selectedKey}
              onSave={handleSaveKey}
              onCancel={() => setSelectedKey(null)}
            />
          )}
        </div>
      </div>
    </div>
  );
}

export default KeyManager;
```

```css
// frontend\src\styles\calendar.css
/* frontend/src/styles/calendar.css */

.calendar-wrapper {
  display: flex;
  flex-direction: column;
  height: 100%;
  background-color: #111;
  color: #e5e7eb;
}

/* --- Month Grid --- */
.month-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 1px;
  background-color: #374151; /* Border color between cells */
  border: 1px solid #374151;
}

.day-cell {
  background-color: #1f2937;
  min-height: 80px;
  position: relative;
  transition: background-color 0.2s;
  padding: 4px;
}

.day-cell:hover {
  background-color: #2a3546;
}

.day-cell.inactive {
  background-color: #111827;
  opacity: 0.5;
}

/* --- Day View (Time Blocking) --- */
.day-view-container {
  position: relative;
  flex: 1;
  background: repeating-linear-gradient(
    0deg,
    #1f2937 0px,
    #1f2937 1px,
    transparent 1px,
    transparent 60px
  );
  background-size: 100% 60px; /* One hour slots */
}

.time-slot-label {
  position: absolute;
  left: 4px;
  font-size: 10px;
  color: #6b7280;
}

.task-block {
  position: absolute;
  left: 50px;
  right: 10px;
  border-radius: 4px;
  padding: 4px;
  font-size: 11px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  cursor: pointer;
  transition: transform 0.1s;
}

.task-block:hover {
  transform: scale(1.01);
  z-index: 10;
}
.scrollbar-thin::-webkit-scrollbar {
    width: 6px;
    height: 6px;
}
.scrollbar-thin::-webkit-scrollbar-track {
    background: transparent;
}
.scrollbar-thin::-webkit-scrollbar-thumb {
    background-color: #4b5563;
    border-radius: 3px;
}

/* Transitions for calendar blocks */
.task-block-transition {
    transition: top 0.2s ease, height 0.2s ease;
}


/* frontend/src/styles/calendar.css */

.calendar-wrapper {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  background-color: #000;
  color: #e5e7eb;
}

/* Custom Scrollbar for better visibility */
.custom-scroll::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
.custom-scroll::-webkit-scrollbar-track {
  background: #111;
}
.custom-scroll::-webkit-scrollbar-thumb {
  background-color: #444;
  border-radius: 4px;
  border: 1px solid #111;
}
.custom-scroll::-webkit-scrollbar-thumb:hover {
  background-color: #666;
}

/* Year View Grid */
.year-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr); /* 4 columns (3 rows) */
  gap: 8px;
  padding: 10px;
  height: 100%;
}

.mini-month {
  background: #111;
  border: 1px solid #333;
  border-radius: 4px;
  padding: 4px;
  display: flex;
  flex-direction: column;
}

.mini-month-grid {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 1px;
  flex: 1;
}

.mini-day {
  height: 100%;
  min-height: 12px;
  border-radius: 1px;
}
```

```js
// frontend\src\styles\theme.js
export const NOTE_COLORS = {
    yellow: "#fff000",
    blue: "#a7ffeb",
    pink: "#f8bbd0",
    green: "#ccff90"
};
```

```js
// shared\constants.js
// shared/constants.js
// This contract ensures the frontend and backend always speak the same language.
// Changing a value here updates it everywhere.

module.exports = {
  IPC_CHANNELS: {
    // File operations
    FILE_SELECT: 'file:select',
    FILE_ENCRYPT: 'file:encrypt',
    FILE_DECRYPT: 'file:decrypt',
    
    // Database: Keys
    DB_GET_KEYS: 'db:get-keys',
    DB_SAVE_KEY: 'db:save-key',
    DB_DELETE_KEY: 'db:delete-key',

    // Database: Peers & Seeds
    DB_GET_PEERS: 'db:get-peers',
    DB_ADD_PEER: 'db:add-peer',

    // P2P operations
    P2P_CREATE_SEED: 'p2p:create-seed',
    P2P_SEND_FILE: 'p2p:send-file',

    // UI Notifications
    NOTIFY_USER: 'notify:user',
    NOTIFY_PROGRESS: 'notify:progress',
  }
};
```

